[
  {
    "className": "ArcGISTiledElevationTerrainProvider",
    "methodName": "ArcGISTiledElevationTerrainProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\", {\n *   token: \"KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\"\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n *"
  },
  {
    "className": "ArcGISTiledElevationTerrainProvider",
    "methodName": "fromUrl",
    "description": "Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\", {\n *   token: \"KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\"\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n *"
  },
  {
    "className": "AxisAlignedBoundingBox",
    "methodName": "fromCorners",
    "description": "Creates an instance of an AxisAlignedBoundingBox from its corners.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Compute an axis aligned bounding box from the two corners.\n * const box = Cesium.AxisAlignedBoundingBox.fromCorners(new Cesium.Cartesian3(-1, -1, -1), new Cesium.Cartesian3(1, 1, 1));"
  },
  {
    "className": "AxisAlignedBoundingBox",
    "methodName": "fromPoints",
    "description": "Computes an instance of an AxisAlignedBoundingBox. The box is determined by",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Compute an axis aligned bounding box enclosing two points.\n * const box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);"
  },
  {
    "className": "BoundingSphere",
    "methodName": "fromVertices",
    "description": "Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Compute the bounding sphere from 3 positions, each specified relative to a center.\n * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n * // elements per point which are ignored for the purpose of computing the bounding sphere.\n * const center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const points = [1.0, 2.0, 3.0, 0.1, 0.2,\n *               4.0, 5.0, 6.0, 0.1, 0.2,\n *               7.0, 8.0, 9.0, 0.1, 0.2];\n * const sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n *\n *"
  },
  {
    "className": "BoundingSphere",
    "methodName": "fromCornerPoints",
    "description": "Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a bounding sphere around the unit cube\n * const sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));"
  },
  {
    "className": "BoundingSphere",
    "methodName": "fromEllipsoid",
    "description": "Creates a bounding sphere encompassing an ellipsoid.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);"
  },
  {
    "className": "BoundingSphere",
    "methodName": "distanceSquaredTo",
    "description": "Computes the estimated distance squared from the closest point on a bounding sphere to a point.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n * });"
  },
  {
    "className": "BoundingSphere",
    "methodName": "transformWithoutScale",
    "description": "Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n * const boundingSphere = new Cesium.BoundingSphere();\n * const newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);"
  },
  {
    "className": "BoundingSphere",
    "methodName": "distanceSquaredTo",
    "description": "Computes the estimated distance squared from the closest point on a bounding sphere to a point.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });"
  },
  {
    "className": "BoxGeometry",
    "methodName": "BoxGeometry",
    "description": "Describes a cube centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const box = new Cesium.BoxGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * const geometry = Cesium.BoxGeometry.createGeometry(box);"
  },
  {
    "className": "BoxGeometry",
    "methodName": "fromDimensions",
    "description": "Creates a cube centered at the origin given its dimensions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const box = Cesium.BoxGeometry.fromDimensions({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.BoxGeometry.createGeometry(box);\n *\n *"
  },
  {
    "className": "BoxGeometry",
    "methodName": "fromAxisAlignedBoundingBox",
    "description": "Creates a cube from the dimensions of an AxisAlignedBoundingBox.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * const box = Cesium.BoxGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n *"
  },
  {
    "className": "BoxOutlineGeometry",
    "methodName": "BoxOutlineGeometry",
    "description": "A description of the outline of a cube centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const box = new Cesium.BoxOutlineGeometry({\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);"
  },
  {
    "className": "BoxOutlineGeometry",
    "methodName": "fromDimensions",
    "description": "Creates an outline of a cube centered at the origin given its dimensions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const box = Cesium.BoxOutlineGeometry.fromDimensions({\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n *\n *"
  },
  {
    "className": "BoxOutlineGeometry",
    "methodName": "fromAxisAlignedBoundingBox",
    "description": "Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * const box = Cesium.BoxOutlineGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n *"
  },
  {
    "className": "Cartesian2",
    "methodName": "fromArray",
    "description": "Creates a Cartesian2 from two consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a Cartesian2 with (1.0, 2.0)\n * const v = [1.0, 2.0];\n * const p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0];\n * const p2 = Cesium.Cartesian2.fromArray(v2, 2);"
  },
  {
    "className": "Cartesian2",
    "methodName": "distance",
    "description": "Computes the distance between two points.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 1.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));"
  },
  {
    "className": "Cartesian2",
    "methodName": "distanceSquared",
    "description": "Computes the squared distance between two points.  Comparing squared distances",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromArray",
    "description": "Creates a Cartesian3 from three consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * const v = [1.0, 2.0, 3.0];\n * const p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * const p2 = Cesium.Cartesian3.fromArray(v2, 2);"
  },
  {
    "className": "Cartesian3",
    "methodName": "distance",
    "description": "Computes the distance between two points.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 1.0\n * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));"
  },
  {
    "className": "Cartesian3",
    "methodName": "distanceSquared",
    "description": "Computes the squared distance between two points.  Comparing squared distances",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromDegrees",
    "description": "Returns a Cartesian3 position from longitude and latitude values given in degrees.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromRadians",
    "description": "Returns a Cartesian3 position from longitude and latitude values given in radians.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromDegreesArray",
    "description": "Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromRadiansArray",
    "description": "Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromDegreesArrayHeights",
    "description": "Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromRadiansArrayHeights",
    "description": "Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);"
  },
  {
    "className": "Cartesian4",
    "methodName": "fromArray",
    "description": "Creates a Cartesian4 from four consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * const v = [1.0, 2.0, 3.0, 4.0];\n * const p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * const p2 = Cesium.Cartesian4.fromArray(v2, 2);"
  },
  {
    "className": "Cartesian4",
    "methodName": "distance",
    "description": "Computes the 4-space distance between two points.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 1.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));"
  },
  {
    "className": "Cartesian4",
    "methodName": "distanceSquared",
    "description": "Computes the squared distance between two points.  Comparing squared distances",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));"
  },
  {
    "className": "CatmullRomSpline",
    "methodName": "CatmullRomSpline",
    "description": "A Catmull-Rom spline is a cubic spline where the tangent at control points,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // spline above the earth from Philadelphia to Los Angeles\n * const spline = new Cesium.CatmullRomSpline({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[i]);         // equal to positions[i]\n * const p1 = spline.evaluate(times[i] + delta); // interpolated value when delta < times[i + 1] - times[i]\n *\n *"
  },
  {
    "className": "Cesium3DTilesTerrainProvider",
    "methodName": "fromUrl",
    "description": "Creates a {@link TerrainProvider} that accesses terrain data in a Cesium 3D Tiles format.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.Cesium3DTilesTerrainProvider.fromUrl(\n *       Cesium.IonResource.fromAssetId(3956), {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }"
  },
  {
    "className": "Cesium3DTilesTerrainProvider",
    "methodName": "fromIonAssetId",
    "description": "Creates a {@link TerrainProvider} from a Cesium ion asset ID that accesses terrain data in a Cesium 3D Tiles format",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create GTOPO30 with vertex normals\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.Cesium3DTilesTerrainProvider.fromIonAssetId(2732686, {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "CesiumTerrainProvider",
    "methodName": "CesiumTerrainProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {\n *       requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "CesiumTerrainProvider",
    "methodName": "fromIonAssetId",
    "description": "Creates a {@link TerrainProvider} from a Cesium ion asset ID that accesses terrain data in a Cesium terrain format",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "CesiumTerrainProvider",
    "methodName": "fromUrl",
    "description": "Creates a {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromUrl(\n *       Cesium.IonResource.fromAssetId(3956), {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "CircleGeometry",
    "methodName": "CircleGeometry",
    "description": "A description of a circle on the ellipsoid. Circle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a circle.\n * const circle = new Cesium.CircleGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   radius : 100000.0\n * });\n * const geometry = Cesium.CircleGeometry.createGeometry(circle);"
  },
  {
    "className": "CircleOutlineGeometry",
    "methodName": "CircleOutlineGeometry",
    "description": "A description of the outline of a circle on the ellipsoid.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a circle.\n * const circle = new Cesium.CircleOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   radius : 100000.0\n * });\n * const geometry = Cesium.CircleOutlineGeometry.createGeometry(circle);"
  },
  {
    "className": "Clock",
    "methodName": "Clock",
    "description": "A simple clock for keeping track of simulated time.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a clock that loops on Christmas day 2013 and runs in real-time.\n * const clock = new Cesium.Clock({\n *    startTime : Cesium.JulianDate.fromIso8601(\"2013-12-25\"),\n *    currentTime : Cesium.JulianDate.fromIso8601(\"2013-12-25\"),\n *    stopTime : Cesium.JulianDate.fromIso8601(\"2013-12-26\"),\n *    clockRange : Cesium.ClockRange.LOOP_STOP,\n *    clockStep : Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER\n * });\n *\n *"
  },
  {
    "className": "Color",
    "methodName": "fromAlpha",
    "description": "Creates a new Color that has the same red, green, and blue components",
    "parameters": [],
    "returnType": "unknown",
    "example": "const translucentRed = Cesium.Color.fromAlpha(Cesium.Color.RED, 0.9);"
  },
  {
    "className": "Color",
    "methodName": "fromRgba",
    "description": "Creates a new Color from a single numeric unsigned 32-bit RGBA value, using the endianness",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const color = Cesium.Color.fromRgba(0x67ADDFFF);\n *\n *"
  },
  {
    "className": "Color",
    "methodName": "fromRandom",
    "description": "Creates a random color using the provided options. For reproducible random colors, you should",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create a completely random color\n * const color = Cesium.Color.fromRandom();\n *\n * //Create a random shade of yellow.\n * const color1 = Cesium.Color.fromRandom({\n *     red : 1.0,\n *     green : 1.0,\n *     alpha : 1.0\n * });\n *\n * //Create a random bright color.\n * const color2 = Cesium.Color.fromRandom({\n *     minimumRed : 0.75,\n *     minimumGreen : 0.75,\n *     minimumBlue : 0.75,\n *     alpha : 1.0\n * });"
  },
  {
    "className": "Color",
    "methodName": "fromCssColorString",
    "description": "Creates a Color instance from a CSS color value.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cesiumBlue = Cesium.Color.fromCssColorString('#67ADDF');\n * const green = Cesium.Color.fromCssColorString('green');\n *\n *"
  },
  {
    "className": "Color",
    "methodName": "toRgba",
    "description": "Converts this color to a single numeric unsigned 32-bit RGBA value, using the endianness",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const rgba = Cesium.Color.BLUE.toRgba();\n *\n *"
  },
  {
    "className": "Color",
    "methodName": "brighten",
    "description": "Brightens this color by the provided magnitude.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const brightBlue = Cesium.Color.BLUE.brighten(0.5, new Cesium.Color());"
  },
  {
    "className": "Color",
    "methodName": "darken",
    "description": "Darkens this color by the provided magnitude.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const darkBlue = Cesium.Color.BLUE.darken(0.5, new Cesium.Color());"
  },
  {
    "className": "Color",
    "methodName": "withAlpha",
    "description": "Creates a new Color that has the same red, green, and blue components",
    "parameters": [],
    "returnType": "unknown",
    "example": "const translucentRed = Cesium.Color.RED.withAlpha(0.9);"
  },
  {
    "className": "ColorGeometryInstanceAttribute",
    "methodName": "ColorGeometryInstanceAttribute",
    "description": "Value and type information for per-instance geometry color.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const instance = new Cesium.GeometryInstance({\n *   geometry : Cesium.BoxGeometry.fromDimensions({\n *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(red, green, blue, alpha)\n *   }\n * });\n *\n *"
  },
  {
    "className": "ColorGeometryInstanceAttribute",
    "methodName": "fromColor",
    "description": "Creates a new {@link ColorGeometryInstanceAttribute} instance given the provided {@link Color}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const instance = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.CORNFLOWERBLUE),\n *   }\n * });"
  },
  {
    "className": "ColorGeometryInstanceAttribute",
    "methodName": "toValue",
    "description": "Converts a color to a typed array that can be used to assign a color attribute.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA, attributes.color);"
  },
  {
    "className": "ComponentDatatype",
    "methodName": "getSizeInBytes",
    "description": "Returns the size, in bytes, of the corresponding datatype.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns Int8Array.BYTES_PER_ELEMENT\n * const size = Cesium.ComponentDatatype.getSizeInBytes(Cesium.ComponentDatatype.BYTE);"
  },
  {
    "className": "ComponentDatatype",
    "methodName": "validate",
    "description": "Validates that the provided component datatype is a valid {@link ComponentDatatype}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* if (!Cesium.ComponentDatatype.validate(componentDatatype)) {\n *   throw new Cesium.DeveloperError('componentDatatype must be a valid value.');\n * }"
  },
  {
    "className": "ComponentDatatype",
    "methodName": "createTypedArray",
    "description": "Creates a typed array corresponding to component data type.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates a Float32Array with length of 100\n * const typedArray = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 100);"
  },
  {
    "className": "ConstantSpline",
    "methodName": "ConstantSpline",
    "description": "A spline that evaluates to a constant value. Although this follows the {@link Spline} interface,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const position = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const spline = new Cesium.ConstantSpline(position);\n *\n * const p0 = spline.evaluate(0.0);\n *\n *"
  },
  {
    "className": "CoplanarPolygonGeometry",
    "methodName": "CoplanarPolygonGeometry",
    "description": "A description of a polygon composed of arbitrary coplanar positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const polygonGeometry = new Cesium.CoplanarPolygonGeometry({\n *  polygonHierarchy: new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArrayHeights([\n *      -90.0, 30.0, 0.0,\n *      -90.0, 30.0, 300000.0,\n *      -80.0, 30.0, 300000.0,\n *      -80.0, 30.0, 0.0\n *   ]))\n * });\n *"
  },
  {
    "className": "CoplanarPolygonGeometry",
    "methodName": "fromPositions",
    "description": "A description of a coplanar polygon from an array of positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a polygon from points\n * const polygon = Cesium.CoplanarPolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n *"
  },
  {
    "className": "CoplanarPolygonOutlineGeometry",
    "methodName": "CoplanarPolygonOutlineGeometry",
    "description": "A description of the outline of a polygon composed of arbitrary coplanar positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *      -90.0, 30.0, 0.0,\n *      -90.0, 30.0, 1000.0,\n *      -80.0, 30.0, 1000.0,\n *      -80.0, 30.0, 0.0\n *   ])\n * });\n * const geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);"
  },
  {
    "className": "CorridorGeometry",
    "methodName": "CorridorGeometry",
    "description": "A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const corridor = new Cesium.CorridorGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });"
  },
  {
    "className": "CorridorOutlineGeometry",
    "methodName": "CorridorOutlineGeometry",
    "description": "A description of a corridor outline.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const corridor = new Cesium.CorridorOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });"
  },
  {
    "className": "Credit",
    "methodName": "Credit",
    "description": "A credit contains data pertaining to how to display attributions/credits for certain content on the screen.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a credit with a tooltip, image and link\n * const credit = new Cesium.Credit('<a href=\"https://cesium.com/\" target=\"_blank\"><img src=\"/images/cesium_logo.png\"  style=\"vertical-align: -7px\" title=\"Cesium\"/></a>');"
  },
  {
    "className": "CustomHeightmapTerrainProvider",
    "methodName": "CustomHeightmapTerrainProvider",
    "description": "A simple {@link TerrainProvider} that gets height values from a callback function.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   terrainProvider: new Cesium.CustomHeightmapTerrainProvider({\n *     width: 32,\n *     height: 32,\n *     callback: function (x, y, level) {\n *       return new Float32Array(32 * 32); // all zeros\n *     },\n *   }),\n * });\n *\n *"
  },
  {
    "className": "CylinderGeometry",
    "methodName": "CylinderGeometry",
    "description": "A description of a cylinder.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create cylinder geometry\n * const cylinder = new Cesium.CylinderGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderGeometry.createGeometry(cylinder);"
  },
  {
    "className": "CylinderOutlineGeometry",
    "methodName": "CylinderOutlineGeometry",
    "description": "A description of the outline of a cylinder.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create cylinder geometry\n * const cylinder = new Cesium.CylinderOutlineGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);"
  },
  {
    "className": "DistanceDisplayCondition",
    "methodName": "DistanceDisplayCondition",
    "description": "Determines visibility based on the distance to the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Make a billboard that is only visible when the distance to the camera is between 10 and 20 meters.\n * billboard.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(10.0, 20.0);"
  },
  {
    "className": "DistanceDisplayConditionGeometryInstanceAttribute",
    "methodName": "DistanceDisplayConditionGeometryInstanceAttribute",
    "description": "Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.BoxGeometry({\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)\n *   }\n * });\n *\n *"
  },
  {
    "className": "DistanceDisplayConditionGeometryInstanceAttribute",
    "methodName": "fromDistanceDisplayCondition",
    "description": "Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);\n * const instance = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   attributes : {\n *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n *   }\n * });"
  },
  {
    "className": "DistanceDisplayConditionGeometryInstanceAttribute",
    "methodName": "toValue",
    "description": "Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);"
  },
  {
    "className": "EarthOrientationParameters",
    "methodName": "fromUrl",
    "description": "* @param {Resource|string} [url] The URL from which to obtain EOP data.  If neither this",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // An example EOP data file, EOP.json:\n * {\n *   \"columnNames\" : [\"dateIso8601\",\"modifiedJulianDateUtc\",\"xPoleWanderRadians\",\"yPoleWanderRadians\",\"ut1MinusUtcSeconds\",\"lengthOfDayCorrectionSeconds\",\"xCelestialPoleOffsetRadians\",\"yCelestialPoleOffsetRadians\",\"taiMinusUtcSeconds\"],\n *   \"samples\" : [\n *      \"2011-07-01T00:00:00Z\",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,\n *      \"2011-07-02T00:00:00Z\",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,\n *      \"2011-07-03T00:00:00Z\",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0\n *   ]\n * }\n *\n *"
  },
  {
    "className": "EasingFunction",
    "methodName": "freeze",
    "description": "Function interface for implementing a custom easing function.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* function quadraticIn(time) {\n *     return time * time;\n * }\n *\n *"
  },
  {
    "className": "EllipseGeometry",
    "methodName": "EllipseGeometry",
    "description": "A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create an ellipse.\n * const ellipse = new Cesium.EllipseGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n *\n *"
  },
  {
    "className": "EllipseOutlineGeometry",
    "methodName": "EllipseOutlineGeometry",
    "description": "A description of the outline of an ellipse on an ellipsoid.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const ellipse = new Cesium.EllipseOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);"
  },
  {
    "className": "Ellipsoid",
    "methodName": "function",
    "description": "The default ellipsoid used when not otherwise specified.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.Ellipsoid.default = Cesium.Ellipsoid.MOON;\n   *\n   * // Apollo 11 landing site\n   * const position = Cesium.Cartesian3.fromRadians(\n   *   0.67416,\n   *   23.47315,\n   * );"
  },
  {
    "className": "Ellipsoid",
    "methodName": "cartographicToCartesian",
    "description": "Converts the provided cartographic to Cartesian representation.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * const cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);"
  },
  {
    "className": "Ellipsoid",
    "methodName": "cartographicArrayToCartesianArray",
    "description": "Converts the provided array of cartographics to an array of Cartesians.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * const cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);"
  },
  {
    "className": "Ellipsoid",
    "methodName": "cartesianToCartographic",
    "description": "Converts the provided cartesian to cartographic representation.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * const cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);"
  },
  {
    "className": "Ellipsoid",
    "methodName": "cartesianArrayToCartographicArray",
    "description": "Converts the provided array of cartesians to an array of cartographics.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * const cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);"
  },
  {
    "className": "EllipsoidGeometry",
    "methodName": "EllipsoidGeometry",
    "description": "A description of an ellipsoid centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const ellipsoid = new Cesium.EllipsoidGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);"
  },
  {
    "className": "EllipsoidOutlineGeometry",
    "methodName": "EllipsoidOutlineGeometry",
    "description": "A description of the outline of an ellipsoid centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const ellipsoid = new Cesium.EllipsoidOutlineGeometry({\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),\n *   stackPartitions: 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);"
  },
  {
    "className": "EllipsoidalOccluder",
    "methodName": "EllipsoidalOccluder",
    "description": "Determine whether or not other objects are visible or hidden behind the visible horizon defined by",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * const cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * const occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n *"
  },
  {
    "className": "EllipsoidalOccluder",
    "methodName": "isPointVisible",
    "description": "Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true"
  },
  {
    "className": "EllipsoidalOccluder",
    "methodName": "isScaledSpacePointVisible",
    "description": "Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * const scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true"
  },
  {
    "className": "EncodedCartesian3",
    "methodName": "encode",
    "description": "Encodes a 64-bit floating-point value as two floating-point values that, when converted to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const value = 1234567.1234567;\n * const splitValue = Cesium.EncodedCartesian3.encode(value);"
  },
  {
    "className": "EncodedCartesian3",
    "methodName": "fromCartesian",
    "description": "Encodes a {@link Cartesian3} with 64-bit floating-point components as two {@link Cartesian3}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cart = new Cesium.Cartesian3(-10000000.0, 0.0, 10000000.0);\n * const encoded = Cesium.EncodedCartesian3.fromCartesian(cart);"
  },
  {
    "className": "EncodedCartesian3",
    "methodName": "writeElements",
    "description": "Encodes the provided <code>cartesian</code>, and writes it to an array with <code>high</code>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = [\n *    new Cesium.Cartesian3(),\n *    // ...\n * ];\n * const encodedPositions = new Float32Array(2 * 3 * positions.length);\n * let j = 0;\n * for (let i = 0; i < positions.length; ++i) {\n *   Cesium.EncodedCartesian3.writeElement(positions[i], encodedPositions, j);\n *   j += 6;\n * }"
  },
  {
    "className": "Event",
    "methodName": "Event",
    "description": "A generic utility class for managing subscribers for a particular event.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* MyObject.prototype.myListener = function(arg1, arg2) {\n *     this.myArg1Copy = arg1;\n *     this.myArg2Copy = arg2;\n * }\n *\n * const myObjectInstance = new MyObject();\n * const evt = new Cesium.Event();\n * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);\n * evt.raiseEvent('1', '2');\n * evt.removeEventListener(MyObject.prototype.myListener);"
  },
  {
    "className": "EventHelper",
    "methodName": "EventHelper",
    "description": "A convenience object that simplifies the common pattern of attaching event listeners",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const helper = new Cesium.EventHelper();\n *\n * helper.add(someObject.event, listener1, this);\n * helper.add(otherObject.event, listener2, this);\n *\n * // later...\n * helper.removeAll();\n *\n *"
  },
  {
    "className": "Fullscreen",
    "methodName": "requestFullscreen",
    "description": "Asynchronously requests the browser to enter fullscreen mode on the given element.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Put the entire page into fullscreen.\n * Cesium.Fullscreen.requestFullscreen(document.body)\n *\n * // Place only the Cesium canvas into fullscreen.\n * Cesium.Fullscreen.requestFullscreen(scene.canvas)"
  },
  {
    "className": "Geometry",
    "methodName": "Geometry",
    "description": "A geometry representation with attributes forming vertices and optional index data",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create geometry with a position attribute and indexed lines.\n * const positions = new Float64Array([\n *   0.0, 0.0, 0.0,\n *   7500000.0, 0.0, 0.0,\n *   0.0, 7500000.0, 0.0\n * ]);\n *\n * const geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,\n *       componentsPerAttribute : 3,\n *       values : positions\n *     })\n *   },\n *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),\n *   primitiveType : Cesium.PrimitiveType.LINES,\n *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)\n * });"
  },
  {
    "className": "Geometry",
    "methodName": "attributes",
    "description": "Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry.attributes.position = new Cesium.GeometryAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.FLOAT,\n   *   componentsPerAttribute : 3,\n   *   values : new Float32Array(0)\n   * });\n   *\n   *"
  },
  {
    "className": "Geometry",
    "methodName": "computeNumberOfVertices",
    "description": "Computes the number of vertices in a geometry.  The runtime is linear with",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);"
  },
  {
    "className": "GeometryAttribute",
    "methodName": "GeometryAttribute",
    "description": "Values and type information for geometry attributes.  A {@link Geometry}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.FLOAT,\n *       componentsPerAttribute : 3,\n *       values : new Float32Array([\n *         0.0, 0.0, 0.0,\n *         7500000.0, 0.0, 0.0,\n *         0.0, 7500000.0, 0.0\n *       ])\n *     })\n *   },\n *   primitiveType : Cesium.PrimitiveType.LINE_LOOP\n * });\n *\n *"
  },
  {
    "className": "GeometryAttribute",
    "methodName": "componentsPerAttribute",
    "description": "A number between 1 and 4 that defines the number of components in an attributes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n   * attribute.componentsPerAttribute = 3;\n   * attribute.values = new Float32Array([\n   *   0.0, 0.0, 0.0,\n   *   7500000.0, 0.0, 0.0,\n   *   0.0, 7500000.0, 0.0\n   * ]);"
  },
  {
    "className": "GeometryAttribute",
    "methodName": "normalize",
    "description": "When <code>true</code> and <code>componentDatatype</code> is an integer format,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\n   * attribute.componentsPerAttribute = 4;\n   * attribute.normalize = true;\n   * attribute.values = new Uint8Array([\n   *   Cesium.Color.floatToByte(color.red),\n   *   Cesium.Color.floatToByte(color.green),\n   *   Cesium.Color.floatToByte(color.blue),\n   *   Cesium.Color.floatToByte(color.alpha)\n   * ]);"
  },
  {
    "className": "GeometryAttribute",
    "methodName": "values",
    "description": "The values for the attributes stored in a typed array.  In the code example,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n   * attribute.componentsPerAttribute = 3;\n   * attribute.values = new Float32Array([\n   *   0.0, 0.0, 0.0,\n   *   7500000.0, 0.0, 0.0,\n   *   0.0, 7500000.0, 0.0\n   * ]);"
  },
  {
    "className": "GeometryInstance",
    "methodName": "GeometryInstance",
    "description": "Geometry instancing allows one {@link Geometry} object to be positions in several",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create geometry for a box, and two instances that refer to it.\n * // One instance positions the box on the bottom and colored aqua.\n * // The other instance positions the box on the top and color white.\n * const geometry = Cesium.BoxGeometry.fromDimensions({\n *   vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *   dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n * });\n * const instanceBottom = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   },\n *   id : 'bottom'\n * });\n * const instanceTop = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 3000000.0), new Cesium.Matrix4()),\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   },\n *   id : 'top'\n * });\n *\n *"
  },
  {
    "className": "GeometryInstanceAttribute",
    "methodName": "GeometryInstanceAttribute",
    "description": "Values and type information for per-instance geometry attributes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const instance = new Cesium.GeometryInstance({\n *   geometry : Cesium.BoxGeometry.fromDimensions({\n *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     color : new Cesium.GeometryInstanceAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n *       componentsPerAttribute : 4,\n *       normalize : true,\n *       value : [255, 255, 0, 255]\n *     })\n *   }\n * });\n *\n *"
  },
  {
    "className": "GeometryInstanceAttribute",
    "methodName": "componentsPerAttribute",
    "description": "A number between 1 and 4 that defines the number of components in an attributes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* show : new Cesium.GeometryInstanceAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n   *   componentsPerAttribute : 1,\n   *   normalize : true,\n   *   value : [1.0]\n   * })"
  },
  {
    "className": "GeometryInstanceAttribute",
    "methodName": "normalize",
    "description": "When <code>true</code> and <code>componentDatatype</code> is an integer format,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\n   * attribute.componentsPerAttribute = 4;\n   * attribute.normalize = true;\n   * attribute.value = [\n   *   Cesium.Color.floatToByte(color.red),\n   *   Cesium.Color.floatToByte(color.green),\n   *   Cesium.Color.floatToByte(color.blue),\n   *   Cesium.Color.floatToByte(color.alpha)\n   * ];"
  },
  {
    "className": "GeometryInstanceAttribute",
    "methodName": "value",
    "description": "The values for the attributes stored in a typed array.  In the code example,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* show : new Cesium.GeometryInstanceAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n   *   componentsPerAttribute : 1,\n   *   normalize : true,\n   *   value : [1.0]\n   * })"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "toWireframe",
    "description": "Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.toWireframe(geometry);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "createLineSegmentsForVectors",
    "description": "Creates a new {@link Geometry} with <code>LINES</code> representing the provided",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "createAttributeLocations",
    "description": "Creates an object that maps attribute names to unique locations (indices)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\n * // Example output\n * // {\n * //   'position' : 0,\n * //   'normal' : 1\n * // }"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "reorderForPreVertexCache",
    "description": "Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\n *\n *"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "reorderForPostVertexCache",
    "description": "Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\n *\n *"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "fitToUnsignedShortIndices",
    "description": "Splits a geometry into multiple geometries, if necessary, to ensure that indices in the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "projectTo2D",
    "description": "Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "encodeAttribute",
    "description": "Encodes floating-point geometry attribute values as two separate attributes to improve",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "transformToWorldCoordinates",
    "description": "Transforms a geometry instance to world coordinates.  This changes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.GeometryPipeline.transformToWorldCoordinates(instance);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "combineInstances",
    "description": "Combines geometry from several {@link GeometryInstance} objects into one geometry.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* for (let i = 0; i < instances.length; ++i) {\n *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\n * }\n * const geometries = Cesium.GeometryPipeline.combineInstances(instances);\n *\n *"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "computeNormal",
    "description": "Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.GeometryPipeline.computeNormal(geometry);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "computeTangentAndBitangent",
    "description": "Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "compressVertices",
    "description": "Compresses and packs geometry normal attribute values to save memory.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.compressVertices(geometry);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "splitLongitude",
    "description": "Splits the instances's geometry, by introducing new vertices and indices,that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* instance = Cesium.GeometryPipeline.splitLongitude(instance);"
  },
  {
    "className": "GoogleEarthEnterpriseTerrainData",
    "methodName": "GoogleEarthEnterpriseTerrainData",
    "description": "Terrain data for a single tile from a Google Earth Enterprise server.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const buffer = ...\n * const childTileMask = ...\n * const terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({\n *   buffer : heightBuffer,\n *   childTileMask : childTileMask\n * });\n *\n *"
  },
  {
    "className": "GoogleEarthEnterpriseTerrainProvider",
    "methodName": "GoogleEarthEnterpriseTerrainProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseTerrainProvider.fromMetadata(geeMetadata);\n *\n *"
  },
  {
    "className": "GoogleEarthEnterpriseTerrainProvider",
    "methodName": "fromMetadata",
    "description": "Creates a GoogleEarthTerrainProvider from GoogleEarthEnterpriseMetadata",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseTerrainProvider.fromMetadata(geeMetadata);"
  },
  {
    "className": "GroundPolylineGeometry",
    "methodName": "GroundPolylineGeometry",
    "description": "A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -112.1340164450331, 36.05494287836128,\n *   -112.08821010582645, 36.097804071380715,\n *   -112.13296079730024, 36.168769146801104\n * ]);\n *\n * const geometry = new Cesium.GroundPolylineGeometry({\n *   positions : positions\n * });"
  },
  {
    "className": "HeightmapTerrainData",
    "methodName": "HeightmapTerrainData",
    "description": "Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const buffer = ...\n * const heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * const childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * const waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * const terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n *"
  },
  {
    "className": "HeightmapTessellator",
    "methodName": "computeVertices",
    "description": "Fills an array of vertices from a heightmap image.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const width = 5;\n * const height = 5;\n * const statistics = Cesium.HeightmapTessellator.computeVertices({\n *     heightmap : [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0],\n *     width : width,\n *     height : height,\n *     skirtHeight : 0.0,\n *     nativeRectangle : {\n *         west : 10.0,\n *         east : 20.0,\n *         south : 30.0,\n *         north : 40.0\n *     }\n * });\n *\n * const encoding = statistics.encoding;\n * const position = encoding.decodePosition(statistics.vertices, index);"
  },
  {
    "className": "HermiteSpline",
    "methodName": "HermiteSpline",
    "description": "A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a G<sup>1</sup> continuous Hermite spline\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.HermiteSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     outTangents : [\n *         new Cesium.Cartesian3(1125196, -161816, 270551),\n *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),\n *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),\n *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)\n *     ],\n *     inTangents : [\n *         new Cesium.Cartesian3(-1993381, -731813, 368057),\n *         new Cesium.Cartesian3(-4193834, 96759, -585367),\n *         new Cesium.Cartesian3(-1781805, 817999, -894230),\n *         new Cesium.Cartesian3(1165345, 112641, 47281)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n *"
  },
  {
    "className": "HermiteSpline",
    "methodName": "createC1",
    "description": "Creates a spline where the tangents at each control point are the same.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const points = [\n *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n * ];\n *\n * // Add tangents\n * const tangents = new Array(points.length);\n * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);\n * const temp = new Cesium.Cartesian3();\n * for (let i = 1; i < tangents.length - 1; ++i) {\n *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());\n * }\n * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);\n *\n * const spline = Cesium.HermiteSpline.createC1({\n *     times : times,\n *     points : points,\n *     tangents : tangents\n * });"
  },
  {
    "className": "HermiteSpline",
    "methodName": "createNaturalCubic",
    "description": "Creates a natural cubic spline. The tangents at the control points are generated",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createNaturalCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });"
  },
  {
    "className": "HermiteSpline",
    "methodName": "createClampedCubic",
    "description": "Creates a clamped cubic spline. The tangents at the interior control points are generated",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createClampedCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),\n *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)\n * });"
  },
  {
    "className": "IndexDatatype",
    "methodName": "getSizeInBytes",
    "description": "Returns the size, in bytes, of the corresponding datatype.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 2\n * const size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);"
  },
  {
    "className": "IndexDatatype",
    "methodName": "validate",
    "description": "Validates that the provided index datatype is a valid {@link IndexDatatype}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n * }"
  },
  {
    "className": "IndexDatatype",
    "methodName": "createTypedArray",
    "description": "Creates a typed array that will store indices, using either <code><Uint16Array</code>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);"
  },
  {
    "className": "IntersectionTests",
    "methodName": "lineSegmentPlane",
    "description": "Computes the intersection of a line segment and a plane.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * const intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);"
  },
  {
    "className": "IntersectionTests",
    "methodName": "trianglePlaneIntersection",
    "description": "Computes the intersection of a triangle and a plane",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n * const p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n * const triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);"
  },
  {
    "className": "Intersections2D",
    "methodName": "clipTriangleAtAxisAlignedThreshold",
    "description": "Splits a 2D triangle at given axis-aligned threshold value and returns the resulting",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);\n * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]"
  },
  {
    "className": "Intersections2D",
    "methodName": "computeBarycentricCoordinates",
    "description": "Compute the barycentric coordinates of a 2D position within a 2D triangle.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);\n * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);"
  },
  {
    "className": "Intersections2D",
    "methodName": "computeLineSegmentLineSegmentIntersection",
    "description": "Compute the intersection between 2 line segments",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);\n * // result === new Cesium.Cartesian2(0.0, 1.0);"
  },
  {
    "className": "IonResource",
    "methodName": "fromAssetId",
    "description": "Asynchronously creates an instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Load a Cesium3DTileset with asset ID of 124624234\n * try {\n *   const resource = await Cesium.IonResource.fromAssetId(124624234);\n *   const tileset = await Cesium.Cesium3DTileset.fromUrl(resource);\n *   scene.primitives.add(tileset);\n * } catch (error) {\n *   console.error(`Error creating tileset: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "LinearSpline",
    "methodName": "LinearSpline",
    "description": "A spline that uses piecewise linear interpolation to create a curve.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.LinearSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n *"
  },
  {
    "className": "Math",
    "methodName": "lerp",
    "description": "Computes the linear interpolation of two values.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0"
  },
  {
    "className": "Math",
    "methodName": "convertLongitudeRange",
    "description": "Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Convert 270 degrees to -90 degrees longitude\n * const longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));"
  },
  {
    "className": "Math",
    "methodName": "clampToLatitudeRange",
    "description": "Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Clamp 108 degrees latitude to 90 degrees latitude\n * const latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));"
  },
  {
    "className": "Math",
    "methodName": "equalsEpsilon",
    "description": "Determines if two values are equal using an absolute or relative tolerance test. This is useful",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true\n * const b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false\n * const c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true\n * const d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false"
  },
  {
    "className": "Math",
    "methodName": "factorial",
    "description": "Computes the factorial of the provided number.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Compute 7!, which is equal to 5040\n * const computedFactorial = Cesium.Math.factorial(7);\n *\n *"
  },
  {
    "className": "Math",
    "methodName": "incrementWrap",
    "description": "Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6\n * const m = Cesium.Math.incrementWrap(10, 10, 0); // returns 0"
  },
  {
    "className": "Math",
    "methodName": "isPowerOfTwo",
    "description": "Determines if a non-negative integer is a power of two.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const t = Cesium.Math.isPowerOfTwo(16); // true\n * const f = Cesium.Math.isPowerOfTwo(20); // false"
  },
  {
    "className": "Math",
    "methodName": "nextPowerOfTwo",
    "description": "Computes the next power-of-two integer greater than or equal to the provided non-negative integer.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const n = Cesium.Math.nextPowerOfTwo(29); // 32\n * const m = Cesium.Math.nextPowerOfTwo(32); // 32"
  },
  {
    "className": "Math",
    "methodName": "previousPowerOfTwo",
    "description": "Computes the previous power-of-two integer less than or equal to the provided non-negative integer.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const n = Cesium.Math.previousPowerOfTwo(29); // 16\n * const m = Cesium.Math.previousPowerOfTwo(32); // 32"
  },
  {
    "className": "Matrix2",
    "methodName": "fromArray",
    "description": "Creates a Matrix2 from 4 consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create the Matrix2:\n * // [1.0, 2.0]\n * // [1.0, 2.0]\n *\n * const v = [1.0, 1.0, 2.0, 2.0];\n * const m = Cesium.Matrix2.fromArray(v);\n *\n * // Create same Matrix2 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n * const m2 = Cesium.Matrix2.fromArray(v2, 2);"
  },
  {
    "className": "Matrix2",
    "methodName": "fromScale",
    "description": "Computes a Matrix2 instance representing a non-uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [7.0, 0.0]\n * //   [0.0, 8.0]\n * const m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));"
  },
  {
    "className": "Matrix2",
    "methodName": "fromUniformScale",
    "description": "Computes a Matrix2 instance representing a uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [2.0, 0.0]\n * //   [0.0, 2.0]\n * const m = Cesium.Matrix2.fromUniformScale(2.0);"
  },
  {
    "className": "Matrix2",
    "methodName": "fromRotation",
    "description": "Creates a rotation matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Rotate a point 45 degrees counterclockwise.\n * const p = new Cesium.Cartesian2(5, 6);\n * const m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());"
  },
  {
    "className": "Matrix2",
    "methodName": "getElementIndex",
    "description": "Computes the array index of the element at the provided row and column.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const myMatrix = new Cesium.Matrix2();\n * const column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;"
  },
  {
    "className": "Matrix2",
    "methodName": "multiplyByScale",
    "description": "Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix2",
    "methodName": "multiplyByUniformScale",
    "description": "Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromUniformScale(scale), m);\n * Cesium.Matrix2.multiplyByUniformScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix2",
    "methodName": "COLUMN0ROW0",
    "description": "The index into Matrix2 for column 0, row 0.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0"
  },
  {
    "className": "Matrix2",
    "methodName": "COLUMN0ROW1",
    "description": "The index into Matrix2 for column 0, row 1.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0"
  },
  {
    "className": "Matrix2",
    "methodName": "COLUMN1ROW0",
    "description": "The index into Matrix2 for column 1, row 0.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0"
  },
  {
    "className": "Matrix2",
    "methodName": "COLUMN1ROW1",
    "description": "The index into Matrix2 for column 1, row 1.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0"
  },
  {
    "className": "Matrix3",
    "methodName": "fromArray",
    "description": "Creates a Matrix3 from 9 consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create the Matrix3:\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n *\n * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m = Cesium.Matrix3.fromArray(v);\n *\n * // Create same Matrix3 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m2 = Cesium.Matrix3.fromArray(v2, 2);"
  },
  {
    "className": "Matrix3",
    "methodName": "fromScale",
    "description": "Computes a Matrix3 instance representing a non-uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [7.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0]\n * //   [0.0, 0.0, 9.0]\n * const m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));"
  },
  {
    "className": "Matrix3",
    "methodName": "fromUniformScale",
    "description": "Computes a Matrix3 instance representing a uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [2.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 2.0]\n * const m = Cesium.Matrix3.fromUniformScale(2.0);"
  },
  {
    "className": "Matrix3",
    "methodName": "fromCrossProduct",
    "description": "Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [0.0, -9.0,  8.0]\n * //   [9.0,  0.0, -7.0]\n * //   [-8.0, 7.0,  0.0]\n * const m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));"
  },
  {
    "className": "Matrix3",
    "methodName": "fromRotationX",
    "description": "Creates a rotation matrix around the x-axis.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Rotate a point 45 degrees counterclockwise around the x-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());"
  },
  {
    "className": "Matrix3",
    "methodName": "fromRotationY",
    "description": "Creates a rotation matrix around the y-axis.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Rotate a point 45 degrees counterclockwise around the y-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());"
  },
  {
    "className": "Matrix3",
    "methodName": "fromRotationZ",
    "description": "Creates a rotation matrix around the z-axis.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Rotate a point 45 degrees counterclockwise around the z-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());"
  },
  {
    "className": "Matrix3",
    "methodName": "getElementIndex",
    "description": "Computes the array index of the element at the provided row and column.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const myMatrix = new Cesium.Matrix3();\n * const column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;"
  },
  {
    "className": "Matrix3",
    "methodName": "multiplyByScale",
    "description": "Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix3",
    "methodName": "multiplyByUniformScale",
    "description": "Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromUniformScale(scale), m);\n * Cesium.Matrix3.multiplyByUniformScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix3",
    "methodName": "computeEigenDecomposition",
    "description": "Computes the eigenvectors and eigenvalues of a symmetric matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const a = //... symetric matrix\n * const result = {\n *     unitary : new Cesium.Matrix3(),\n *     diagonal : new Cesium.Matrix3()\n * };\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n * const b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n * const v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n * const c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)"
  },
  {
    "className": "Matrix4",
    "methodName": "fromArray",
    "description": "Creates a Matrix4 from 16 consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create the Matrix4:\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n *\n * const v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n * const m = Cesium.Matrix4.fromArray(v);\n *\n * // Create same Matrix4 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n * const m2 = Cesium.Matrix4.fromArray(v2, 2);"
  },
  {
    "className": "Matrix4",
    "methodName": "fromTranslationQuaternionRotationScale",
    "description": "Computes a Matrix4 instance from a translation, rotation, and scale (TRS)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(\n *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation\n *   Cesium.Quaternion.IDENTITY,           // rotation\n *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale\n *   result);"
  },
  {
    "className": "Matrix4",
    "methodName": "fromScale",
    "description": "Computes a Matrix4 instance representing a non-uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [7.0, 0.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0, 0.0]\n * //   [0.0, 0.0, 9.0, 0.0]\n * //   [0.0, 0.0, 0.0, 1.0]\n * const m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));"
  },
  {
    "className": "Matrix4",
    "methodName": "fromUniformScale",
    "description": "Computes a Matrix4 instance representing a uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [2.0, 0.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0, 0.0]\n * //   [0.0, 0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 0.0, 1.0]\n * const m = Cesium.Matrix4.fromUniformScale(2.0);"
  },
  {
    "className": "Matrix4",
    "methodName": "computeViewportTransformation",
    "description": "Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create viewport transformation using an explicit viewport and depth range.\n * const m = Cesium.Matrix4.computeViewportTransformation({\n *     x : 0.0,\n *     y : 0.0,\n *     width : 1024.0,\n *     height : 768.0\n * }, 0.0, 1.0, new Cesium.Matrix4());"
  },
  {
    "className": "Matrix4",
    "methodName": "toArray",
    "description": "Computes an Array from the provided Matrix4 instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //create an array from an instance of Matrix4\n * // m = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n * const a = Cesium.Matrix4.toArray(m);\n *\n * // m remains the same\n * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "getElementIndex",
    "description": "Computes the array index of the element at the provided row and column.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const myMatrix = new Cesium.Matrix4();\n * const column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index];\n * myMatrix[column1Row0Index] = 10.0;"
  },
  {
    "className": "Matrix4",
    "methodName": "getColumn",
    "description": "Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //returns a Cartesian4 instance with values from the specified column\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * //Example 1: Creates an instance of Cartesian\n * const a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());\n *\n *"
  },
  {
    "className": "Matrix4",
    "methodName": "setColumn",
    "description": "Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //creates a new Matrix4 instance with new column values from the Cartesian4 instance\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 11.0, 99.0, 13.0]\n * //     [14.0, 15.0, 98.0, 17.0]\n * //     [18.0, 19.0, 97.0, 21.0]\n * //     [22.0, 23.0, 96.0, 25.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "getRow",
    "description": "Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //returns a Cartesian4 instance with values from the specified column\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * //Example 1: Returns an instance of Cartesian\n * const a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());\n *\n *"
  },
  {
    "className": "Matrix4",
    "methodName": "setRow",
    "description": "Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //create a new Matrix4 instance with new row values from the Cartesian4 instance\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [99.0, 98.0, 97.0, 96.0]\n * //     [22.0, 23.0, 24.0, 25.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyTransformation",
    "description": "Computes the product of two matrices assuming the matrices are affine transformation matrices,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n * const m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));\n * const m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByMatrix3",
    "description": "Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);\n * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByTranslation",
    "description": "Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);\n * Cesium.Matrix4.multiplyByTranslation(m, position, m);"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByScale",
    "description": "Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);\n * Cesium.Matrix4.multiplyByScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByUniformScale",
    "description": "Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);\n * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByPointAsVector",
    "description": "Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());\n * // A shortcut for\n * //   Cartesian3 p = ...\n * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByPoint",
    "description": "Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByScalar",
    "description": "Computes the product of a matrix and a scalar.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //create a Matrix4 instance which is a scaled version of the supplied Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [-20.0, -22.0, -24.0, -26.0]\n * //     [-28.0, -30.0, -32.0, -34.0]\n * //     [-36.0, -38.0, -40.0, -42.0]\n * //     [-44.0, -46.0, -48.0, -50.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "negate",
    "description": "Computes a negated copy of the provided matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //create a new Matrix4 instance which is a negation of a Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [-10.0, -11.0, -12.0, -13.0]\n * //     [-14.0, -15.0, -16.0, -17.0]\n * //     [-18.0, -19.0, -20.0, -21.0]\n * //     [-22.0, -23.0, -24.0, -25.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "transpose",
    "description": "Computes the transpose of the provided matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //returns transpose of a Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "equals",
    "description": "Compares the provided matrices componentwise and returns",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //compares two Matrix4 instances\n *\n * // a = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * // b = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * if(Cesium.Matrix4.equals(a,b)) {\n *      console.log(\"Both matrices are equal\");\n * } else {\n *      console.log(\"They are not equal\");\n * }\n *\n * //Prints \"Both matrices are equal\" on the console"
  },
  {
    "className": "Matrix4",
    "methodName": "equalsEpsilon",
    "description": "Compares the provided matrices componentwise and returns",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //compares two Matrix4 instances\n *\n * // a = [10.5, 14.5, 18.5, 22.5]\n * //     [11.5, 15.5, 19.5, 23.5]\n * //     [12.5, 16.5, 20.5, 24.5]\n * //     [13.5, 17.5, 21.5, 25.5]\n *\n * // b = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){\n *      console.log(\"Difference between both the matrices is less than 0.1\");\n * } else {\n *      console.log(\"Difference between both the matrices is not less than 0.1\");\n * }\n *\n * //Prints \"Difference between both the matrices is not less than 0.1\" on the console"
  },
  {
    "className": "Matrix4",
    "methodName": "getMatrix3",
    "description": "Gets the upper left 3x3 matrix of the provided matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // returns a Matrix3 instance from a Matrix4 instance\n *\n * // m = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * const b = new Cesium.Matrix3();\n * Cesium.Matrix4.getMatrix3(m,b);\n *\n * // b = [10.0, 14.0, 18.0]\n * //     [11.0, 15.0, 19.0]\n * //     [12.0, 16.0, 20.0]"
  },
  {
    "className": "MorphWeightSpline",
    "methodName": "MorphWeightSpline",
    "description": "A spline that linearly interpolates over an array of weight values used by morph targets.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const weights = [0.0, 1.0, 0.25, 0.75, 0.5, 0.5, 0.75, 0.25, 1.0, 0.0]; //Two targets\n * const spline = new Cesium.WeightSpline({\n *     times : times,\n *     weights : weights\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n *"
  },
  {
    "className": "Occluder",
    "methodName": "Occluder",
    "description": "Creates an Occluder derived from an object's position and radius, as well as the camera position.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Construct an occluder one unit away from the origin with a radius of one.\n * const cameraPosition = Cesium.Cartesian3.ZERO;\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 1);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);"
  },
  {
    "className": "Occluder",
    "methodName": "isPointVisible",
    "description": "Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const point = new Cesium.Cartesian3(0, 0, -3);\n * occluder.isPointVisible(point); //returns true\n *\n *"
  },
  {
    "className": "Occluder",
    "methodName": "isBoundingSphereVisible",
    "description": "Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const bigSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -3), 1);\n * occluder.isBoundingSphereVisible(bigSphere); //returns true\n *\n *"
  },
  {
    "className": "Occluder",
    "methodName": "computeVisibility",
    "description": "Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const sphere1 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1.5), 0.5);\n * const sphere2 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -2.5), 0.5);\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluder = new Cesium.Occluder(sphere1, cameraPosition);\n * occluder.computeVisibility(sphere2); //returns Visibility.NONE"
  },
  {
    "className": "Occluder",
    "methodName": "computeOccludeePoint",
    "description": "Computes a point that can be used as the occludee position to the visibility functions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -8), 2);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n * const positions = [new Cesium.Cartesian3(-0.25, 0, -5.3), new Cesium.Cartesian3(0.25, 0, -5.3)];\n * const tileOccluderSphere = Cesium.BoundingSphere.fromPoints(positions);\n * const occludeePosition = tileOccluderSphere.center;\n * const occludeePt = Cesium.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);"
  },
  {
    "className": "OffsetGeometryInstanceAttribute",
    "methodName": "toValue",
    "description": "Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.modelMatrix = Cesium.OffsetGeometryInstanceAttribute.toValue(modelMatrix, attributes.modelMatrix);"
  },
  {
    "className": "OpenCageGeocoderService",
    "methodName": "OpenCageGeocoderService",
    "description": "Provides geocoding via a {@link https://opencagedata.com/|OpenCage} server.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Configure a Viewer to use the OpenCage Geocoder\n * const viewer = new Cesium.Viewer('cesiumContainer', {\n *   geocoder: new Cesium.OpenCageGeocoderService('https://api.opencagedata.com/geocode/v1/', '<API key>')\n * });"
  },
  {
    "className": "OrientedBoundingBox",
    "methodName": "OrientedBoundingBox",
    "description": "Creates an instance of an OrientedBoundingBox.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n *"
  },
  {
    "className": "OrientedBoundingBox",
    "methodName": "fromPoints",
    "description": "Computes an instance of an OrientedBoundingBox of the given positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Compute an object oriented bounding box enclosing two points.\n * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);"
  },
  {
    "className": "OrientedBoundingBox",
    "methodName": "distanceSquaredTo",
    "description": "Computes the estimated distance squared from the closest point on a bounding box to a point.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });"
  },
  {
    "className": "OrientedBoundingBox",
    "methodName": "distanceSquaredTo",
    "description": "Computes the estimated distance squared from the closest point on a bounding box to a point.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });"
  },
  {
    "className": "OrthographicFrustum",
    "methodName": "OrthographicFrustum",
    "description": "The viewing frustum is defined by 6 planes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicFrustum();\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;"
  },
  {
    "className": "OrthographicFrustum",
    "methodName": "computeCullingVolume",
    "description": "Creates a culling volume for this frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);"
  },
  {
    "className": "OrthographicFrustum",
    "methodName": "getPixelDimensions",
    "description": "Returns the pixel's width and height in meters.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());"
  },
  {
    "className": "OrthographicOffCenterFrustum",
    "methodName": "OrthographicOffCenterFrustum",
    "description": "The viewing frustum is defined by 6 planes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicOffCenterFrustum();\n * frustum.right = maxRadii * Cesium.Math.PI;\n * frustum.left = -c.frustum.right;\n * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);\n * frustum.bottom = -c.frustum.top;\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;"
  },
  {
    "className": "OrthographicOffCenterFrustum",
    "methodName": "computeCullingVolume",
    "description": "Creates a culling volume for this frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);"
  },
  {
    "className": "OrthographicOffCenterFrustum",
    "methodName": "getPixelDimensions",
    "description": "Returns the pixel's width and height in meters.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());"
  },
  {
    "className": "PeliasGeocoderService",
    "methodName": "PeliasGeocoderService",
    "description": "Provides geocoding via a {@link https://pelias.io/|Pelias} server.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Configure a Viewer to use the Pelias server hosted by https://geocode.earth/\n * const viewer = new Cesium.Viewer('cesiumContainer', {\n *   geocoder: new Cesium.PeliasGeocoderService(new Cesium.Resource({\n *     url: 'https://api.geocode.earth/v1/',\n *       queryParameters: {\n *         api_key: '<Your geocode.earth API key>'\n *     }\n *   }))\n * });"
  },
  {
    "className": "PerspectiveFrustum",
    "methodName": "PerspectiveFrustum",
    "description": "The viewing frustum is defined by 6 planes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const frustum = new Cesium.PerspectiveFrustum({\n *     fov : Cesium.Math.PI_OVER_THREE,\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\n *     near : 1.0,\n *     far : 1000.0\n * });\n *\n *"
  },
  {
    "className": "PerspectiveFrustum",
    "methodName": "computeCullingVolume",
    "description": "Creates a culling volume for this frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);"
  },
  {
    "className": "PerspectiveFrustum",
    "methodName": "getPixelDimensions",
    "description": "Returns the pixel's width and height in meters.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n *"
  },
  {
    "className": "PerspectiveOffCenterFrustum",
    "methodName": "PerspectiveOffCenterFrustum",
    "description": "The viewing frustum is defined by 6 planes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const frustum = new Cesium.PerspectiveOffCenterFrustum({\n *     left : -1.0,\n *     right : 1.0,\n *     top : 1.0,\n *     bottom : -1.0,\n *     near : 1.0,\n *     far : 100.0\n * });\n *\n *"
  },
  {
    "className": "PerspectiveOffCenterFrustum",
    "methodName": "computeCullingVolume",
    "description": "Creates a culling volume for this frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);"
  },
  {
    "className": "PerspectiveOffCenterFrustum",
    "methodName": "getPixelDimensions",
    "description": "Returns the pixel's width and height in meters.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n *"
  },
  {
    "className": "Plane",
    "methodName": "Plane",
    "description": "A plane in Hessian Normal Form defined by",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // The plane x=0\n * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n *\n *"
  },
  {
    "className": "Plane",
    "methodName": "fromPointNormal",
    "description": "Creates a plane from a normal and a point on the plane.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const normal = ellipsoid.geodeticSurfaceNormal(point);\n * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n *\n *"
  },
  {
    "className": "PlaneGeometry",
    "methodName": "PlaneGeometry",
    "description": "Describes geometry representing a plane centered at the origin, with a unit width and length.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const planeGeometry = new Cesium.PlaneGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n * });"
  },
  {
    "className": "PolygonGeometry",
    "methodName": "PolygonGeometry",
    "description": "A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. create a polygon from points\n * const polygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes\n * const polygonWithHole = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon\n * const extrudedPolygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);"
  },
  {
    "className": "PolygonGeometry",
    "methodName": "fromPositions",
    "description": "A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a polygon from points\n * const polygon = Cesium.PolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n *"
  },
  {
    "className": "PolygonOutlineGeometry",
    "methodName": "PolygonOutlineGeometry",
    "description": "A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. create a polygon outline from points\n * const polygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes outline\n * const polygonWithHole = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon outline\n * const extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);"
  },
  {
    "className": "PolygonOutlineGeometry",
    "methodName": "fromPositions",
    "description": "A description of a polygon outline from an array of positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a polygon from points\n * const polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n *"
  },
  {
    "className": "PolylineGeometry",
    "methodName": "PolylineGeometry",
    "description": "A description of a polyline modeled as a line strip; the first two positions define a line segment,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // A polyline with two connected line segments\n * const polyline = new Cesium.PolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ]),\n *   width : 10.0\n * });\n * const geometry = Cesium.PolylineGeometry.createGeometry(polyline);"
  },
  {
    "className": "PolylinePipeline",
    "methodName": "wrapLongitude",
    "description": "Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const polylines = new Cesium.PolylineCollection();\n * const polyline = polylines.add(...);\n * const positions = polyline.positions;\n * const modelMatrix = polylines.modelMatrix;\n * const segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n *\n *"
  },
  {
    "className": "PolylinePipeline",
    "methodName": "generateArc",
    "description": "Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateArc({\n *   positons: positions\n * });"
  },
  {
    "className": "PolylinePipeline",
    "methodName": "generateRhumbArc",
    "description": "Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n *   positons: positions\n * });"
  },
  {
    "className": "PolylinePipeline",
    "methodName": "generateCartesianArc",
    "description": "Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n *   positons: positions\n * });"
  },
  {
    "className": "PolylinePipeline",
    "methodName": "generateCartesianRhumbArc",
    "description": "Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n *   positons: positions\n * });"
  },
  {
    "className": "PolylineVolumeGeometry",
    "methodName": "PolylineVolumeGeometry",
    "description": "A description of a polyline with a volume (a 2D shape extruded along a polyline).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* function computeCircle(radius) {\n *   const positions = [];\n *   for (let i = 0; i < 360; i++) {\n *     const radians = Cesium.Math.toRadians(i);\n *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n *   }\n *   return positions;\n * }\n *\n * const volume = new Cesium.PolylineVolumeGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0\n *   ]),\n *   shapePositions : computeCircle(100000.0)\n * });"
  },
  {
    "className": "PolylineVolumeOutlineGeometry",
    "methodName": "PolylineVolumeOutlineGeometry",
    "description": "A description of a polyline with a volume (a 2D shape extruded along a polyline).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* function computeCircle(radius) {\n *   const positions = [];\n *   for (let i = 0; i < 360; i++) {\n *     const radians = Cesium.Math.toRadians(i);\n *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n *   }\n *   return positions;\n * }\n *\n * const volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({\n *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0\n *   ]),\n *   shapePositions : computeCircle(100000.0)\n * });"
  },
  {
    "className": "QuantizedMeshTerrainData",
    "methodName": "QuantizedMeshTerrainData",
    "description": "Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const data = new Cesium.QuantizedMeshTerrainData({\n *     minimumHeight : -100,\n *     maximumHeight : 2101,\n *     quantizedVertices : new Uint16Array([// order is SW NW SE NE\n *                                          // longitude\n *                                          0, 0, 32767, 32767,\n *                                          // latitude\n *                                          0, 32767, 0, 32767,\n *                                          // heights\n *                                          16384, 0, 32767, 16384]),\n *     indices : new Uint16Array([0, 3, 1,\n *                                0, 2, 3]),\n *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),\n *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),\n *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),\n *     westIndices : [0, 1],\n *     southIndices : [0, 1],\n *     eastIndices : [2, 3],\n *     northIndices : [1, 3],\n *     westSkirtHeight : 1.0,\n *     southSkirtHeight : 1.0,\n *     eastSkirtHeight : 1.0,\n *     northSkirtHeight : 1.0\n * });\n *\n *"
  },
  {
    "className": "Quaternion",
    "methodName": "squad",
    "description": "Computes the spherical quadrangle interpolation between quaternions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. compute the squad interpolation between two quaternions on a curve\n * const s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());\n *\n * // 2. compute the squad interpolation as above but where the first quaternion is a end point.\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());\n *\n *"
  },
  {
    "className": "Ray",
    "methodName": "getPoint",
    "description": "Computes the point along the ray given by r(t) = o + t*d,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Get the first intersection point of a ray and an ellipsoid.\n * const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * const point = Cesium.Ray.getPoint(ray, intersection.start);"
  },
  {
    "className": "Rectangle",
    "methodName": "fromDegrees",
    "description": "Creates a rectangle given the boundary longitude and latitude in degrees.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);"
  },
  {
    "className": "Rectangle",
    "methodName": "fromRadians",
    "description": "Creates a rectangle given the boundary longitude and latitude in radians.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);"
  },
  {
    "className": "RectangleGeometry",
    "methodName": "RectangleGeometry",
    "description": "A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. create a rectangle\n * const rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.default,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n *\n * // 2. create an extruded rectangle without a top\n * const rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.default,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0,\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);"
  },
  {
    "className": "RectangleOutlineGeometry",
    "methodName": "RectangleOutlineGeometry",
    "description": "A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const rectangle = new Cesium.RectangleOutlineGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);"
  },
  {
    "className": "RequestScheduler",
    "methodName": "requestsByServer",
    "description": "A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* RequestScheduler.requestsByServer[\"myserver.com:443\"] = 18;\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "Resource",
    "description": "A resource that includes the location and any other parameters we need to retrieve it or create derived resources. It also provides the ability to retry requests.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* function refreshTokenRetryCallback(resource, error) {\n *   if (error.statusCode === 403) {\n *     // 403 status code means a new token should be generated\n *     return getNewAccessToken()\n *       .then(function(token) {\n *         resource.queryParameters.access_token = token;\n *         return true;\n *       })\n *       .catch(function() {\n *         return false;\n *       });\n *   }\n *\n *   return false;\n * }\n *\n * const resource = new Resource({\n *    url: 'http://server.com/path/to/resource.json',\n *    proxy: new DefaultProxy('/proxy/'),\n *    headers: {\n *      'X-My-Header': 'valueOfHeader'\n *    },\n *    queryParameters: {\n *      'access_token': '123-435-456-000'\n *    },\n *    retryCallback: refreshTokenRetryCallback,\n *    retryAttempts: 1\n * });"
  },
  {
    "className": "Resource",
    "methodName": "combineQueryParameters",
    "description": "This combines a map of query parameters.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const q1 = {\n *   a: 1,\n *   b: 2\n * };\n * const q2 = {\n *   a: 3,\n *   c: 4\n * };\n * const q3 = {\n *   b: [5, 6],\n *   d: 7\n * }\n *\n * // Returns\n * // {\n * //   a: [1, 3],\n * //   b: 2,\n * //   c: 4\n * // };\n * combineQueryParameters(q1, q2, true);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: 2,\n * //   c: 4\n * // };\n * combineQueryParameters(q1, q2, false);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: [2, 5, 6],\n * //   d: 7\n * // };\n * combineQueryParameters(q1, q3, true);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: 2,\n * //   d: 7\n * // };\n * combineQueryParameters(q1, q3, false);\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchArrayBuffer",
    "description": "Asynchronously loads the resource as raw binary data.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load a single URL asynchronously\n * resource.fetchArrayBuffer().then(function(arrayBuffer) {\n *     // use the data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchBlob",
    "description": "Asynchronously loads the given resource as a blob.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load a single URL asynchronously\n * resource.fetchBlob().then(function(blob) {\n *     // use the data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchImage",
    "description": "Asynchronously loads the given image resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load a single image asynchronously\n * resource.fetchImage().then(function(image) {\n *     // use the loaded image\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * // load several images in parallel\n * Promise.all([resource1.fetchImage(), resource2.fetchImage()]).then(function(images) {\n *     // images is an array containing all the loaded images\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchText",
    "description": "Asynchronously loads the given resource as text.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load text from a URL, setting a custom header\n * const resource = new Resource({\n *   url: 'http://someUrl.com/someJson.txt',\n *   headers: {\n *     'X-Custom-Header' : 'some value'\n *   }\n * });\n * resource.fetchText().then(function(text) {\n *     // Do something with the text\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchJson",
    "description": "Asynchronously loads the given resource as JSON.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.fetchJson().then(function(jsonData) {\n *     // Do something with the JSON object\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchXML",
    "description": "Asynchronously loads the given resource as XML.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load XML from a URL, setting a custom header\n * Cesium.loadXML('http://someUrl.com/someXML.xml', {\n *   'X-Custom-Header' : 'some value'\n * }).then(function(document) {\n *     // Do something with the document\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchJsonp",
    "description": "Requests a resource using JSONP.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load a data asynchronously\n * resource.fetchJsonp().then(function(data) {\n *     // use the loaded data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetch",
    "description": "Asynchronously loads the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.fetch()\n *   .then(function(body) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "delete",
    "description": "Asynchronously deletes the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.delete()\n *   .then(function(body) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "head",
    "description": "Asynchronously gets headers the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.head()\n *   .then(function(headers) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "options",
    "description": "Asynchronously gets options the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.options()\n *   .then(function(headers) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "post",
    "description": "Asynchronously posts data to the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.post(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "put",
    "description": "Asynchronously puts data to the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.put(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "patch",
    "description": "Asynchronously patches data to the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.patch(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "ScreenSpaceEventHandler",
    "methodName": "destroy",
    "description": "Removes listeners held by this object.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* handler = handler && handler.destroy();\n *\n *"
  },
  {
    "className": "ShowGeometryInstanceAttribute",
    "methodName": "ShowGeometryInstanceAttribute",
    "description": "Value and type information for per-instance geometry attribute that determines if the geometry instance will be shown.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.BoxGeometry({\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     show : new Cesium.ShowGeometryInstanceAttribute(false)\n *   }\n * });\n *\n *"
  },
  {
    "className": "ShowGeometryInstanceAttribute",
    "methodName": "toValue",
    "description": "Converts a boolean show to a typed array that can be used to assign a show attribute.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true, attributes.show);"
  },
  {
    "className": "SimplePolylineGeometry",
    "methodName": "SimplePolylineGeometry",
    "description": "A description of a polyline modeled as a line strip; the first two positions define a line segment,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // A polyline with two connected line segments\n * const polyline = new Cesium.SimplePolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ])\n * });\n * const geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);"
  },
  {
    "className": "SphereGeometry",
    "methodName": "SphereGeometry",
    "description": "A description of a sphere centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const sphere = new Cesium.SphereGeometry({\n *   radius : 100.0,\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n * });\n * const geometry = Cesium.SphereGeometry.createGeometry(sphere);"
  },
  {
    "className": "SphereOutlineGeometry",
    "methodName": "SphereOutlineGeometry",
    "description": "A description of the outline of a sphere.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const sphere = new Cesium.SphereOutlineGeometry({\n *   radius : 100.0,\n *   stackPartitions : 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.SphereOutlineGeometry.createGeometry(sphere);"
  },
  {
    "className": "SteppedSpline",
    "methodName": "SteppedSpline",
    "description": "A spline that is composed of piecewise constants representing a step function.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.SteppedSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n *"
  },
  {
    "className": "TaskProcessor",
    "methodName": "scheduleTask",
    "description": "Schedule a task to be processed by the web worker asynchronously.  If there are currently more",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const taskProcessor = new Cesium.TaskProcessor('myWorkerPath');\n * const promise = taskProcessor.scheduleTask({\n *     someParameter : true,\n *     another : 'hello'\n * });\n * if (!Cesium.defined(promise)) {\n *     // too many active tasks - try again later\n * } else {\n *     promise.then(function(result) {\n *         // use the result of the task\n *     });\n * }"
  },
  {
    "className": "TimeInterval",
    "methodName": "TimeInterval",
    "description": "An interval defined by a start and a stop time; optionally including those times as part of the interval.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create an instance that spans August 1st, 1980 and is associated\n * // with a Cartesian position.\n * const timeInterval = new Cesium.TimeInterval({\n *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),\n *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)\n * });\n *\n *"
  },
  {
    "className": "Tipsify",
    "methodName": "calculateACMR",
    "description": "Calculates the average cache miss ratio (ACMR) for a given set of indices.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const indices = [0, 1, 2, 3, 4, 5];\n * const maxIndex = 5;\n * const cacheSize = 3;\n * const acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});"
  },
  {
    "className": "Tipsify",
    "methodName": "tipsify",
    "description": "Optimizes triangles for the post-vertex shader cache.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const indices = [0, 1, 2, 3, 4, 5];\n * const maxIndex = 5;\n * const cacheSize = 3;\n * const reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});"
  },
  {
    "className": "Transforms",
    "methodName": "eastNorthUpToFixedFrame",
    "description": "Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);"
  },
  {
    "className": "Transforms",
    "methodName": "northEastDownToFixedFrame",
    "description": "Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northEastDownToFixedFrame(center);"
  },
  {
    "className": "Transforms",
    "methodName": "northUpEastToFixedFrame",
    "description": "Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northUpEastToFixedFrame(center);"
  },
  {
    "className": "Transforms",
    "methodName": "northWestUpToFixedFrame",
    "description": "Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northWestUpToFixedFrame(center);"
  },
  {
    "className": "Transforms",
    "methodName": "headingPitchRollToFixedFrame",
    "description": "Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);\n * const transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);"
  },
  {
    "className": "Transforms",
    "methodName": "headingPitchRollQuaternion",
    "description": "Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new HeadingPitchRoll(heading, pitch, roll);\n * const quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);"
  },
  {
    "className": "Transforms",
    "methodName": "computeIcrfToCentralBodyFixedMatrix",
    "description": "The default function to compute a rotation matrix to transform a point or vector from the International Celestial",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set the default ICRF to fixed transformation to that of the Moon.\n * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;\n *\n *"
  },
  {
    "className": "Transforms",
    "methodName": "computeTemeToPseudoFixedMatrix",
    "description": "Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Set the view to the inertial frame.\n * scene.postUpdate.addEventListener(function(scene, time) {\n *    const now = Cesium.JulianDate.now();\n *    const offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n *    const transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));\n *    const inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n *    camera.lookAtTransform(transform, offset);\n * });"
  },
  {
    "className": "Transforms",
    "methodName": "preloadIcrfFixed",
    "description": "Preloads the data necessary to transform between the ICRF and Fixed axes, in either",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const interval = new Cesium.TimeInterval(...);\n * await Cesium.Transforms.preloadIcrfFixed(interval));\n * // the data is now loaded\n *\n *"
  },
  {
    "className": "Transforms",
    "methodName": "computeIcrfToFixedMatrix",
    "description": "Computes a rotation matrix to transform a point or vector from the International Celestial",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.postUpdate.addEventListener(function(scene, time) {\n *   // View in ICRF.\n *   const icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);\n *   if (Cesium.defined(icrfToFixed)) {\n *     const offset = Cesium.Cartesian3.clone(camera.position);\n *     const transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);\n *     camera.lookAtTransform(transform, offset);\n *   }\n * });\n *\n *"
  },
  {
    "className": "Transforms",
    "methodName": "computeMoonFixedToIcrfMatrix",
    "description": "Computes a rotation matrix to transform a point or vector from the Moon-Fixed frame axes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Transform a point from the Fixed axes to the ICRF axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeMoonFixedToIcrfMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }"
  },
  {
    "className": "Transforms",
    "methodName": "computeIcrfToMoonFixedMatrix",
    "description": "Computes a rotation matrix to transform a point or vector from the International Celestial",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set the default ICRF to fixed transformation to that of the Moon.\n * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;"
  },
  {
    "className": "Transforms",
    "methodName": "computeFixedToIcrfMatrix",
    "description": "Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Transform a point from the Fixed axes to the ICRF axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeFixedToIcrfMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n *\n *"
  },
  {
    "className": "TridiagonalSystemSolver",
    "methodName": "solve",
    "description": "Solves a tridiagonal system of linear equations.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const lowerDiagonal = [1.0, 1.0, 1.0, 1.0];\n * const diagonal = [2.0, 4.0, 4.0, 4.0, 2.0];\n * const upperDiagonal = [1.0, 1.0, 1.0, 1.0];\n * const rightHandSide = [\n *     new Cesium.Cartesian3(410757.0, -1595711.0, 1375302.0),\n *     new Cesium.Cartesian3(-5986705.0, -2190640.0, 1099600.0),\n *     new Cesium.Cartesian3(-12593180.0, 288588.0, -1755549.0),\n *     new Cesium.Cartesian3(-5349898.0, 2457005.0, -2685438.0),\n *     new Cesium.Cartesian3(845820.0, 1573488.0, -1205591.0)\n * ];\n *\n * const solution = Cesium.TridiagonalSystemSolver.solve(lowerDiagonal, diagonal, upperDiagonal, rightHandSide);\n *\n *"
  },
  {
    "className": "TrustedServers",
    "methodName": "add",
    "description": "Adds a trusted server to the registry",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Add a trusted server\n * TrustedServers.add('my.server.com', 80);"
  },
  {
    "className": "TrustedServers",
    "methodName": "remove",
    "description": "Removes a trusted server from the registry",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Remove a trusted server\n * TrustedServers.remove('my.server.com', 80);"
  },
  {
    "className": "TrustedServers",
    "methodName": "contains",
    "description": "Tests whether a server is trusted or not. The server must have been added with the port if it is included in the url.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Add server\n * TrustedServers.add('my.server.com', 81);\n *\n * // Check if server is trusted\n * if (TrustedServers.contains('https://my.server.com:81/path/to/file.png')) {\n *     // my.server.com:81 is trusted\n * }\n * if (TrustedServers.contains('https://my.server.com/path/to/file.png')) {\n *     // my.server.com isn't trusted\n * }"
  },
  {
    "className": "TrustedServers",
    "methodName": "clear",
    "description": "Clears the registry",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Remove a trusted server\n * TrustedServers.clear();"
  },
  {
    "className": "VRTheWorldTerrainProvider",
    "methodName": "VRTheWorldTerrainProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const terrainProvider = await Cesium.VRTheWorldTerrainProvider.fromUrl(\n *   \"https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/\"\n * );\n * viewer.terrainProvider = terrainProvider;\n *\n *"
  },
  {
    "className": "VRTheWorldTerrainProvider",
    "methodName": "fromUrl",
    "description": "Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const terrainProvider = await Cesium.VRTheWorldTerrainProvider.fromUrl(\n *   \"https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/\"\n * );\n * viewer.terrainProvider = terrainProvider;\n *\n *"
  },
  {
    "className": "VertexFormat",
    "methodName": "VertexFormat",
    "description": "A vertex format defines what attributes make up a vertex.  A VertexFormat can be provided",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a vertex format with position and 2D texture coordinate attributes.\n * const format = new Cesium.VertexFormat({\n *   position : true,\n *   st : true\n * });\n *\n *"
  },
  {
    "className": "WallGeometry",
    "methodName": "WallGeometry",
    "description": "A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a wall that spans from ground level to 10000 meters\n * const wall = new Cesium.WallGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *     19.0, 47.0, 10000.0,\n *     19.0, 48.0, 10000.0,\n *     20.0, 48.0, 10000.0,\n *     20.0, 47.0, 10000.0,\n *     19.0, 47.0, 10000.0\n *   ])\n * });\n * const geometry = Cesium.WallGeometry.createGeometry(wall);"
  },
  {
    "className": "WallGeometry",
    "methodName": "fromConstantHeights",
    "description": "A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a wall that spans from 10000 meters to 20000 meters\n * const wall = Cesium.WallGeometry.fromConstantHeights({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     19.0, 47.0,\n *     19.0, 48.0,\n *     20.0, 48.0,\n *     20.0, 47.0,\n *     19.0, 47.0,\n *   ]),\n *   minimumHeight : 20000.0,\n *   maximumHeight : 10000.0\n * });\n * const geometry = Cesium.WallGeometry.createGeometry(wall);\n *\n *"
  },
  {
    "className": "WallOutlineGeometry",
    "methodName": "WallOutlineGeometry",
    "description": "A description of a wall outline. A wall is defined by a series of points,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a wall outline that spans from ground level to 10000 meters\n * const wall = new Cesium.WallOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *     19.0, 47.0, 10000.0,\n *     19.0, 48.0, 10000.0,\n *     20.0, 48.0, 10000.0,\n *     20.0, 47.0, 10000.0,\n *     19.0, 47.0, 10000.0\n *   ])\n * });\n * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);"
  },
  {
    "className": "WallOutlineGeometry",
    "methodName": "fromConstantHeights",
    "description": "A description of a walloutline. A wall is defined by a series of points,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a wall that spans from 10000 meters to 20000 meters\n * const wall = Cesium.WallOutlineGeometry.fromConstantHeights({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     19.0, 47.0,\n *     19.0, 48.0,\n *     20.0, 48.0,\n *     20.0, 47.0,\n *     19.0, 47.0,\n *   ]),\n *   minimumHeight : 20000.0,\n *   maximumHeight : 10000.0\n * });\n * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n *\n *"
  },
  {
    "className": "addAllToArray",
    "methodName": "addAllToArray",
    "description": "Adds all elements from the given source array to the given target array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const target = [ 0, 1, 2 ];\n * const source = [ 3, 4, 5 ];\n * Cesium.addAllToArray(target, source);\n * // The target is now [ 0, 1, 2, 3, 4, 5 ]"
  },
  {
    "className": "arrayRemoveDuplicates",
    "methodName": "arrayRemoveDuplicates",
    "description": "Removes adjacent duplicate values in an array of values.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0), (1.0, 1.0, 1.0)]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon);\n *\n *"
  },
  {
    "className": "barycentricCoordinates",
    "methodName": "barycentricCoordinates",
    "description": "Computes the barycentric coordinates for a point with respect to a triangle.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns Cartesian3.UNIT_X\n * const p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);\n * const b = Cesium.barycentricCoordinates(p,\n *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));"
  },
  {
    "className": "binarySearch",
    "methodName": "binarySearch",
    "description": "Finds an item in a sorted array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a comparator function to search through an array of numbers.\n * function comparator(a, b) {\n *     return a - b;\n * };\n * const numbers = [0, 2, 4, 6, 8];\n * const index = Cesium.binarySearch(numbers, 6, comparator); // 3"
  },
  {
    "className": "buildModuleUrl",
    "methodName": "buildModuleUrl",
    "description": "Given a relative URL under the Cesium base URL, returns an absolute URL.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(\n *     Cesium.TileMapServiceImageryProvider.fromUrl(\n *       Cesium.buildModuleUrl(\"Assets/Textures/NaturalEarthII\"),\n *     )),\n *   baseLayerPicker: false,\n * });"
  },
  {
    "className": "combine",
    "methodName": "combine",
    "description": "Merges two objects, copying their properties onto a new combined object. When two objects have the same",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const object1 = {\n *     propOne : 1,\n *     propTwo : {\n *         value1 : 10\n *     }\n * }\n * const object2 = {\n *     propTwo : 2\n * }\n * const final = Cesium.combine(object1, object2);\n *\n * // final === {\n * //     propOne : 1,\n * //     propTwo : {\n * //         value1 : 10\n * //     }\n * // }\n *\n *"
  },
  {
    "className": "createGuid",
    "methodName": "createGuid",
    "description": "Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* this.guid = Cesium.createGuid();\n *\n *"
  },
  {
    "className": "createWorldBathymetryAsync",
    "methodName": "createWorldBathymetryAsync",
    "description": "Creates a {@link CesiumTerrainProvider} instance for the {@link https://cesium.com/content/#cesium-world-bathymetry|Cesium World Bathymetry}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Cesium World Bathymetry with default settings\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.createWorldBathymetryAsync();\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "createWorldTerrainAsync",
    "methodName": "createWorldTerrainAsync",
    "description": "Creates a {@link CesiumTerrainProvider} instance for the {@link https://cesium.com/content/#cesium-world-terrain|Cesium World Terrain}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Cesium World Terrain with default settings\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.createWorldTerrainAsync();\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "defined",
    "methodName": "defined",
    "description": "@function",
    "parameters": [],
    "returnType": "unknown",
    "example": "* if (Cesium.defined(positions)) {\n *      doSomething();\n * } else {\n *      doSomethingElse();\n * }"
  },
  {
    "className": "deprecationWarning",
    "methodName": "deprecationWarning",
    "description": "Logs a deprecation message to the console.  Use this function instead of",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Deprecated function or class\n * function Foo() {\n *    deprecationWarning('Foo', 'Foo was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use newFoo instead.');\n *    // ...\n * }\n *\n * // Deprecated function\n * Bar.prototype.func = function() {\n *    deprecationWarning('Bar.func', 'Bar.func() was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newFunc() instead.');\n *    // ...\n * };\n *\n * // Deprecated property\n * Object.defineProperties(Bar.prototype, {\n *     prop : {\n *         get : function() {\n *             deprecationWarning('Bar.prop', 'Bar.prop was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newProp instead.');\n *             // ...\n *         },\n *         set : function(value) {\n *             deprecationWarning('Bar.prop', 'Bar.prop was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newProp instead.');\n *             // ...\n *         }\n *     }\n * });\n *\n *"
  },
  {
    "className": "destroyObject",
    "methodName": "destroyObject",
    "description": "Destroys an object.  Each of the object's functions, including functions in its prototype,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // How a texture would destroy itself.\n * this.destroy = function () {\n *     _gl.deleteTexture(_texture);\n *     return Cesium.destroyObject(this);\n * };\n *\n *"
  },
  {
    "className": "getAbsoluteUri",
    "methodName": "getAbsoluteUri",
    "description": "Given a relative Uri and a base Uri, returns the absolute Uri of the relative Uri.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //absolute Uri will be \"https://test.com/awesome.png\";\n * const absoluteUri = Cesium.getAbsoluteUri('awesome.png', 'https://test.com');"
  },
  {
    "className": "getBaseUri",
    "methodName": "getBaseUri",
    "description": "Given a URI, returns the base path of the URI.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // basePath will be \"/Gallery/\";\n * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false');\n *\n * // basePath will be \"/Gallery/?value=true&example=false\";\n * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false', true);"
  },
  {
    "className": "getExtensionFromUri",
    "methodName": "getExtensionFromUri",
    "description": "Given a URI, returns the extension of the URI.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //extension will be \"czml\";\n * const extension = Cesium.getExtensionFromUri('/Gallery/simple.czml?value=true&example=false');"
  },
  {
    "className": "getFilenameFromUri",
    "methodName": "getFilenameFromUri",
    "description": "Given a URI, returns the last segment of the URI, removing any path or query information.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //fileName will be\"simple.czml\";\n * const fileName = Cesium.getFilenameFromUri('/Gallery/simple.czml?value=true&example=false');"
  },
  {
    "className": "isLeapYear",
    "methodName": "isLeapYear",
    "description": "Determines if a given date is a leap year.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const leapYear = Cesium.isLeapYear(2000); // true"
  },
  {
    "className": "loadKTX2",
    "methodName": "loadKTX2",
    "description": "Asynchronously loads and parses the given URL to a KTX2 file or parses the raw binary data of a KTX2 file.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load a single URL asynchronously\n * Cesium.loadKTX2('some/url').then(function (ktx2Data) {\n *     const width = ktx2Data.width;\n *     const height = ktx2Data.height;\n *     const format = ktx2Data.internalFormat;\n *     const arrayBufferView = ktx2Data.bufferView;\n *     // use the data to create a texture\n * }).catch(function (error) {\n *     // an error occurred.\n * });\n *\n *"
  },
  {
    "className": "mergeSort",
    "methodName": "mergeSort",
    "description": "A stable merge sort.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Assume array contains BoundingSpheres in world coordinates.\n * // Sort them in ascending order of distance from the camera.\n * const position = camera.positionWC;\n * Cesium.mergeSort(array, function(a, b, position) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, position) - Cesium.BoundingSphere.distanceSquaredTo(a, position);\n * }, position);"
  },
  {
    "className": "objectToQuery",
    "methodName": "objectToQuery",
    "description": "Converts an object representing a set of name/value pairs into a query string,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const str = Cesium.objectToQuery({\n *     key1 : 'some value',\n *     key2 : 'a/b',\n *     key3 : ['x', 'y']\n * });\n *\n *"
  },
  {
    "className": "oneTimeWarning",
    "methodName": "oneTimeWarning",
    "description": "Logs a one time message to the console.  Use this function instead of",
    "parameters": [],
    "returnType": "unknown",
    "example": "* for(let i=0;i<foo.length;++i) {\n *    if (!defined(foo[i].bar)) {\n *       // Something that can be recovered from but may happen a lot\n *       oneTimeWarning('foo.bar undefined', 'foo.bar is undefined. Setting to 0.');\n *       foo[i].bar = 0;\n *       // ...\n *    }\n * }\n *\n *"
  },
  {
    "className": "pointInsideTriangle",
    "methodName": "pointInsideTriangle",
    "description": "Determines if a point is inside a triangle.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns true\n * const p = new Cesium.Cartesian2(0.25, 0.25);\n * const b = Cesium.pointInsideTriangle(p,\n *   new Cesium.Cartesian2(0.0, 0.0),\n *   new Cesium.Cartesian2(1.0, 0.0),\n *   new Cesium.Cartesian2(0.0, 1.0));"
  },
  {
    "className": "queryToObject",
    "methodName": "queryToObject",
    "description": "Parses a query string into an object, where the keys and values of the object are the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const obj = Cesium.queryToObject('key1=some%20value&key2=a%2Fb&key3=x&key3=y');\n * // obj will be:\n * // {\n * //   key1 : 'some value',\n * //   key2 : 'a/b',\n * //   key3 : ['x', 'y']\n * // }\n *\n *"
  },
  {
    "className": "sampleTerrain",
    "methodName": "sampleTerrain",
    "description": "Initiates a terrain height query for an array of {@link Cartographic} positions by",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Query the terrain height of two Cartographic positions\n * const terrainProvider = await Cesium.createWorldTerrainAsync();\n * const positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions);\n * // positions[0].height and positions[1].height have been updated.\n * // updatedPositions is just a reference to positions.\n *\n * // To handle tile errors, pass true for the rejectOnTileFail parameter.\n * try {\n *    const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions, true);\n * } catch (error) {\n *   // A tile request error occurred.\n * }"
  },
  {
    "className": "sampleTerrainMostDetailed",
    "methodName": "sampleTerrainMostDetailed",
    "description": "Initiates a sampleTerrain() request at the maximum available tile level for a terrain dataset.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Query the terrain height of two Cartographic positions\n * const terrainProvider = await Cesium.createWorldTerrainAsync();\n * const positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions);\n * // positions[0].height and positions[1].height have been updated.\n * // updatedPositions is just a reference to positions.\n *\n * // To handle tile errors, pass true for the rejectOnTileFail parameter.\n * try {\n *    const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions, true);\n * } catch (error) {\n *   // A tile request error occurred.\n * }"
  },
  {
    "className": "srgbToLinear",
    "methodName": "srgbToLinear",
    "description": "Converts the value from sRGB color space to linear color space.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const srgbColor = [0.5, 0.5, 0.5];\n * const linearColor = srgbColor.map(function (c) {\n *     return Cesium.srgbToLinear(c);\n * });"
  },
  {
    "className": "CompositeProperty",
    "methodName": "CompositeProperty",
    "description": "A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const constantProperty = ...;\n * const sampledProperty = ...;\n *\n * //Create a composite property from two previously defined properties\n * //where the property is valid on August 1st, 2012 and uses a constant\n * //property for the first half of the day and a sampled property for the\n * //remaining half.\n * const composite = new Cesium.CompositeProperty();\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',\n *     data : constantProperty\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',\n *     isStartIncluded : false,\n *     isStopIncluded : false,\n *     data : sampledProperty\n * }));\n *\n *"
  },
  {
    "className": "CustomDataSource",
    "methodName": "CustomDataSource",
    "description": "A {@link DataSource} implementation which can be used to manually manage a group of entities.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const dataSource = new Cesium.CustomDataSource('myData');\n *\n * const entity = dataSource.entities.add({\n *    position : Cesium.Cartesian3.fromDegrees(1, 2, 0),\n *    billboard : {\n *        image : 'image.png'\n *    }\n * });\n *\n * viewer.dataSources.add(dataSource);"
  },
  {
    "className": "DataSourceCollection",
    "methodName": "destroy",
    "description": "Destroys the resources held by all data sources in this collection.  Explicitly destroying this",
    "parameters": [],
    "returnType": "unknown",
    "example": "* dataSourceCollection = dataSourceCollection && dataSourceCollection.destroy();\n *\n *"
  },
  {
    "className": "DataSourceDisplay",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* dataSourceDisplay = dataSourceDisplay.destroy();\n *\n *"
  },
  {
    "className": "GeoJsonDataSource",
    "methodName": "GeoJsonDataSource",
    "description": "A {@link DataSource} which processes both",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.GeoJsonDataSource.load('../../SampleData/ne_10m_us_states.topojson', {\n *   stroke: Cesium.Color.HOTPINK,\n *   fill: Cesium.Color.PINK,\n *   strokeWidth: 3,\n *   markerSymbol: '?'\n * }));"
  },
  {
    "className": "GpxDataSource",
    "methodName": "GpxDataSource",
    "description": "A {@link DataSource} which processes the GPS Exchange Format (GPX).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.GpxDataSource.load('../../SampleData/track.gpx'));"
  },
  {
    "className": "KmlDataSource",
    "methodName": "KmlDataSource",
    "description": "A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',\n *      {\n *           camera: viewer.scene.camera,\n *           canvas: viewer.scene.canvas\n *      })\n * );"
  },
  {
    "className": "ReferenceProperty",
    "methodName": "ReferenceProperty",
    "description": "A {@link Property} which transparently links to another property on a provided object.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const collection = new Cesium.EntityCollection();\n *\n * //Create a new entity and assign a billboard scale.\n * const object1 = new Cesium.Entity({id:'object1'});\n * object1.billboard = new Cesium.BillboardGraphics();\n * object1.billboard.scale = new Cesium.ConstantProperty(2.0);\n * collection.add(object1);\n *\n * //Create a second entity and reference the scale from the first one.\n * const object2 = new Cesium.Entity({id:'object2'});\n * object2.model = new Cesium.ModelGraphics();\n * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);\n * collection.add(object2);\n *\n * //Create a third object, but use the fromString helper function.\n * const object3 = new Cesium.Entity({id:'object3'});\n * object3.billboard = new Cesium.BillboardGraphics();\n * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');\n * collection.add(object3);\n *\n * //You can refer to an entity with a # or . in id and property names by escaping them.\n * const object4 = new Cesium.Entity({id:'#object.4'});\n * object4.billboard = new Cesium.BillboardGraphics();\n * object4.billboard.scale = new Cesium.ConstantProperty(2.0);\n * collection.add(object4);\n *\n * const object5 = new Cesium.Entity({id:'object5'});\n * object5.billboard = new Cesium.BillboardGraphics();\n * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\\\#object\\\\.4#billboard.scale');\n * collection.add(object5);"
  },
  {
    "className": "Rotation",
    "methodName": "Rotation",
    "description": "Represents a {@link Packable} number that always interpolates values",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const time1 = Cesium.JulianDate.fromIso8601('2010-05-07T00:00:00');\n * const time2 = Cesium.JulianDate.fromIso8601('2010-05-07T00:01:00');\n * const time3 = Cesium.JulianDate.fromIso8601('2010-05-07T00:02:00');\n *\n * const property = new Cesium.SampledProperty(Cesium.Rotation);\n * property.addSample(time1, 0);\n * property.addSample(time3, Cesium.Math.toRadians(350));\n *\n * //Getting the value at time2 will equal 355 degrees instead\n * //of 175 degrees (which is what you get if you construct\n * //a SampledProperty(Number) instead.  Note, the actual\n * //return value is in radians, not degrees.\n * property.getValue(time2);\n *\n *"
  },
  {
    "className": "SampledProperty",
    "methodName": "SampledProperty",
    "description": "A {@link Property} whose value is interpolated for a given time from the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create a linearly interpolated Cartesian2\n * const property = new Cesium.SampledProperty(Cesium.Cartesian2);\n *\n * //Populate it with data\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), new Cesium.Cartesian2(0, 0));\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-02T00:00:00.00Z'), new Cesium.Cartesian2(4, 7));\n *\n * //Retrieve an interpolated value\n * const result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T12:00:00.00Z'));\n *\n *"
  },
  {
    "className": "TimeIntervalCollectionProperty",
    "methodName": "TimeIntervalCollectionProperty",
    "description": "A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create a Cartesian2 interval property which contains data on August 1st, 2012\n * //and uses a different value every 6 hours.\n * const composite = new Cesium.TimeIntervalCollectionProperty();\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T06:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(2.0, 3.4)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T06:00:00.00Z/2012-08-01T12:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(12.0, 2.7)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-01T18:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(5.0, 12.4)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T18:00:00.00Z/2012-08-02T00:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : true,\n *     data : new Cesium.Cartesian2(85.0, 4.1)\n * }));"
  },
  {
    "className": "VelocityOrientationProperty",
    "methodName": "VelocityOrientationProperty",
    "description": "A {@link Property} which evaluates to a {@link Quaternion} rotation",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create an entity with position and orientation.\n * const position = new Cesium.SampledProperty();\n * position.addSamples(...);\n * const entity = viewer.entities.add({\n *   position : position,\n *   orientation : new Cesium.VelocityOrientationProperty(position)\n * }));"
  },
  {
    "className": "VelocityVectorProperty",
    "methodName": "VelocityVectorProperty",
    "description": "A {@link Property} which evaluates to a {@link Cartesian3} vector",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create an entity with a billboard rotated to match its velocity.\n * const position = new Cesium.SampledProperty();\n * position.addSamples(...);\n * const entity = viewer.entities.add({\n *   position : position,\n *   billboard : {\n *     image : 'image.png',\n *     alignedAxis : new Cesium.VelocityVectorProperty(position, true) // alignedAxis must be a unit vector\n *   }\n * }));"
  },
  {
    "className": "exportKml",
    "methodName": "exportKml",
    "description": "Exports an EntityCollection as a KML document. Only Point, Billboard, Model, Path, Polygon, Polyline geometries",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.exportKml({\n *      entities: entityCollection\n *  })\n *   .then(function(result) {\n *     // The XML string is in result.kml\n *\n *     const externalFiles = result.externalFiles\n *     for(const file in externalFiles) {\n *       // file is the name of the file used in the KML document as the href\n *       // externalFiles[file] is a blob with the contents of the file\n *     }\n *   });\n *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec4 czm_viewport;\n   *\n   * // Scale the window coordinate components to [0, 1] by dividing\n   * // by the viewport's width and height.\n   * vec2 v = gl_FragCoord.xy / czm_viewport.zw;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 orthographic projection matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_viewportOrthographic;\n   *\n   * // Example\n   * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_viewportTransformation;\n   *\n   * // Use czm_viewportTransformation as part of the\n   * // transform from model to window coordinates.\n   * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates\n   * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)\n   * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the depth of the scene",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform sampler2D czm_globeDepthTexture;\n   *\n   * // Get the depth at the current fragment\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * float depth = czm_unpackDepth(texture(czm_globeDepthTexture, coords));"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a texture containing edge IDs",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform sampler2D czm_edgeIdTexture;\n   *\n   * // Get the edge ID at the current fragment\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * vec4 edgeId = texture(czm_edgeIdTexture, coords);"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the edge color texture.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform sampler2D czm_edgeColorTexture;\n   *\n   * // Sample the edge color at the current fragment\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * vec4 edgeColor = texture(czm_edgeColorTexture, coords);"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the packed depth texture produced by the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform sampler2D czm_edgeDepthTexture;\n   *\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * float d = czm_unpackDepth(texture(czm_edgeDepthTexture, coords));"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_model;\n   *\n   * // Example\n   * vec4 worldPosition = czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseModel;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModel * worldPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 view transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_view;\n   *\n   * // Example\n   * vec4 eyePosition = czm_view * worldPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 view transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_view3D;\n   *\n   * // Example\n   * vec4 eyePosition3D = czm_view3D * worldPosition3D;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 view rotation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_viewRotation;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation * worldVector;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 view rotation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_viewRotation3D;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation3D * worldVector;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseView;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseView3D;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView3D * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 rotation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation * eyeVector;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 rotation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation3D;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation3D * eyeVector;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_projection;\n   *\n   * // Example\n   * gl_Position = czm_projection * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseProjection;\n   *\n   * // Example\n   * vec4 eyePosition = czm_inverseProjection * clipPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_infiniteProjection;\n   *\n   * // Example\n   * gl_Position = czm_infiniteProjection * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelView;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view * czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelView3D;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView3D * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view3D * czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelViewRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);\n   * }\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseModelView;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseModelView3D;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView3D * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_viewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseViewProjection;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseViewProjection * clipPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelViewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 inverse model-view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseModelViewProjection;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelViewProjection * clipPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelViewProjectionRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n   * }\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelViewInfiniteProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 normal transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_normal;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal * normal;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 normal transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_normal3D;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal3D * normal;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 normal transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_inverseNormal;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal * normalEC;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 normal transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_inverseNormal3D;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal3D * normalEC;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec2 czm_entireFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec2 czm_currentFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_currentFrustum.y - czm_currentFrustum.x;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the sun position in world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_sunPositionWC;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the sun position in Columbus view world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_sunPositionColumbusView;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_sunDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_sunDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionWC, normalWC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_moonDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the normalized direction to the scene's light source in eye coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_lightDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionEC, normalEC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the normalized direction to the scene's light source in world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_lightDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform that represents the color of light emitted by the scene's light source. This",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_lightColor;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColor * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform that represents the high dynamic range color of light emitted by the scene's light",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_lightColorHdr;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColorHdr * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the high bits of the camera position in model",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCHigh;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the low bits of the camera position in model",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCLow;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_viewerPositionWC;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the frame number. This uniform is automatically incremented",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_frameNumber;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the current morph transition time between",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_morphTime;\n   *\n   * // Example\n   * vec4 p = czm_columbusViewMorph(position2D, position3D, czm_morphTime);"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the current {@link SceneMode}, expressed",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_sceneMode;\n   *\n   * // Example\n   * if (czm_sceneMode == czm_sceneMode2D)\n   * {\n   *     eyeHeightSq = czm_eyeHeight2D.y;\n   * }\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the current rendering pass.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_pass;\n   *\n   * // Example\n   * if ((czm_pass == czm_passTranslucent) && isOpaque())\n   * {\n   *     gl_Position *= 0.0; // Cull opaque geometry in the translucent pass\n   * }"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the current scene background color.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec4 czm_backgroundColor;\n   *\n   * // Example: If the given color's RGB matches the background color, invert it.\n   * vec4 adjustColorForContrast(vec4 color)\n   * {\n   *     if (czm_backgroundColor.rgb == color.rgb)\n   *     {\n   *         color.rgb = vec3(1.0) - color.rgb;\n   *     }\n   *\n   *     return color;\n   * }"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the BRDF look up texture used for image-based lighting computations.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform sampler2D czm_brdfLut;\n   *\n   * // Example: For a given roughness and NdotV value, find the material's BRDF information in the red and green channels\n   * float roughness = 0.5;\n   * float NdotV = dot(normal, view);\n   * vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the environment map used within the scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform samplerCube czm_environmentMap;\n   *\n   * // Example: Create a perfect reflection of the environment map on a  model\n   * float reflected = reflect(view, normal);\n   * vec4 reflectedColor = texture(czm_environmentMap, reflected);"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the specular environment cube map used within the scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform samplerCube czm_specularEnvironmentMaps;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the maximum valid level-of-detail of the specular environment cube map used within the scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_specularEnvironmentMapsMaximumLOD;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the spherical harmonic coefficients used within the scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3[9] czm_sphericalHarmonicCoefficients;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 rotation matrix that transforms",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_temeToPseudoFixed;\n   *\n   * // Example\n   * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the ratio of canvas coordinate space to canvas pixel space.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform float czm_pixelRatio;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the color shift for the atmosphere in HSB color space",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform vec3 czm_atmosphereHsbShift;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the intensity of the light that is used for computing the atmosphere color",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform float czm_atmosphereLightIntensity;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the Rayleigh scattering coefficient used when computing the atmosphere scattering",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform vec3 czm_atmosphereRayleighCoefficient;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the Rayleigh scale height in meters used for computing atmosphere scattering.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform vec3 czm_atmosphereRayleighScaleHeight;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the Mie scattering coefficient used when computing atmosphere scattering.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform vec3 czm_atmosphereMieCoefficient;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform storign the Mie scale height used when computing atmosphere scattering.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform float czm_atmosphereMieScaleHeight;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the anisotropy of the medium to consider for Mie scattering.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform float czm_atmosphereAnisotropy;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing which light source to use for dynamic lighting",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform float czm_atmosphereDynamicLighting"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the splitter position to use when rendering with a splitter.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_splitPosition;"
  },
  {
    "className": "Buffer",
    "methodName": "createVertexBuffer",
    "description": "Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Create a dynamic vertex buffer 16 bytes in size.\n * const buffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.DYNAMIC_DRAW\n * });\n *\n *"
  },
  {
    "className": "Buffer",
    "methodName": "createIndexBuffer",
    "description": "Creates an index buffer, which contains typed indices in GPU-controlled memory.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Create a stream index buffer of unsigned shorts that is\n * // 16 bytes in size.\n * const buffer = Buffer.createIndexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.STREAM_DRAW,\n *     indexDatatype : IndexDatatype.UNSIGNED_SHORT\n * });\n *\n *"
  },
  {
    "className": "Context",
    "methodName": "getObjectByPickColor",
    "description": "Gets the object associated with a pick color.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const object = context.getObjectByPickColor(pickColor);\n *\n *"
  },
  {
    "className": "Context",
    "methodName": "createPickId",
    "description": "Creates a unique ID associated with the input object for use with color-buffer picking.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* this._pickId = context.createPickId({\n *   primitive : this,\n *   id : this.id\n * });\n *\n *"
  },
  {
    "className": "CubeMap",
    "methodName": "generateMipmap",
    "description": "Generates a complete mipmap chain for each cubemap face.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Generate mipmaps, and then set the sampler so mipmaps are used for\n * // minification when the cube map is sampled.\n * cubeMap.generateMipmap();\n * cubeMap.sampler = new Sampler({\n *   minificationFilter : Cesium.TextureMinificationFilter.NEAREST_MIPMAP_LINEAR\n * });"
  },
  {
    "className": "CubeMapFace",
    "methodName": "copyFrom",
    "description": "Copies texels from the source to the cubemap's face.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a cubemap with 1x1 faces, and make the +x face red.\n * const cubeMap = new CubeMap({\n *   context : context\n *   width : 1,\n *   height : 1\n * });\n * cubeMap.positiveX.copyFrom({\n *   source: {\n *     width : 1,\n *     height : 1,\n *     arrayBufferView : new Uint8Array([255, 0, 0, 255])\n *   }\n * });"
  },
  {
    "className": "CubeMapFace",
    "methodName": "copyFromFramebuffer",
    "description": "Copies texels from the framebuffer to the cubemap's face.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Copy the framebuffer contents to the +x cube map face.\n * cubeMap.positiveX.copyFromFramebuffer();"
  },
  {
    "className": "CubeMapFace",
    "methodName": "copyMipmapFromFramebuffer",
    "description": "Copies texels from the framebuffer to the cubemap's face mipmap.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Copy the framebuffer contents to the +x cube map face.\n * cubeMap.positiveX.copyFromFramebuffer();"
  },
  {
    "className": "Framebuffer",
    "methodName": "Framebuffer",
    "description": "Creates a framebuffer with optional initial color, depth, and stencil attachments.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a framebuffer with color and depth texture attachments.\n * const width = context.canvas.clientWidth;\n * const height = context.canvas.clientHeight;\n * const framebuffer = new Framebuffer({\n *   context : context,\n *   colorTextures : [new Texture({\n *     context : context,\n *     width : width,\n *     height : height,\n *     pixelFormat : PixelFormat.RGBA\n *   })],\n *   depthTexture : new Texture({\n *     context : context,\n *     width : width,\n *     height : height,\n *     pixelFormat : PixelFormat.DEPTH_COMPONENT,\n *     pixelDatatype : PixelDatatype.UNSIGNED_SHORT\n *   })\n * });\n *\n *"
  },
  {
    "className": "RenderState",
    "methodName": "fromCache",
    "description": "Validates and then finds or creates an immutable render state, which defines the pipeline",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const defaults = {\n *     frontFace : WindingOrder.COUNTER_CLOCKWISE,\n *     cull : {\n *         enabled : false,\n *         face : CullFace.BACK\n *     },\n *     lineWidth : 1,\n *     polygonOffset : {\n *         enabled : false,\n *         factor : 0,\n *         units : 0\n *     },\n *     scissorTest : {\n *         enabled : false,\n *         rectangle : {\n *             x : 0,\n *             y : 0,\n *             width : 0,\n *             height : 0\n *         }\n *     },\n *     depthRange : {\n *         near : 0,\n *         far : 1\n *     },\n *     depthTest : {\n *         enabled : false,\n *         func : DepthFunction.LESS\n *      },\n *     colorMask : {\n *         red : true,\n *         green : true,\n *         blue : true,\n *         alpha : true\n *     },\n *     depthMask : true,\n *     stencilMask : ~0,\n *     blending : {\n *         enabled : false,\n *         color : {\n *             red : 0.0,\n *             green : 0.0,\n *             blue : 0.0,\n *             alpha : 0.0\n *         },\n *         equationRgb : BlendEquation.ADD,\n *         equationAlpha : BlendEquation.ADD,\n *         functionSourceRgb : BlendFunction.ONE,\n *         functionSourceAlpha : BlendFunction.ONE,\n *         functionDestinationRgb : BlendFunction.ZERO,\n *         functionDestinationAlpha : BlendFunction.ZERO\n *     },\n *     stencilTest : {\n *         enabled : false,\n *         frontFunction : StencilFunction.ALWAYS,\n *         backFunction : StencilFunction.ALWAYS,\n *         reference : 0,\n *         mask : ~0,\n *         frontOperation : {\n *             fail : StencilOperation.KEEP,\n *             zFail : StencilOperation.KEEP,\n *             zPass : StencilOperation.KEEP\n *         },\n *         backOperation : {\n *             fail : StencilOperation.KEEP,\n *             zFail : StencilOperation.KEEP,\n *             zPass : StencilOperation.KEEP\n *         }\n *     },\n *     sampleCoverage : {\n *         enabled : false,\n *         value : 1.0,\n *         invert : false\n *      }\n * };\n *\n * const rs = RenderState.fromCache(defaults);\n *\n *"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "ShaderBuilder",
    "description": "An object that makes it easier to build the text of a {@link ShaderProgram}. This tracks GLSL code for both the vertex shader and the fragment shader.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const shaderBuilder = new ShaderBuilder();\n * shaderBuilder.addDefine(\"SOLID_COLOR\", undefined, ShaderDestination.FRAGMENT);\n * shaderBuilder.addUniform(\"vec3\", \"u_color\", ShaderDestination.FRAGMENT);\n * shaderBuilder.addVarying(\"vec3\", v_color\");\n * // These locations can be used when creating the VertexArray\n * const positionLocation = shaderBuilder.addPositionAttribute(\"vec3\", \"a_position\");\n * const colorLocation = shaderBuilder.addAttribute(\"vec3\", \"a_color\");\n * shaderBuilder.addVertexLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    v_color = a_color;\",\n *  \"    gl_Position = vec4(a_position, 1.0);\",\n *  \"}\"\n * ]);\n * shaderBuilder.addFragmentLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    #ifdef SOLID_COLOR\",\n *  \"    out_FragColor = vec4(u_color, 1.0);\",\n *  \"    #else\",\n *  \"    out_FragColor = vec4(v_color, 1.0);\",\n *  \"    #endif\",\n *  \"}\"\n * ]);\n * const shaderProgram = shaderBuilder.build(context);\n *\n *"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addDefine",
    "description": "Add a <code>#define</code> macro to one or both of the shaders. These lines",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates the line \"#define ENABLE_LIGHTING\" in both shaders\n * shaderBuilder.addDefine(\"ENABLE_LIGHTING\");\n * // creates the line \"#define PI 3.141592\" in the fragment shader\n * shaderBuilder.addDefine(\"PI\", 3.141593, ShaderDestination.FRAGMENT);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addStruct",
    "description": "Add a new dynamically-generated struct to the shader",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // generates the following struct in the fragment shader\n * // struct TestStruct\n * // {\n * // };\n * shaderBuilder.addStruct(\"testStructId\", \"TestStruct\", ShaderDestination.FRAGMENT);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addStructField",
    "description": "Add a field to a dynamically-generated struct.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // generates the following struct in the fragment shader\n * // struct TestStruct\n * // {\n * //    float minimum;\n * //    float maximum;\n * // };\n * shaderBuilder.addStruct(\"testStructId\", \"TestStruct\", ShaderDestination.FRAGMENT);\n * shaderBuilder.addStructField(\"testStructId\", \"float\", \"maximum\");\n * shaderBuilder.addStructField(\"testStructId\", \"float\", \"minimum\");"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addFunction",
    "description": "Add a new dynamically-generated function to the shader.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // generates the following function in the vertex shader\n * // vec3 testFunction(float parameter)\n * // {\n * // }\n * shaderBuilder.addStruct(\"testFunction\", \"vec3 testFunction(float parameter)\", ShaderDestination.VERTEX);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addFunctionLines",
    "description": "Add lines to a dynamically-generated function",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // generates the following function in the vertex shader\n * // vec3 testFunction(float parameter)\n * // {\n * //   float signed = 2.0 * parameter - 1.0;\n * //   return vec3(signed, 0.0, 0.0);\n * // }\n * shaderBuilder.addStruct(\"testFunction\", \"vec3 testFunction(float parameter)\", ShaderDestination.VERTEX);\n * shaderBuilder.addFunctionLines(\"testFunction\", [\n *   \"float signed = 2.0 * parameter - 1.0;\",\n *   \"return vec3(parameter);\"\n * ]);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addUniform",
    "description": "Add a uniform declaration to one or both of the shaders. These lines",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates the line \"uniform vec3 u_resolution;\"\n * shaderBuilder.addUniform(\"vec3\", \"u_resolution\", ShaderDestination.FRAGMENT);\n * // creates the line \"uniform float u_time;\" in both shaders\n * shaderBuilder.addUniform(\"float\", \"u_time\", ShaderDestination.BOTH);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "setPositionAttribute",
    "description": "Add a position attribute declaration to the vertex shader. These lines",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates the line \"in vec3 a_position;\"\n * shaderBuilder.setPositionAttribute(\"vec3\", \"a_position\");"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addAttribute",
    "description": "Add an attribute declaration to the vertex shader. These lines",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates the line \"in vec2 a_texCoord0;\" in the vertex shader\n * shaderBuilder.addAttribute(\"vec2\", \"a_texCoord0\");"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addVarying",
    "description": "Add a varying declaration to both the vertex and fragment shaders.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates the line \"in vec3 v_color;\" in the vertex shader\n * // creates the line \"out vec3 v_color;\" in the fragment shader\n * shaderBuilder.addVarying(\"vec3\", \"v_color\");"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addVertexLines",
    "description": "Appends lines of GLSL code to the vertex shader",
    "parameters": [],
    "returnType": "unknown",
    "example": "* shaderBuilder.addVertexLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    v_color = a_color;\",\n *  \"    gl_Position = vec4(a_position, 1.0);\",\n *  \"}\"\n * ]);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addFragmentLines",
    "description": "Appends lines of GLSL code to the fragment shader",
    "parameters": [],
    "returnType": "unknown",
    "example": "* shaderBuilder.addFragmentLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    #ifdef SOLID_COLOR\",\n *  \"    out_FragColor = vec4(u_color, 1.0);\",\n *  \"    #else\",\n *  \"    out_FragColor = vec4(v_color, 1.0);\",\n *  \"    #endif\",\n *  \"}\"\n * ]);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "buildShaderProgram",
    "description": "Builds the {@link ShaderProgram} from the pieces added by the other methods.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const shaderProgram = shaderBuilder.buildShaderProgram(context);"
  },
  {
    "className": "ShaderCache",
    "methodName": "replaceShaderProgram",
    "description": "Returns a shader program from the cache, or creates and caches a new shader program,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* this._shaderProgram = context.shaderCache.replaceShaderProgram({\n     *     shaderProgram : this._shaderProgram,\n     *     vertexShaderSource : vs,\n     *     fragmentShaderSource : fs,\n     *     attributeLocations : attributeLocations\n     * });\n     *\n     *"
  },
  {
    "className": "ShaderFunction",
    "methodName": "ShaderFunction",
    "description": "A utility for dynamically-generating a GLSL function",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // generate the following function\n * //\n * // void assignVaryings(vec3 position)\n * // {\n * //    v_positionEC = (czm_modelView * vec4(a_position, 1.0)).xyz;\n * //    v_texCoord = a_texCoord;\n * // }\n * const signature = \"void assignVaryings(vec3 position)\";\n * const func = new ShaderFunction(signature);\n * func.addLine(\"v_positionEC = (czm_modelView * vec4(a_position, 1.0)).xyz;\");\n * func.addLine(\"v_texCoord = a_texCoord;\");\n * const generatedLines = func.generateGlslLines();\n *\n *"
  },
  {
    "className": "ShaderSource",
    "methodName": "ShaderSource",
    "description": "An object containing various inputs that will be combined to form a final GLSL shader string.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Prepend #defines to a shader\n * const source = new Cesium.ShaderSource({\n *   defines : ['WHITE'],\n *   sources : ['void main() { \\n#ifdef WHITE\\n out_FragColor = vec4(1.0); \\n#else\\n out_FragColor = vec4(0.0); \\n#endif\\n }']\n * });\n *\n * // 2. Modify a fragment shader for picking\n * const source2 = new Cesium.ShaderSource({\n *   sources : ['void main() { out_FragColor = vec4(1.0); }'],\n *   pickColorQualifier : 'uniform'\n * });\n *\n *"
  },
  {
    "className": "ShaderStruct",
    "methodName": "ShaderStruct",
    "description": "A utility for dynamically-generating a GLSL struct.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Generate the struct:\n * //\n * // struct Attributes\n * // {\n * //     vec3 position;\n * //     vec3 normal;\n * //     vec2 texCoord;\n * // };\n * const struct = new ShaderStruct(\"Attributes\");\n * struct.addField(\"vec3\", \"position\");\n * struct.addField(\"vec3\", \"normal\");\n * struct.addField(\"vec2\", \"texCoord\");\n * const generatedLines = struct.generateGlslLines();\n *\n *"
  },
  {
    "className": "SharedContext",
    "methodName": "SharedContext",
    "description": "Enables a single WebGL context to be used by any number of {@link Scene}s.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create two Scenes sharing a single WebGL context\n * const context = new Cesium.SharedContext();\n * const scene1 = new Cesium.Scene({\n *   canvas: canvas1,\n *   contextOptions: context,\n * });\n * const scene2 = new Cesium.Scene({\n *   canvas: canvas2,\n *   contextOptions: context,\n * });"
  },
  {
    "className": "SharedContext",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object. Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* context = context && context.destroy();\n *\n *"
  },
  {
    "className": "Sync",
    "methodName": "waitForSignal",
    "description": "Incremantally polls the status of the Sync object until signaled then resolves.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *  await sync.waitForSignal(function (next) {\n *    setTimeout(next, 100);\n *  });\n *} catch (e) {\n *  throw \"Signal timeout\";\n *} finally {\n *  sync.destroy();\n *}\n *\n *"
  },
  {
    "className": "Texture",
    "methodName": "fromFramebuffer",
    "description": "Creates a texture, and copies a subimage of the framebuffer to it.  When called without arguments,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a texture with the contents of the framebuffer.\n * const t = Texture.fromFramebuffer({\n *     context : context\n * });\n *\n *"
  },
  {
    "className": "Texture",
    "methodName": "copyFrom",
    "description": "Copy new image data into this texture, from a source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, or {@link HTMLVideoElement}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* texture.copyFrom({\n *  source: {\n *   width : 1,\n *   height : 1,\n *   arrayBufferView : new Uint8Array([255, 0, 0, 255])\n *  }\n * });"
  },
  {
    "className": "TextureAtlas",
    "methodName": "computeTextureCoordinates",
    "description": "Get the texture coordinates for reading the associated image in shaders.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const index = await atlas.addImage(\"myImage\", image);\n * const rectangle = atlas.computeTextureCoordinates(index);\n * BoundingRectangle.pack(rectangle, bufferView);"
  },
  {
    "className": "TextureAtlas",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* atlas = atlas && atlas.destroy();\n *"
  },
  {
    "className": "VertexArray",
    "methodName": "VertexArray",
    "description": "Creates a vertex array, which defines the attributes making up a vertex, and contains an optional index buffer",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Create a vertex array with vertices made up of three floating point\n * // values, e.g., a position, from a single vertex buffer.  No index buffer is used.\n * const positionBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * const attributes = [\n *     {\n *         index                  : 0,\n *         enabled                : true,\n *         vertexBuffer           : positionBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         normalize              : false,\n *         offsetInBytes          : 0,\n *         strideInBytes          : 0 // tightly packed\n *         instanceDivisor        : 0 // not instanced\n *     }\n * ];\n * const va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n *"
  },
  {
    "className": "VertexArray",
    "methodName": "fromGeometry",
    "description": "Creates a vertex array from a geometry.  A geometry contains vertex attributes and optional index data",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Creates a vertex array for rendering a box.  The default dynamic draw\n * // usage is used for the created vertex and index buffer.  The attributes are not\n * // interleaved by default.\n * const geometry = new BoxGeometry();\n * const va = VertexArray.fromGeometry({\n *     context            : context,\n *     geometry           : geometry,\n *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),\n * });\n *\n *"
  },
  {
    "className": "loadCubeMap",
    "methodName": "loadCubeMap",
    "description": "Asynchronously loads six images and creates a cube map.  Returns a promise that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.loadCubeMap(context, {\n *     positiveX : 'skybox_px.png',\n *     negativeX : 'skybox_nx.png',\n *     positiveY : 'skybox_py.png',\n *     negativeY : 'skybox_ny.png',\n *     positiveZ : 'skybox_pz.png',\n *     negativeZ : 'skybox_nz.png'\n * }).then(function(cubeMap) {\n *     // use the cubemap\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "ArcGisMapServerImageryProvider",
    "methodName": "ArcGisMapServerImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set the default access token for accessing ArcGIS Image Tile service\n * Cesium.ArcGisMapService.defaultAccessToken = \"<ArcGIS Access Token>\";\n *\n * // Add a base layer from a default ArcGIS basemap\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(\n *     Cesium.ArcGisMapServerImageryProvider.fromBasemapType(\n *       Cesium.ArcGisBaseMapType.SATELLITE\n *     )\n *   ),\n * });\n *\n *"
  },
  {
    "className": "ArcGisMapServerImageryProvider",
    "methodName": "fromBasemapType",
    "description": "Creates an {@link ImageryProvider} which provides tiled imagery from an ArcGIS base map.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set the default access token for accessing ArcGIS Image Tile service\n * Cesium.ArcGisMapService.defaultAccessToken = \"<ArcGIS Access Token>\";\n *\n * // Add a base layer from a default ArcGIS basemap\n * const provider = await Cesium.ArcGisMapServerImageryProvider.fromBasemapType(\n *   Cesium.ArcGisBaseMapType.SATELLITE);\n *\n *"
  },
  {
    "className": "ArcGisMapServerImageryProvider",
    "methodName": "fromUrl",
    "description": "Creates an {@link ImageryProvider} which provides tiled imagery hosted by an ArcGIS MapServer.  By default, the server's pre-cached tiles are",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const esri = await Cesium.ArcGisMapServerImageryProvider.fromUrl(\n *     \"https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer\"\n * );\n *\n *"
  },
  {
    "className": "Atmosphere",
    "methodName": "Atmosphere",
    "description": "Common atmosphere settings used by 3D Tiles and models for rendering sky atmosphere, ground atmosphere, and fog.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Turn on dynamic atmosphere lighting using the sun direction\n * scene.atmosphere.dynamicLighting = Cesium.DynamicAtmosphereLightingType.SUNLIGHT;\n *\n *"
  },
  {
    "className": "Azure2DImageryProvider",
    "methodName": "Azure2DImageryProvider",
    "description": "Provides 2D image tiles from Azure.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Azure 2D imagery provider\n * const azureImageryProvider = new Cesium.Azure2DImageryProvider({\n *     subscriptionKey: \"subscription-key\",\n *     tilesetId: \"microsoft.base.road\"\n * });"
  },
  {
    "className": "BatchTable",
    "methodName": "BatchTable",
    "description": "Creates a texture to look up per instance attributes for batched primitives. For example, store each primitive's pick color in the texture.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create the batch table\n * const attributes = [{\n *     functionName : 'getShow',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 1\n * }, {\n *     functionName : 'getPickColor',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 4,\n *     normalize : true\n * }];\n * const batchTable = new BatchTable(context, attributes, 5);\n *\n * // when creating the draw commands, update the uniform map and the vertex shader\n * vertexShaderSource = batchTable.getVertexShaderCallback()(vertexShaderSource);\n * const shaderProgram = ShaderProgram.fromCache({\n *    // ...\n *    vertexShaderSource : vertexShaderSource,\n * });\n *\n * drawCommand.shaderProgram = shaderProgram;\n * drawCommand.uniformMap = batchTable.getUniformMapCallback()(uniformMap);\n *\n * // use the attribute function names in the shader to retrieve the instance values\n * // ...\n * attribute float batchId;\n *\n * void main() {\n *     // ...\n *     float show = getShow(batchId);\n *     vec3 pickColor = getPickColor(batchId);\n *     // ...\n * }"
  },
  {
    "className": "BatchTexture",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets near and far scaling properties of a Billboard based on the billboard's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a billboard's scaleByDistance to scale by 1.5 when the\n   * // camera is 1500 meters from the billboard and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * b.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets near and far translucency properties of a Billboard based on the billboard's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a billboard's translucency to 1.0 when the\n   * // camera is 1500 meters from the billboard and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * b.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets near and far pixel offset scaling properties of a Billboard based on the billboard's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a billboard's pixel offset scale to 0.0 when the\n   * // camera is 1500 meters from the billboard and scale pixel offset to 10.0 pixels\n   * // in the y direction the camera distance approaches 8.0e6 meters.\n   * b.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);\n   * b.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);\n   *\n   *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets the horizontal origin of this billboard, which determines if the billboard is",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use a bottom, left origin\n   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;\n   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets the vertical origin of this billboard, which determines if the billboard is",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use a bottom, left origin\n   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;\n   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Assign yellow.\n   * b.color = Cesium.Color.YELLOW;\n   *\n   *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets the aligned axis in world space. The aligned axis is the unit vector that the billboard up vector points towards.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Have the billboard up vector point north\n   * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;\n   *\n   *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "<p>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load an image from a URL\n   * b.image = 'some/image/url.png';\n   *\n   * // assuming b1 and b2 are billboards in the same billboard collection,\n   * // use the same image for both billboards.\n   * b2.image = b1.image;"
  },
  {
    "className": "Billboard",
    "methodName": "setImage",
    "description": "<p>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a billboard image dynamically\n * function drawImage(id) {\n *   // create and draw an image using a canvas\n *   const canvas = document.createElement('canvas');\n *   const context2D = canvas.getContext('2d');\n *   // ... draw image\n *   return canvas;\n * }\n * // drawImage will be called to create the texture\n * b.setImage('myImage', drawImage);\n *\n * // subsequent billboards created in the same collection using the same id will use the existing\n * // texture, without the need to create the canvas or draw the image\n * b2.setImage('myImage', drawImage);"
  },
  {
    "className": "Billboard",
    "methodName": "computeScreenSpacePosition",
    "description": "Computes the screen-space position of the billboard's origin, taking into account eye and pixel offsets.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* console.log(b.computeScreenSpacePosition(scene).toString());\n *\n *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "BillboardCollection",
    "description": "A renderable collection of billboards.  Billboards are viewport-aligned",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a billboard collection with two billboards\n * const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n * billboards.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   image : 'url/to/image'\n * });\n * billboards.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   image : 'url/to/another/image'\n * });"
  },
  {
    "className": "BillboardCollection",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * billboards.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "function",
    "description": "Gets or sets a value which determines if the texture atlas is",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set destroyTextureAtlas\n   * // Destroy a billboard collection but not its texture atlas.\n   *\n   * const atlas = new TextureAtlas();\n   * billboards.textureAtlas = atlas;\n   * billboards.destroyTextureAtlas = false;\n   *\n   * billboards = billboards.destroy();\n   * console.log(atlas.isDestroyed()); // False"
  },
  {
    "className": "BillboardCollection",
    "methodName": "add",
    "description": "Creates and adds a billboard with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1:  Add a billboard, specifying all the default values.\n * const b = billboards.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   heightReference : Cesium.HeightReference.NONE,\n *   horizontalOrigin : Cesium.HorizontalOrigin.CENTER,\n *   verticalOrigin : Cesium.VerticalOrigin.CENTER,\n *   scale : 1.0,\n *   image : 'url/to/image',\n *   imageSubRegion : undefined,\n *   color : Cesium.Color.WHITE,\n *   id : undefined,\n *   rotation : 0.0,\n *   alignedAxis : Cesium.Cartesian3.ZERO,\n *   width : undefined,\n *   height : undefined,\n *   scaleByDistance : undefined,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   sizeInMeters : false,\n *   distanceDisplayCondition : undefined\n * });\n *\n *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "remove",
    "description": "Removes a billboard from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const b = billboards.add(...);\n * billboards.remove(b);  // Returns true\n *\n *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "removeAll",
    "description": "Removes all billboards from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* billboards.add(...);\n * billboards.add(...);\n * billboards.removeAll();\n *\n *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "get",
    "description": "Returns the billboard in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every billboard in the collection\n * const len = billboards.length;\n * for (let i = 0; i < len; ++i) {\n *   const b = billboards.get(i);\n *   b.show = !b.show;\n * }\n *\n *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* billboards = billboards && billboards.destroy();\n *\n *"
  },
  {
    "className": "BingMapsImageryProvider",
    "methodName": "BingMapsImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const bing = await Cesium.BingMapsImageryProvider.fromUrl(\n *   \"https://dev.virtualearth.net\", {\n *     key: \"get-yours-at-https://www.bingmapsportal.com/\",\n *     mapStyle: Cesium.BingMapsStyle.AERIAL\n * });\n *\n *"
  },
  {
    "className": "BingMapsImageryProvider",
    "methodName": "fromUrl",
    "description": "Creates an {@link ImageryProvider} which provides tiled imagery using the Bing Maps Imagery REST API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const bing = await Cesium.BingMapsImageryProvider.fromUrl(\n *   \"https://dev.virtualearth.net\", {\n *     key: \"get-yours-at-https://www.bingmapsportal.com/\",\n *     mapStyle: Cesium.BingMapsStyle.AERIAL\n * });\n *\n *"
  },
  {
    "className": "Camera",
    "methodName": "Camera",
    "description": "The camera is defined by a position, orientation, and view frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * const camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;"
  },
  {
    "className": "Camera",
    "methodName": "setView",
    "description": "Sets the camera position, orientation and transform.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });"
  },
  {
    "className": "Camera",
    "methodName": "lookAt",
    "description": "Sets the camera position and orientation using a target and offset. The target must be given in",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Using a cartesian offset\n * const center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));"
  },
  {
    "className": "Camera",
    "methodName": "lookAtTransform",
    "description": "Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Using a cartesian offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));"
  },
  {
    "className": "Camera",
    "methodName": "pickEllipsoid",
    "description": "Pick an ellipsoid or map.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const canvas = viewer.scene.canvas;\n * const center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * const ellipsoid = viewer.scene.ellipsoid;\n * const result = viewer.camera.pickEllipsoid(center, ellipsoid);"
  },
  {
    "className": "Camera",
    "methodName": "flyTo",
    "description": "Flies the camera from its current position to a new position.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });"
  },
  {
    "className": "CameraEventAggregator",
    "methodName": "destroy",
    "description": "Removes mouse listeners held by this object.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* handler = handler && handler.destroy();\n *\n *"
  },
  {
    "className": "Cesium3DTileContent",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* content = content && content.destroy();\n *\n *"
  },
  {
    "className": "Cesium3DTileFeature",
    "methodName": "Cesium3DTileFeature",
    "description": "A feature of a {@link Cesium3DTileset}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On mouse over, display all the properties for a feature in the console log.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.Cesium3DTileFeature) {\n *         const propertyIds = feature.getPropertyIds();\n *         const length = propertyIds.length;\n *         for (let i = 0; i < length; ++i) {\n *             const propertyId = propertyIds[i];\n *             console.log(`{propertyId}: ${feature.getProperty(propertyId)}`);\n *         }\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);"
  },
  {
    "className": "Cesium3DTileFeature",
    "methodName": "getProperty",
    "description": "Returns a copy of the value of the feature's property with the given name. This includes properties from this feature's",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Display all the properties for a feature in the console log.\n * const propertyIds = feature.getPropertyIds();\n * const length = propertyIds.length;\n * for (let i = 0; i < length; ++i) {\n *     const propertyId = propertyIds[i];\n *     console.log(`{propertyId}: ${feature.getProperty(propertyId)}`);\n * }"
  },
  {
    "className": "Cesium3DTileFeature",
    "methodName": "setProperty",
    "description": "Sets the value of the feature's property with the given name.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const height = feature.getProperty('Height'); // e.g., the height of a building\n *\n *"
  },
  {
    "className": "Cesium3DTilePointFeature",
    "methodName": "Cesium3DTilePointFeature",
    "description": "A point feature of a {@link Cesium3DTileset}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On mouse over, display all the properties for a feature in the console log.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.Cesium3DTilePointFeature) {\n *         const propertyIds = feature.getPropertyIds();\n *         const length = propertyIds.length;\n *         for (let i = 0; i < length; ++i) {\n *             const propertyId = propertyIds[i];\n *             console.log(`{propertyId}: ${feature.getProperty(propertyId)}`);\n *         }\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);"
  },
  {
    "className": "Cesium3DTilePointFeature",
    "methodName": "getProperty",
    "description": "Returns a copy of the value of the feature's property with the given name. This includes properties from this feature's",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Display all the properties for a feature in the console log.\n * const propertyIds = feature.getPropertyIds();\n * const length = propertyIds.length;\n * for (let i = 0; i < length; ++i) {\n *     const propertyId = propertyIds[i];\n *     console.log(`{propertyId} : ${feature.getProperty(propertyId)}`);\n * }"
  },
  {
    "className": "Cesium3DTilePointFeature",
    "methodName": "setProperty",
    "description": "Sets the value of the feature's property with the given name.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const height = feature.getProperty('Height'); // e.g., the height of a building\n *\n *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "Cesium3DTileStyle",
    "description": "A style that is applied to a {@link Cesium3DTileset}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.style = new Cesium.Cesium3DTileStyle({\n *     color : {\n *         conditions : [\n *             ['${Height} >= 100', 'color(\"purple\", 0.5)'],\n *             ['${Height} >= 50', 'color(\"red\")'],\n *             ['true', 'color(\"blue\")']\n *         ]\n *     },\n *     show : '${Height} > 0',\n *     meta : {\n *         description : '\"Building id ${id} has height ${Height}.\"'\n *     }\n * });\n *\n *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>show</code> property. Alternatively a boolean, string, or object defining a show style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     show : '(regExp(\"^Chest\").test(${County})) && (${YearBuilt} >= 1970)'\n   * });\n   * style.show.evaluate(feature); // returns true or false depending on the feature's properties\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>color</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     color : '(${Temperature} > 90) ? color(\"red\") : color(\"white\")'\n   * });\n   * style.color.evaluateColor(feature, result); // returns a Cesium.Color object\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointSize</code> property. Alternatively a string or object defining a point size style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     pointSize : '(${Temperature} > 90) ? 2.0 : 1.0'\n   * });\n   * style.pointSize.evaluate(feature); // returns a Number\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointOutlineColor</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override pointOutlineColor expression with a string\n   * style.pointOutlineColor = 'color(\"blue\")';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointOutlineWidth</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override pointOutlineWidth expression with a string\n   * style.pointOutlineWidth = '5';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelColor</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override labelColor expression with a string\n   * style.labelColor = 'color(\"blue\")';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelOutlineColor</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override labelOutlineColor expression with a string\n   * style.labelOutlineColor = 'color(\"blue\")';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelOutlineWidth</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override labelOutlineWidth expression with a string\n   * style.labelOutlineWidth = '5';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>font</code> property. Alternatively a string or object defining a string style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     font : '(${Temperature} > 90) ? \"30px Helvetica\" : \"24px Helvetica\"'\n   * });\n   * style.font.evaluate(feature); // returns a String\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>label style</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     labelStyle : `(\\${Temperature} > 90) ? ${LabelStyle.FILL_AND_OUTLINE} : ${LabelStyle.FILL}`\n   * });\n   * style.labelStyle.evaluate(feature); // returns a LabelStyle\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelText</code> property. Alternatively a string or object defining a string style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     labelText : '(${Temperature} > 90) ? \">90\" : \"<=90\"'\n   * });\n   * style.labelText.evaluate(feature); // returns a String\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundColor</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override backgroundColor expression with a string\n   * style.backgroundColor = 'color(\"blue\")';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundPadding</code> property. Alternatively a string or object defining a vec2 style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override backgroundPadding expression with a string\n   * style.backgroundPadding = 'vec2(5.0, 7.0)';\n   * style.backgroundPadding.evaluate(feature); // returns a Cartesian2"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundEnabled</code> property. Alternatively a string or object defining a boolean style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override backgroundEnabled expression with a string\n   * style.backgroundEnabled = 'true';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>scaleByDistance</code> property. Alternatively a string or object defining a vec4 style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override scaleByDistance expression with a string\n   * style.scaleByDistance = 'vec4(1.5e2, 2.0, 1.5e7, 0.5)';\n   * style.scaleByDistance.evaluate(feature); // returns a Cartesian4"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>translucencyByDistance</code> property. Alternatively a string or object defining a vec4 style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override translucencyByDistance expression with a string\n   * style.translucencyByDistance = 'vec4(1.5e2, 1.0, 1.5e7, 0.2)';\n   * style.translucencyByDistance.evaluate(feature); // returns a Cartesian4"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>distanceDisplayCondition</code> property. Alternatively a string or object defining a vec2 style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override distanceDisplayCondition expression with a string\n   * style.distanceDisplayCondition = 'vec2(0.0, 5.5e6)';\n   * style.distanceDisplayCondition.evaluate(feature); // returns a Cartesian2"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>heightOffset</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override heightOffset expression with a string\n   * style.heightOffset = '2.0';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>anchorLineEnabled</code> property. Alternatively a string or object defining a boolean style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override anchorLineEnabled expression with a string\n   * style.anchorLineEnabled = 'true';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>anchorLineColor</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override anchorLineColor expression with a string\n   * style.anchorLineColor = 'color(\"blue\")';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>image</code> property. Alternatively a string or object defining a string style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     image : '(${Temperature} > 90) ? \"/url/to/image1\" : \"/url/to/image2\"'\n   * });\n   * style.image.evaluate(feature); // returns a String\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>disableDepthTestDistance</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override disableDepthTestDistance expression with a string\n   * style.disableDepthTestDistance = '1000.0';\n   * style.disableDepthTestDistance.evaluate(feature); // returns a Number"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>horizontalOrigin</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     horizontalOrigin : HorizontalOrigin.LEFT\n   * });\n   * style.horizontalOrigin.evaluate(feature); // returns a HorizontalOrigin\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>verticalOrigin</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     verticalOrigin : VerticalOrigin.TOP\n   * });\n   * style.verticalOrigin.evaluate(feature); // returns a VerticalOrigin\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelHorizontalOrigin</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n    *     labelHorizontalOrigin : HorizontalOrigin.LEFT\n    * });\n    * style.labelHorizontalOrigin.evaluate(feature); // returns a HorizontalOrigin\n    *\n    *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelVerticalOrigin</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     labelVerticalOrigin : VerticalOrigin.TOP\n   * });\n   * style.labelVerticalOrigin.evaluate(feature); // returns a VerticalOrigin\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the object containing application-specific expression that can be explicitly",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     meta : {\n   *         description : '\"Building id ${id} has height ${Height}.\"'\n   *     }\n   * });\n   * style.meta.description.evaluate(feature); // returns a String with the substituted variables"
  },
  {
    "className": "Cesium3DTilesVoxelProvider",
    "methodName": "fromUrl",
    "description": "Creates a {@link Cesium3DTilesVoxelProvider} that fetches voxel data from a 3D Tiles tileset.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *   const voxelProvider = await Cesium3DTilesVoxelProvider.fromUrl(\n *     \"http://localhost:8002/tilesets/voxel/tileset.json\"\n *   );\n *   const voxelPrimitive = new VoxelPrimitive({\n *     provider: voxelProvider,\n *     customShader: customShader,\n *   });\n *   scene.primitives.add(voxelPrimitive);\n * } catch (error) {\n *   console.error(`Error creating voxel primitive: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "Cesium3DTileset",
    "description": "A {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles tileset},",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *   const tileset = await Cesium.Cesium3DTileset.fromUrl(\n *      \"http://localhost:8002/tilesets/Seattle/tileset.json\"\n *   );\n *   scene.primitives.add(tileset);\n * } catch (error) {\n *   console.error(`Error creating tileset: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "loadProgress",
    "description": "The event fired to indicate progress of loading new tiles.  This event is fired when a new tile",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.loadProgress.addEventListener(function(numberOfPendingRequests, numberOfTilesProcessing) {\n   *     if ((numberOfPendingRequests === 0) && (numberOfTilesProcessing === 0)) {\n   *         console.log('Stopped loading');\n   *         return;\n   *     }\n   *\n   *     console.log(`Loading: requests: ${numberOfPendingRequests}, processing: ${numberOfTilesProcessing}`);\n   * });"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "allTilesLoaded",
    "description": "The event fired to indicate that all tiles that meet the screen space error this frame are loaded. The tileset",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.allTilesLoaded.addEventListener(function() {\n   *     console.log('All tiles are loaded');\n   * });\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "initialTilesLoaded",
    "description": "The event fired to indicate that all tiles that meet the screen space error this frame are loaded. This event",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.initialTilesLoaded.addEventListener(function() {\n   *     console.log('Initial tiles are loaded');\n   * });\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "tileLoad",
    "description": "The event fired to indicate that a tile's content was loaded.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.tileLoad.addEventListener(function(tile) {\n   *     console.log('A tile was loaded.');\n   * });"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "tileUnload",
    "description": "The event fired to indicate that a tile's content was unloaded.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.tileUnload.addEventListener(function(tile) {\n   *     console.log('A tile was unloaded from the cache.');\n   * });\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "tileFailed",
    "description": "The event fired to indicate that a tile's content failed to load.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.tileFailed.addEventListener(function(error) {\n   *     console.log(`An error occurred loading tile: ${error.url}`);\n   *     console.log(`Error: ${error.message}`);\n   * });"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "tileVisible",
    "description": "This event fires once for each visible tile in a frame.  This can be used to manually",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.tileVisible.addEventListener(function(tile) {\n   *     if (tile.content instanceof Cesium.Model3DTileContent) {\n   *         console.log('A 3D model tile is visible.');\n   *     }\n   * });\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "The collection of <code>ImageryLayer</code> objects providing 2D georeferenced",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Drape Bing Maps Aerial imagery over the tileset\n   * const imageryProvider = await Cesium.createWorldImageryAsync({\n   *   style: Cesium.IonWorldImageryStyle.AERIAL,\n   * });\n   * const imageryLayer = new ImageryLayer(imageryProvider);\n   * tileset.imageryLayers.add(imageryLayer);"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* console.log(`Maximum building height: ${tileset.properties.height.maximum}`);\n   * console.log(`Minimum building height: ${tileset.properties.height.minimum}`);\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "The style, defined using the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.style = new Cesium.Cesium3DTileStyle({\n   *    color : {\n   *        conditions : [\n   *            ['${Height} >= 100', 'color(\"purple\", 0.5)'],\n   *            ['${Height} >= 50', 'color(\"red\")'],\n   *            ['true', 'color(\"blue\")']\n   *        ]\n   *    },\n   *    show : '${Height} > 0',\n   *    meta : {\n   *        description : '\"Building id ${id} has height ${Height}.\"'\n   *    }\n   * });\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "The tileset's bounding sphere.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const tileset = await Cesium.Cesium3DTileset.fromUrl(\"http://localhost:8002/tilesets/Seattle/tileset.json\");\n   *\n   * viewer.scene.primitives.add(tileset);\n   *\n   * // Set the camera to view the newly added tileset\n   * viewer.camera.viewBoundingSphere(tileset.boundingSphere, new Cesium.HeadingPitchRange(0, -0.5, 0));"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "A 4x4 transformation matrix that transforms the entire tileset.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Adjust a tileset's height from the globe's surface.\n   * const heightOffset = 20.0;\n   * const boundingSphere = tileset.boundingSphere;\n   * const cartographic = Cesium.Cartographic.fromCartesian(boundingSphere.center);\n   * const surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0);\n   * const offset = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, heightOffset);\n   * const translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3());\n   * tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation);"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "The properties for managing dynamic environment maps on this model. Affects lighting.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Change the ground color used for a tileset's environment map to a forest green\n   * const environmentMapManager = tileset.environmentMapManager;\n   * environmentMapManager.groundColor = Cesium.Color.fromCssColorString(\"#203b34\");\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "fromIonAssetId",
    "description": "Creates a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles tileset},",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Load a Cesium3DTileset with a Cesium ion asset ID of 124624234\n * try {\n *   const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(124624234);\n *   scene.primitives.add(tileset);\n * } catch (error) {\n *   console.error(`Error creating tileset: ${error}`);\n * }"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "fromUrl",
    "description": "Creates a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles tileset},",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *   const tileset = await Cesium.Cesium3DTileset.fromUrl(\n *      \"http://localhost:8002/tilesets/Seattle/tileset.json\"\n *   );\n *   scene.primitives.add(tileset);\n * } catch (error) {\n *   console.error(`Error creating tileset: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset = tileset && tileset.destroy();\n *\n *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "getHeight",
    "description": "Get the height of the loaded surface at a given cartographic. This function will only take into account meshes for loaded tiles, not neccisarily the most detailed tiles available for a tileset. This function will always return undefined when sampling a point cloud.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(124624234);\n * scene.primitives.add(tileset);\n *\n * const height = tileset.getHeight(scene.camera.positionCartographic, scene);"
  },
  {
    "className": "ClassificationPrimitive",
    "methodName": "getGeometryInstanceAttributes",
    "description": "Returns the modifiable per-instance attributes for a {@link GeometryInstance}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);"
  },
  {
    "className": "ClassificationPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "ClippingPlaneCollection",
    "methodName": "ClippingPlaneCollection",
    "description": "Specifies a set of clipping planes. Clipping planes selectively disable rendering in a region on the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // This clipping plane's distance is positive, which means its normal\n * // is facing the origin. This will clip everything that is behind\n * // the plane, which is anything with y coordinate < -5.\n * const clippingPlanes = new Cesium.ClippingPlaneCollection({\n *     planes : [\n *         new Cesium.ClippingPlane(new Cesium.Cartesian3(0.0, 1.0, 0.0), 5.0)\n *     ],\n * });\n * // Create an entity and attach the ClippingPlaneCollection to the model.\n * const entity = viewer.entities.add({\n *     position : Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, 10000),\n *     model : {\n *         uri : 'model.gltf',\n *         minimumPixelSize : 128,\n *         maximumScale : 20000,\n *         clippingPlanes : clippingPlanes\n *     }\n * });\n * viewer.zoomTo(entity);"
  },
  {
    "className": "ClippingPlaneCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* clippingPlanes = clippingPlanes && clippingPlanes.destroy();\n *\n *"
  },
  {
    "className": "ClippingPolygon",
    "methodName": "ClippingPolygon",
    "description": "A geodesic polygon to be used with {@link ClippingPlaneCollection} for selectively hiding regions in a model, a 3D tileset, or the globe.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * const polygon = new Cesium.ClippingPolygon({\n *     positions: positions\n * });"
  },
  {
    "className": "ClippingPolygonCollection",
    "methodName": "ClippingPolygonCollection",
    "description": "Specifies a set of clipping polygons. Clipping polygons selectively disable rendering in a region",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * const polygon = new Cesium.ClippingPolygon({\n *     positions: positions\n * });\n *\n * const polygons = new Cesium.ClippingPolygonCollection({\n *    polygons: [ polygon ]\n * });"
  },
  {
    "className": "ClippingPolygonCollection",
    "methodName": "add",
    "description": "Adds the specified {@link ClippingPolygon} to the collection to be used to selectively disable rendering",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const polygons = new Cesium.ClippingPolygonCollection();\n *\n * const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * polygons.add(new Cesium.ClippingPolygon({\n *     positions: positions\n * }));\n *\n *\n *\n *"
  },
  {
    "className": "ClippingPolygonCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* clippingPolygons = clippingPolygons && clippingPolygons.destroy();\n *\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "CloudCollection",
    "description": "A renderable collection of clouds in the 3D scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a cloud collection with two cumulus clouds\n * const clouds = scene.primitives.add(new Cesium.CloudCollection());\n * clouds.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   maximumSize: new Cesium.Cartesian3(20.0, 12.0, 8.0)\n * });\n * clouds.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   maximumSize: new Cesium.Cartesian3(15.0, 9.0, 9.0),\n *   slice: 0.5\n * });\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "add",
    "description": "Creates and adds a cloud with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1:  Add a cumulus cloud, specifying all the default values.\n * const c = clouds.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   scale : new Cesium.Cartesian2(20.0, 12.0),\n *   maximumSize: new Cesium.Cartesian3(20.0, 12.0, 12.0),\n *   slice: -1.0,\n *   cloudType : CloudType.CUMULUS\n * });\n *\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "remove",
    "description": "Removes a cloud from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const c = clouds.add(...);\n * clouds.remove(c);  // Returns true\n *\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "removeAll",
    "description": "Removes all clouds from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* clouds.add(...);\n * clouds.add(...);\n * clouds.removeAll();\n *\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "get",
    "description": "Returns the cloud in the collection at the specified index. Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every cloud in the collection\n * const len = clouds.length;\n * for (let i = 0; i < len; ++i) {\n *   const c = clouds.get(i);\n *   c.show = !c.show;\n * }\n *\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* clouds = clouds && clouds.destroy();\n *\n *"
  },
  {
    "className": "CloudType",
    "methodName": "validate",
    "description": "Validates that the provided cloud type is a valid {@link CloudType}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* if (!Cesium.CloudType.validate(cloudType)) {\n *   throw new Cesium.DeveloperError('cloudType must be a valid value.');\n * }"
  },
  {
    "className": "ConditionsExpression",
    "methodName": "ConditionsExpression",
    "description": "An expression for a style applied to a {@link Cesium3DTileset}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const expression = new Cesium.ConditionsExpression({\n *     conditions : [\n *         ['${Area} > 10, 'color(\"#FF0000\")'],\n *         ['${id} !== \"1\"', 'color(\"#00FF00\")'],\n *         ['true', 'color(\"#FFFFFF\")']\n *     ]\n * });\n * expression.evaluateColor(feature, result); // returns a Cesium.Color object"
  },
  {
    "className": "CreditDisplay",
    "methodName": "CreditDisplay",
    "description": "The credit display is responsible for displaying credits on screen.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Add a credit with a tooltip, image and link to display onscreen\n * const credit = new Cesium.Credit(`<a href=\"https://cesium.com/\" target=\"_blank\"><img src=\"/images/cesium_logo.png\" title=\"Cesium\"/></a>`, true);\n * viewer.creditDisplay.addStaticCredit(credit);\n *\n *"
  },
  {
    "className": "CreditDisplay",
    "methodName": "addStaticCredit",
    "description": "Adds a {@link Credit} that will show on screen or in the lightbox until removed with {@link CreditDisplay.removeStaticCredit}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Add a credit with a tooltip, image and link to display onscreen\n * const credit = new Cesium.Credit(`<a href=\"https://cesium.com/\" target=\"_blank\"><img src=\"/images/cesium_logo.png\" title=\"Cesium\"/></a>`, true);\n * viewer.creditDisplay.addStaticCredit(credit);\n *\n *"
  },
  {
    "className": "DebugAppearance",
    "methodName": "DebugAppearance",
    "description": "Visualizes a vertex attribute by displaying it as a color for debugging.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const primitive = new Cesium.Primitive({\n *   geometryInstances : // ...\n *   appearance : new Cesium.DebugAppearance({\n *     attributeName : 'normal'\n *   })\n * });"
  },
  {
    "className": "DebugCameraPrimitive",
    "methodName": "DebugCameraPrimitive",
    "description": "Draws the outline of the camera's view frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* primitives.add(new Cesium.DebugCameraPrimitive({\n *   camera : camera,\n *   color : Cesium.Color.YELLOW\n * }));"
  },
  {
    "className": "DebugCameraPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* p = p && p.destroy();\n *\n *"
  },
  {
    "className": "DebugModelMatrixPrimitive",
    "methodName": "DebugModelMatrixPrimitive",
    "description": "Draws the axes of a reference frame defined by a matrix that transforms to world",
    "parameters": [],
    "returnType": "unknown",
    "example": "* primitives.add(new Cesium.DebugModelMatrixPrimitive({\n *   modelMatrix : primitive.modelMatrix,  // primitive to debug\n *   length : 100000.0,\n *   width : 10.0\n * }));"
  },
  {
    "className": "DebugModelMatrixPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* p = p && p.destroy();\n *\n *"
  },
  {
    "className": "DynamicEnvironmentMapManager",
    "methodName": "DynamicEnvironmentMapManager",
    "description": "Generates an environment map at the given position based on scene's current lighting conditions. From this, it produces multiple levels of specular maps and spherical harmonic coefficients than can be used with {@link ImageBasedLighting} for models or tilesets.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Enable time-of-day environment mapping in a scene\n * scene.atmosphere.dynamicLighting = Cesium.DynamicAtmosphereLightingType.SUNLIGHT;\n *\n * // Decrease the directional lighting contribution\n * scene.light.intensity = 0.5\n *\n * // Increase the intensity of of the environment map lighting contribution\n * const environmentMapManager = tileset.environmentMapManager;\n * environmentMapManager.atmosphereScatteringIntensity = 3.0;\n *\n *"
  },
  {
    "className": "DynamicEnvironmentMapManager",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* mapManager = mapManager && mapManager.destroy();\n *"
  },
  {
    "className": "EllipsoidPrimitive",
    "methodName": "radii",
    "description": "The radius of the ellipsoid along the <code>x</code>, <code>y</code>, and <code>z</code> axes in the ellipsoid's model coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // A sphere with a radius of 2.0\n   * e.radii = new Cesium.Cartesian3(2.0, 2.0, 2.0);\n   *\n   *"
  },
  {
    "className": "EllipsoidPrimitive",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms the ellipsoid from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * e.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);"
  },
  {
    "className": "EllipsoidPrimitive",
    "methodName": "material",
    "description": "The surface appearance of the ellipsoid.  This can be one of several built-in {@link Material} objects or a custom material, scripted with",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Change the color of the default material to yellow\n   * e.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);\n   *\n   * // 2. Change material to horizontal stripes\n   * e.material = Cesium.Material.fromType(Cesium.Material.StripeType);\n   *\n   *"
  },
  {
    "className": "EllipsoidPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "EllipsoidSurfaceAppearance",
    "methodName": "EllipsoidSurfaceAppearance",
    "description": "An appearance for geometry on the surface of the ellipsoid like {@link PolygonGeometry}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.PolygonGeometry({\n *       vertexFormat : Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT,\n *       // ...\n *     })\n *   }),\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Stripe')\n *   })\n * });"
  },
  {
    "className": "Expression",
    "methodName": "Expression",
    "description": "An expression for a style applied to a {@link Cesium3DTileset}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const expression = new Cesium.Expression('(regExp(\"^Chest\").test(${County})) && (${YearBuilt} >= 1970)');\n * expression.evaluate(feature); // returns true or false depending on the feature's properties\n *\n *"
  },
  {
    "className": "Fog",
    "methodName": "enabled",
    "description": "<code>true</code> if fog is enabled, <code>false</code> otherwise.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Disable fog in the scene\n   * viewer.scene.fog.enabled = false;"
  },
  {
    "className": "Fog",
    "methodName": "renderable",
    "description": "<code>true</code> if fog is renderable in shaders, <code>false</code> otherwise.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use fog culling but don't render it\n   * viewer.scene.fog.enabled = true;\n   * viewer.scene.fog.renderable = false;"
  },
  {
    "className": "Fog",
    "methodName": "density",
    "description": "A scalar that determines the density of the fog. Terrain that is in full fog are culled.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Double the default fog density\n   * viewer.scene.fog.density = 0.0012;"
  },
  {
    "className": "Fog",
    "methodName": "visualDensityScalar",
    "description": "A scalar that impacts the visual density of fog. This value does not impact the culling of terrain.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Increase fog appearance effect\n   * viewer.scene.fog.visualDensityScalar = 0.6;"
  },
  {
    "className": "FrameState",
    "methodName": "afterRender",
    "description": "An array of functions to be called at the end of the frame.  This array",
    "parameters": [],
    "returnType": "unknown",
    "example": "* frameState.afterRender.push(function() {\n   *   // take some action, raise an event, etc.\n   * });"
  },
  {
    "className": "Globe",
    "methodName": "pick",
    "description": "Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // find intersection of ray through a pixel and the globe\n * const ray = viewer.camera.getPickRay(windowCoordinates);\n * const intersection = globe.pick(ray, scene);"
  },
  {
    "className": "Globe",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* globe = globe && globe.destroy();\n *\n *"
  },
  {
    "className": "GlobeSurfaceTileProvider",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* provider = provider && provider();\n *\n *"
  },
  {
    "className": "GlobeTranslucency",
    "methodName": "function",
    "description": "A constant translucency to apply to front faces of the globe.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set front face translucency to 0.5.\n   * globe.translucency.frontFaceAlpha = 0.5;\n   * globe.translucency.enabled = true;"
  },
  {
    "className": "GlobeTranslucency",
    "methodName": "function",
    "description": "Gets or sets near and far translucency properties of front faces of the globe based on the distance to the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set front face translucency to 0.5 when the\n   * // camera is 1500 meters from the surface and 1.0\n   * // as the camera distance approaches 8.0e6 meters.\n   * globe.translucency.frontFaceAlphaByDistance = new Cesium.NearFarScalar(1.5e2, 0.5, 8.0e6, 1.0);\n   * globe.translucency.enabled = true;\n   *\n   *"
  },
  {
    "className": "GlobeTranslucency",
    "methodName": "function",
    "description": "A constant translucency to apply to back faces of the globe.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set back face translucency to 0.5.\n   * globe.translucency.backFaceAlpha = 0.5;\n   * globe.translucency.enabled = true;"
  },
  {
    "className": "GlobeTranslucency",
    "methodName": "function",
    "description": "Gets or sets near and far translucency properties of back faces of the globe based on the distance to the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set back face translucency to 0.5 when the\n   * // camera is 1500 meters from the surface and 1.0\n   * // as the camera distance approaches 8.0e6 meters.\n   * globe.translucency.backFaceAlphaByDistance = new Cesium.NearFarScalar(1.5e2, 0.5, 8.0e6, 1.0);\n   * globe.translucency.enabled = true;\n   *\n   *"
  },
  {
    "className": "Google2DImageryProvider",
    "methodName": "Google2DImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Google 2D imagery provider\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromIonAssetId({\n *     assetId: 3830184\n * });\n  *"
  },
  {
    "className": "Google2DImageryProvider",
    "methodName": "fromIonAssetId",
    "description": "Creates an {@link ImageryProvider} which provides 2D global tiled imagery from {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview|Google 2D Tiles}, streamed using the Cesium ion REST API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Google 2D imagery provider\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromIonAssetId({\n *     assetId: 3830184\n * });\n *"
  },
  {
    "className": "Google2DImageryProvider",
    "methodName": "fromUrl",
    "description": "Creates an {@link ImageryProvider} which provides 2D global tiled imagery from {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview|Google 2D Tiles}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use your own Google api key\n * Cesium.GoogleMaps.defaultApiKey = \"your-api-key\";\n *\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromUrl({\n *     mapType: \"satellite\"\n * });\n *"
  },
  {
    "className": "GoogleEarthEnterpriseImageryProvider",
    "methodName": "GoogleEarthEnterpriseImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseImageryProvider.fromMetadata(geeMetadata);\n *\n *"
  },
  {
    "className": "GoogleEarthEnterpriseImageryProvider",
    "methodName": "fromMetadata",
    "description": "Creates a tiled imagery provider using the Google Earth Enterprise REST API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseImageryProvider.fromMetadata(geeMetadata);"
  },
  {
    "className": "GoogleEarthEnterpriseMapsProvider",
    "methodName": "GoogleEarthEnterpriseMapsProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const google = await Cesium.GoogleEarthEnterpriseMapsProvider.fromUrl(\"https://earth.localdomain\", 1008);\n *\n *"
  },
  {
    "className": "GoogleEarthEnterpriseMapsProvider",
    "methodName": "fromUrl",
    "description": "Creates a tiled imagery provider using the Google Earth Imagery API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const google = await Cesium.GoogleEarthEnterpriseMapsProvider.fromUrl(\"https://earth.localdomain\", 1008);"
  },
  {
    "className": "GroundPolylinePrimitive",
    "methodName": "GroundPolylinePrimitive",
    "description": "A GroundPolylinePrimitive represents a polyline draped over the terrain or 3D Tiles in the {@link Scene}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Draw a polyline on terrain with a basic color material\n *\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715\n *      ]),\n *      width : 4.0\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.PolylineMaterialAppearance()\n * }));\n *\n * // 2. Draw a looped polyline on terrain with per-instance color and a distance display condition.\n * // Distance display conditions for polylines on terrain are based on an approximate terrain height\n * // instead of true terrain height.\n *\n * const instance2 = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715,\n *          -112.13296079730024, 36.168769146801104\n *      ]),\n *      loop : true,\n *      width : 4.0\n *   }),\n *   attributes : {\n *      color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('green').withAlpha(0.7)),\n *      distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(1000, 30000)\n *   },\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance2,\n *   appearance : new Cesium.PolylineColorAppearance()\n * }));"
  },
  {
    "className": "GroundPolylinePrimitive",
    "methodName": "getGeometryInstanceAttributes",
    "description": "Returns the modifiable per-instance attributes for a {@link GeometryInstance}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);"
  },
  {
    "className": "GroundPolylinePrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "GroundPrimitive",
    "methodName": "GroundPrimitive",
    "description": "A ground primitive represents geometry draped over terrain or 3D Tiles in the {@link Scene}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1: Create primitive with a single instance\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : rectangleInstance\n * }));\n *\n * // Example 2: Batch instances\n * const color = new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5); // Both instances must have the same color.\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : color\n *   }\n * });\n * const ellipseInstance = new Cesium.GeometryInstance({\n *     geometry : new Cesium.EllipseGeometry({\n *         center : Cesium.Cartesian3.fromDegrees(-105.0, 40.0),\n *         semiMinorAxis : 300000.0,\n *         semiMajorAxis : 400000.0\n *     }),\n *     id : 'ellipse',\n *     attributes : {\n *         color : color\n *     }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : [rectangleInstance, ellipseInstance]\n * }));\n *\n *"
  },
  {
    "className": "GroundPrimitive",
    "methodName": "getGeometryInstanceAttributes",
    "description": "Returns the modifiable per-instance attributes for a {@link GeometryInstance}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);"
  },
  {
    "className": "GroundPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "I3SDataProvider",
    "methodName": "8",
    "description": "@typedef {object} I3SDataProvider.ConstructorOptions",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Increase LOD by reducing SSE\n * const cesium3dTilesetOptions = {\n *   maximumScreenSpaceError: 1,\n * };\n * const i3sOptions = {\n *   cesium3dTilesetOptions: cesium3dTilesetOptions,\n * };\n *\n *"
  },
  {
    "className": "I3SDataProvider",
    "methodName": "I3SDataProvider",
    "description": "An I3SDataProvider is the main public class for I3S support. The url option",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\"\n *   );\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "I3SDataProvider",
    "methodName": "fromUrl",
    "description": "Creates an I3SDataProvider. Currently supported I3S versions are 1.6 and",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\"\n *   );\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "ITwinData",
    "methodName": "createTilesetFromIModelId",
    "description": "Create a {@link Cesium3DTileset} for the given iModel id using iTwin's Mesh Export API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const tileset = await Cesium.ITwinData.createTilesetFromIModelId({ iModelId });\n * if (Cesium.defined(tileset)) {\n *   viewer.scene.primitives.add(tileset);\n * }\n *\n *"
  },
  {
    "className": "ImageBasedLighting",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* imageBasedLighting = imageBasedLighting && imageBasedLighting.destroy();\n *\n *"
  },
  {
    "className": "ImageryLayer",
    "methodName": "ImageryLayer",
    "description": "An imagery layer that displays tiled image data from a single imagery provider",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Add an OpenStreetMaps layer\n * const imageryLayer = new Cesium.ImageryLayer(new Cesium.OpenStreetMapImageryProvider({\n *   url: \"https://tile.openstreetmap.org/\"\n * }));\n * scene.imageryLayers.add(imageryLayer);\n *\n *"
  },
  {
    "className": "ImageryLayer",
    "methodName": "fromProviderAsync",
    "description": "Create a new imagery layer from an asynchronous imagery provider. The layer will handle any asynchronous loads or errors, and begin rendering the imagery layer once ready.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a new base layer\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * });\n *\n *"
  },
  {
    "className": "ImageryLayer",
    "methodName": "fromWorldImagery",
    "description": "Create a new imagery layer for ion's default global base imagery layer, currently Bing Maps. The layer will handle any asynchronous loads or errors, and begin rendering the imagery layer once ready.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a new base layer\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromWorldImagery();\n * });\n *\n *"
  },
  {
    "className": "ImageryLayer",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* imageryLayer = imageryLayer && imageryLayer.destroy();\n *\n *"
  },
  {
    "className": "ImageryLayer",
    "methodName": "getImageryRectangle",
    "description": "Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Zoom to an imagery layer.\n * const imageryRectangle = imageryLayer.getImageryRectangle();\n * scene.camera.flyTo({\n *     destination: rectangle\n * });\n *"
  },
  {
    "className": "ImageryLayerCollection",
    "methodName": "add",
    "description": "Adds a layer to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();\n * scene.imageryLayers.add(imageryLayer);\n *\n *"
  },
  {
    "className": "ImageryLayerCollection",
    "methodName": "addImageryProvider",
    "description": "Creates a new layer using the given ImageryProvider and adds it to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *    const provider = await Cesium.IonImageryProvider.fromAssetId(3812);\n *    scene.imageryLayers.addImageryProvider(provider);\n * } catch (error) {\n *   console.log(`There was an error creating the imagery layer. ${error}`)\n * }"
  },
  {
    "className": "ImageryLayerCollection",
    "methodName": "pickImageryLayerFeatures",
    "description": "Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const pickRay = viewer.camera.getPickRay(windowPosition);\n * const featuresPromise = viewer.imageryLayers.pickImageryLayerFeatures(pickRay, viewer.scene);\n * if (!Cesium.defined(featuresPromise)) {\n *     console.log('No features picked.');\n * } else {\n *     Promise.resolve(featuresPromise).then(function(features) {\n *         // This function is called asynchronously when the list if picked features is available.\n *         console.log(`Number of features: ${features.length}`);\n *         if (features.length > 0) {\n *             console.log(`First feature name: ${features[0].name}`);\n *         }\n *     });\n * }"
  },
  {
    "className": "ImageryLayerCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this",
    "parameters": [],
    "returnType": "unknown",
    "example": "* layerCollection = layerCollection && layerCollection.destroy();\n *\n *"
  },
  {
    "className": "IonImageryProvider",
    "methodName": "IonImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * viewer.imageryLayers.add(imageryLayer);\n *\n *"
  },
  {
    "className": "IonImageryProvider",
    "methodName": "fromAssetId",
    "description": "Creates a provider for tiled imagery using the Cesium ion REST API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * viewer.imageryLayers.add(imageryLayer);\n *\n *"
  },
  {
    "className": "Label",
    "methodName": "function",
    "description": "Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a label's translucencyByDistance to 1.0 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "Label",
    "methodName": "function",
    "description": "Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a label's pixel offset scale to 0.0 when the\n   * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels\n   * // in the y direction the camera distance approaches 8.0e6 meters.\n   * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);\n   * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);\n   *\n   *"
  },
  {
    "className": "Label",
    "methodName": "function",
    "description": "Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a label's scaleByDistance to scale by 1.5 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "Label",
    "methodName": "function",
    "description": "Gets or sets the horizontal origin of this label, which determines if the label is drawn",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;"
  },
  {
    "className": "Label",
    "methodName": "function",
    "description": "Gets or sets the vertical origin of this label, which determines if the label is",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;"
  },
  {
    "className": "Label",
    "methodName": "computeScreenSpacePosition",
    "description": "Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* console.log(l.computeScreenSpacePosition(scene).toString());\n *\n *"
  },
  {
    "className": "Label",
    "methodName": "enableRightToLeftDetection",
    "description": "Determines whether or not run the algorithm, that match the text of the label to right-to-left languages",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n * // Set a label's rightToLeft before init\n * Cesium.Label.enableRightToLeftDetection = true;\n * const myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: '   \\n   ',\n *   }\n * });\n *\n *"
  },
  {
    "className": "LabelCollection",
    "methodName": "LabelCollection",
    "description": "A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a label collection with two labels\n * const labels = scene.primitives.add(new Cesium.LabelCollection());\n * labels.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   text : 'A label'\n * });\n * labels.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   text : 'Another label'\n * });"
  },
  {
    "className": "LabelCollection",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),\n   *   text     : 'Center'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),\n   *   text     : 'East'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),\n   *   text     : 'North'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),\n   *   text     : 'Up'\n   * });"
  },
  {
    "className": "LabelCollection",
    "methodName": "add",
    "description": "Creates and adds a label with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1:  Add a label, specifying all the default values.\n * const l = labels.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   text : '',\n *   font : '30px sans-serif',\n *   fillColor : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.BLACK,\n *   outlineWidth : 1.0,\n *   showBackground : false,\n *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),\n *   backgroundPadding : new Cesium.Cartesian2(7, 5),\n *   style : Cesium.LabelStyle.FILL,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,\n *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,\n *   scale : 1.0,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   heightReference : HeightReference.NONE,\n *   distanceDisplayCondition : undefined\n * });\n *\n *"
  },
  {
    "className": "LabelCollection",
    "methodName": "remove",
    "description": "Removes a label from the collection.  Once removed, a label is no longer usable.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const l = labels.add(...);\n * labels.remove(l);  // Returns true\n *\n *"
  },
  {
    "className": "LabelCollection",
    "methodName": "removeAll",
    "description": "Removes all labels from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* labels.add(...);\n * labels.add(...);\n * labels.removeAll();\n *\n *"
  },
  {
    "className": "LabelCollection",
    "methodName": "get",
    "description": "Returns the label in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every label in the collection\n * const len = labels.length;\n * for (let i = 0; i < len; ++i) {\n *   const l = billboards.get(i);\n *   l.show = !l.show;\n * }\n *\n *"
  },
  {
    "className": "LabelCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* labels = labels && labels.destroy();\n *\n *"
  },
  {
    "className": "MapboxImageryProvider",
    "methodName": "MapboxImageryProvider",
    "description": "Provides tiled imagery hosted by Mapbox.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Mapbox tile provider\n * const mapbox = new Cesium.MapboxImageryProvider({\n *     mapId: 'mapbox.mapbox-terrain-v2',\n *     accessToken: 'thisIsMyAccessToken'\n * });\n *\n *"
  },
  {
    "className": "MapboxStyleImageryProvider",
    "methodName": "MapboxStyleImageryProvider",
    "description": "Provides tiled imagery hosted by Mapbox.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Mapbox style provider\n * const mapbox = new Cesium.MapboxStyleImageryProvider({\n *     styleId: 'streets-v11',\n *     accessToken: 'thisIsMyAccessToken'\n * });\n *\n *"
  },
  {
    "className": "Material",
    "methodName": "Material",
    "description": "A Material defines surface appearance through a combination of diffuse, specular,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a color material with fromType:\n * polygon.material = Cesium.Material.fromType('Color');\n * polygon.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);\n *\n * // Create the default material:\n * polygon.material = new Cesium.Material();\n *\n * // Create a color material with full Fabric notation:\n * polygon.material = new Cesium.Material({\n *   fabric: {\n *     type: 'Color',\n *     uniforms: {\n *       color: new Cesium.Color(1.0, 1.0, 0.0, 1.0)\n *     }\n *   }\n * });"
  },
  {
    "className": "Material",
    "methodName": "fromType",
    "description": "Creates a new material using an existing material type.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const material = Cesium.Material.fromType('Color', {\n *   color: new Cesium.Color(1.0, 0.0, 0.0, 1.0)\n * });"
  },
  {
    "className": "Material",
    "methodName": "fromTypeAsync",
    "description": "Creates a new material using an existing material type and returns a promise that resolves when",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const material = await Cesium.Material.fromTypeAsync('Image', {\n *    image: '../Images/Cesium_Logo_overlay.png'\n * });"
  },
  {
    "className": "Material",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* material = material && material.destroy();\n *\n *"
  },
  {
    "className": "MaterialAppearance",
    "methodName": "MaterialAppearance",
    "description": "An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const primitive = new Cesium.Primitive({\n     *   geometryInstances : new Cesium.GeometryInstance({\n     *     geometry : new Cesium.WallGeometry({\n            materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,\n     *       // ...\n     *     })\n     *   }),\n     *   appearance : new Cesium.MaterialAppearance({\n     *     material : Cesium.Material.fromType('Color'),\n     *     faceForward : true\n     *   })\n     *\n     * });"
  },
  {
    "className": "Megatexture",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* megatexture = megatexture && megatexture.destroy();"
  },
  {
    "className": "CustomShader",
    "methodName": "CustomShader",
    "description": "A user defined GLSL shader used with {@link Model} as well",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const customShader = new CustomShader({\n *   uniforms: {\n *     u_colorIndex: {\n *       type: Cesium.UniformType.FLOAT,\n *       value: 1.0\n *     },\n *     u_normalMap: {\n *       type: Cesium.UniformType.SAMPLER_2D,\n *       value: new Cesium.TextureUniform({\n *         url: \"http://example.com/normal.png\"\n *       })\n *     }\n *   },\n *   varyings: {\n *     v_selectedColor: Cesium.VaryingType.VEC3\n *   },\n *   vertexShaderText: `\n *   void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {\n *     v_selectedColor = mix(vsInput.attributes.color_0, vsInput.attributes.color_1, u_colorIndex);\n *     vsOutput.positionMC += 0.1 * vsInput.attributes.normal;\n *   }\n *   `,\n *   fragmentShaderText: `\n *   void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {\n *     material.normal = texture(u_normalMap, fsInput.attributes.texCoord_0);\n *     material.diffuse = v_selectedColor;\n *   }\n *   `\n * });"
  },
  {
    "className": "CustomShader",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* customShader = customShader && customShader.destroy();\n *\n *"
  },
  {
    "className": "Model",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms the model from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);"
  },
  {
    "className": "Model",
    "methodName": "function",
    "description": "If <code>true</code>, the model is exaggerated along the ellipsoid normal when {@link Scene.verticalExaggeration} is set to a value other than <code>1.0</code>.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Exaggerate terrain by a factor of 2, but prevent model exaggeration\n   * scene.verticalExaggeration = 2.0;\n   * model.enableVerticalExaggeration = false;"
  },
  {
    "className": "Model",
    "methodName": "function",
    "description": "The properties for managing dynamic environment maps on this model. Affects lighting.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Change the ground color used for a model's environment map to a forest green\n   * const environmentMapManager = model.environmentMapManager;\n   * environmentMapManager.groundColor = Cesium.Color.fromCssColorString(\"#203b34\");\n   *\n   *"
  },
  {
    "className": "Model",
    "methodName": "getNode",
    "description": "Returns the node with the given <code>name</code> in the glTF. This is used to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Apply non-uniform scale to node \"Hand\"\n * const node = model.getNode(\"Hand\");\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);"
  },
  {
    "className": "Model",
    "methodName": "setArticulationStage",
    "description": "Sets the current value of an articulation stage.  After setting one or",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Sets the value of the stage named \"MoveX\" belonging to the articulation named \"SampleArticulation\"\n * model.setArticulationStage(\"SampleArticulation MoveX\", 50.0);"
  },
  {
    "className": "Model",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* model = model && model.destroy();\n *\n *"
  },
  {
    "className": "Model",
    "methodName": "fromGltfAsync",
    "description": "<p>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Load a model and add it to the scene\n * try {\n *  const model = await Cesium.Model.fromGltfAsync({\n *    url: \"../../SampleData/models/CesiumMan/Cesium_Man.glb\"\n *  });\n *  viewer.scene.primitives.add(model);\n * } catch (error) {\n *  console.log(`Failed to load model. ${error}`);\n * }\n *\n *"
  },
  {
    "className": "ModelAnimation",
    "methodName": "start",
    "description": "The event fired when this animation is started.  This can be used, for",
    "parameters": [],
    "returnType": "unknown",
    "example": "* animation.start.addEventListener(function(model, animation) {\n   *   console.log(`Animation started: ${animation.name}`);\n   * });"
  },
  {
    "className": "ModelAnimation",
    "methodName": "update",
    "description": "The event fired when on each frame when this animation is updated.  The",
    "parameters": [],
    "returnType": "unknown",
    "example": "* animation.update.addEventListener(function(model, animation, time) {\n   *   console.log(`Animation updated: ${animation.name}. glTF animation time: ${time}`);\n   * });"
  },
  {
    "className": "ModelAnimation",
    "methodName": "stop",
    "description": "The event fired when this animation is stopped.  This can be used, for",
    "parameters": [],
    "returnType": "unknown",
    "example": "* animation.stop.addEventListener(function(model, animation) {\n   *   console.log(`Animation stopped: ${animation.name}`);\n   * });"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "animationAdded",
    "description": "The event fired when an animation is added to the collection.  This can be used, for",
    "parameters": [],
    "returnType": "unknown",
    "example": "* model.activeAnimations.animationAdded.addEventListener(function(model, animation) {\n   *   console.log(`Animation added: ${animation.name}`);\n   * });"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "animationRemoved",
    "description": "The event fired when an animation is removed from the collection.  This can be used, for",
    "parameters": [],
    "returnType": "unknown",
    "example": "* model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {\n   *   console.log(`Animation removed: ${animation.name}`);\n   * });"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "add",
    "description": "Creates and adds an animation with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Add an animation by name\n * model.activeAnimations.add({\n *   name : 'animation name'\n * });\n *\n *"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "addAll",
    "description": "Creates and adds animations with the specified initial properties to the collection",
    "parameters": [],
    "returnType": "unknown",
    "example": "* model.activeAnimations.addAll({\n *   multiplier : 0.5,                            // Play at half-speed\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations\n * });"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "remove",
    "description": "Removes an animation from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const a = model.activeAnimations.add({\n *   name : 'animation name'\n * });\n * model.activeAnimations.remove(a); // Returns true"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "get",
    "description": "Returns the animation in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Output the names of all the animations in the collection.\n * const animations = model.activeAnimations;\n * const length = animations.length;\n * for (let i = 0; i < length; ++i) {\n *   console.log(animations.get(i).name);\n * }"
  },
  {
    "className": "ModelFeature",
    "methodName": "ModelFeature",
    "description": "A feature of a {@link Model}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On mouse over, display all the properties for a feature in the console log.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.ModelFeature) {\n *         console.log(feature);\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *"
  },
  {
    "className": "ModelFeature",
    "methodName": "getProperty",
    "description": "Returns a copy of the value of the feature's property with the given name.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Display all the properties for a feature in the console log.\n * const propertyIds = feature.getPropertyIds();\n * const length = propertyIds.length;\n * for (let i = 0; i < length; ++i) {\n *     const propertyId = propertyIds[i];\n *     console.log(propertyId + ': ' + feature.getProperty(propertyId));\n * }"
  },
  {
    "className": "ModelFeature",
    "methodName": "setProperty",
    "description": "Sets the value of the feature's property with the given name.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const height = feature.getProperty('Height'); // e.g., the height of a building\n *\n *"
  },
  {
    "className": "ModelFeatureTable",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "ModelNode",
    "methodName": "ModelNode",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const node = model.getNode(\"Hand\");\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n *\n *"
  },
  {
    "className": "ModelRuntimeNode",
    "methodName": "getChild",
    "description": "Returns the child with the given index.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Iterate through all children of a runtime node.\n * for (let i = 0; i < runtimeNode.children.length; i++)\n * {\n *   const childNode = runtimeNode.getChild(i);\n * }\n *\n *"
  },
  {
    "className": "ModelUtility",
    "methodName": "sanitizeGlslIdentifier",
    "description": "Sanitize the identifier to be used in a GLSL shader. The identifier",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns \"customProperty\"\n * ModelUtility.sanitizeGlslIdentifier(\"gl_customProperty\");\n *\n *"
  },
  {
    "className": "PrimitiveOutlineGenerator",
    "methodName": "PrimitiveOutlineGenerator",
    "description": "A class to handle the low-level details of processing indices and vertex",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // The constructor will compute the updated indices and generate outline\n * // coordinates.\n * const outlineGenerator = new PrimitiveOutlineGenerator({\n *   triangleIndices: primitive.indices.typedArray,\n *   outlineIndices: outlineIndices,\n *   originalVertexCount: primitive.attributes[0].count\n * });\n *\n * // Caller must update the indices (the data type may have been upgraded!)\n * primitive.indices.typedArray = outlineGenerator.updatedTriangleIndices;\n * primitive.indices.indexDatatype =\n *  IndexDatatype.fromTypedArray(primitive.indices.typedArray);\n *\n * // Create a new attribute for the generated outline coordinates\n * primitive.outlineCoordinates = new ModelComponents.Attribute();\n * // ... initialize as a vec3 attribute\n * primitive.outlineCoordinates.typedArray =\n *   outlineGenerator.outlineCoordinates;\n *\n * // Updating an attribute\n * const attribute = primitive.attributes[i];\n * attribute.typedArray = outlineGenerator.updateAttribute(\n *   attribute.typedArray\n * );\n *\n *"
  },
  {
    "className": "TextureManager",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* textureManager = textureManager && textureManager.destroy();\n *\n *"
  },
  {
    "className": "Moon",
    "methodName": "Moon",
    "description": "Draws the Moon in 3D.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.moon = new Cesium.Moon();\n *\n *"
  },
  {
    "className": "Moon",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* moon = moon && moon.destroy();\n *\n *"
  },
  {
    "className": "OpenStreetMapImageryProvider",
    "methodName": "OpenStreetMapImageryProvider",
    "description": "An imagery provider that provides tiled imagery hosted by OpenStreetMap",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const osm = new Cesium.OpenStreetMapImageryProvider({\n *     url : 'https://tile.openstreetmap.org/'\n * });\n *\n *"
  },
  {
    "className": "OrderedGroundPrimitiveCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this",
    "parameters": [],
    "returnType": "unknown",
    "example": "* primitives = primitives && primitives.destroy();\n *\n *"
  },
  {
    "className": "PerInstanceColorAppearance",
    "methodName": "PerInstanceColorAppearance",
    "description": "An appearance for {@link GeometryInstance} instances with color attributes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // A solid white line segment\n * const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.SimplePolylineGeometry({\n *       positions : Cesium.Cartesian3.fromDegreesArray([\n *         0.0, 0.0,\n *         5.0, 0.0\n *       ])\n *     }),\n *     attributes : {\n *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))\n *     }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance({\n *     flat : true,\n *     translucent : false\n *   })\n * });\n *\n * // Two rectangles in a primitive, each with a different color\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0)\n *   }),\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 0.5)\n *   }\n * });\n *\n * const anotherInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(0.0, 40.0, 10.0, 50.0)\n *   }),\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 0.0, 1.0, 0.5)\n *   }\n * });\n *\n * const rectanglePrimitive = new Cesium.Primitive({\n *   geometryInstances : [instance, anotherInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * });"
  },
  {
    "className": "PointCloudEyeDomeLighting",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* processor = processor && processor.destroy();\n *\n *"
  },
  {
    "className": "PointPrimitive",
    "methodName": "function",
    "description": "Gets or sets near and far scaling properties of a point based on the point's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a pointPrimitive's scaleByDistance to scale to 15 when the\n   * // camera is 1500 meters from the pointPrimitive and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * p.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 15, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "PointPrimitive",
    "methodName": "function",
    "description": "Gets or sets near and far translucency properties of a point based on the point's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a point's translucency to 1.0 when the\n   * // camera is 1500 meters from the point and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * p.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "PointPrimitive",
    "methodName": "function",
    "description": "Gets or sets the inner color of the point.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Assign yellow.\n   * p.color = Cesium.Color.YELLOW;\n   *\n   *"
  },
  {
    "className": "PointPrimitive",
    "methodName": "computeScreenSpacePosition",
    "description": "Computes the screen-space position of the point's origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* console.log(p.computeScreenSpacePosition(scene).toString());"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "PointPrimitiveCollection",
    "description": "A renderable collection of points.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a pointPrimitive collection with two points\n * const points = scene.primitives.add(new Cesium.PointPrimitiveCollection());\n * points.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   color : Cesium.Color.YELLOW\n * });\n * points.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   color : Cesium.Color.CYAN\n * });\n *\n *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * pointPrimitives.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * pointPrimitives.add({\n   *   color : Cesium.Color.ORANGE,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.YELLOW,\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.GREEN,\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.CYAN,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "add",
    "description": "Creates and adds a point with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1:  Add a point, specifying all the default values.\n * const p = pointPrimitives.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelSize : 10.0,\n *   color : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.TRANSPARENT,\n *   outlineWidth : 0.0,\n *   id : undefined\n * });\n *\n *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "remove",
    "description": "Removes a point from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const p = pointPrimitives.add(...);\n * pointPrimitives.remove(p);  // Returns true\n *\n *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "removeAll",
    "description": "Removes all points from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointPrimitives.add(...);\n * pointPrimitives.add(...);\n * pointPrimitives.removeAll();\n *\n *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "get",
    "description": "Returns the point in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every point in the collection\n * const len = pointPrimitives.length;\n * for (let i = 0; i < len; ++i) {\n *   const p = pointPrimitives.get(i);\n *   p.show = !p.show;\n * }\n *\n *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointPrimitives = pointPrimitives && pointPrimitives.destroy();\n *\n *"
  },
  {
    "className": "Polyline",
    "methodName": "function",
    "description": "Gets or sets the positions of the polyline.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* polyline.positions = Cesium.Cartesian3.fromDegreesArray([\n   *     0.0, 0.0,\n   *     10.0, 0.0,\n   *     0.0, 20.0\n   * ]);"
  },
  {
    "className": "PolylineCollection",
    "methodName": "PolylineCollection",
    "description": "A renderable collection of polylines.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a polyline collection with two polylines\n * const polylines = new Cesium.PolylineCollection();\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -75.10, 39.57,\n *     -77.02, 38.53,\n *     -80.50, 35.14,\n *     -80.12, 25.46]),\n *   width : 2\n * });\n *\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -73.10, 37.57,\n *     -75.02, 36.53,\n *     -78.50, 33.14,\n *     -78.12, 23.46]),\n *   width : 4\n * });"
  },
  {
    "className": "PolylineCollection",
    "methodName": "add",
    "description": "Creates and adds a polyline with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1:  Add a polyline, specifying all the default values.\n     * const p = polylines.add({\n     *   show : true,\n     *   positions : ellipsoid.cartographicArrayToCartesianArray([\n           Cesium.Cartographic.fromDegrees(-75.10, 39.57),\n           Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),\n     *   width : 1\n     * });\n     *\n     *"
  },
  {
    "className": "PolylineCollection",
    "methodName": "remove",
    "description": "Removes a polyline from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const p = polylines.add(...);\n * polylines.remove(p);  // Returns true\n *\n *"
  },
  {
    "className": "PolylineCollection",
    "methodName": "removeAll",
    "description": "Removes all polylines from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* polylines.add(...);\n * polylines.add(...);\n * polylines.removeAll();\n *\n *"
  },
  {
    "className": "PolylineCollection",
    "methodName": "get",
    "description": "Returns the polyline in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every polyline in the collection\n * const len = polylines.length;\n * for (let i = 0; i < len; ++i) {\n *   const p = polylines.get(i);\n *   p.show = !p.show;\n * }\n *\n *"
  },
  {
    "className": "PolylineCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* polylines = polylines && polylines.destroy();\n *\n *"
  },
  {
    "className": "PolylineColorAppearance",
    "methodName": "PolylineColorAppearance",
    "description": "An appearance for {@link GeometryInstance} instances with color attributes and",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // A solid white line segment\n * const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.PolylineGeometry({\n *       positions : Cesium.Cartesian3.fromDegreesArray([\n *         0.0, 0.0,\n *         5.0, 0.0\n *       ]),\n *       width : 10.0,\n *       vertexFormat : Cesium.PolylineColorAppearance.VERTEX_FORMAT\n *     }),\n *     attributes : {\n *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))\n *     }\n *   }),\n *   appearance : new Cesium.PolylineColorAppearance({\n *     translucent : false\n *   })\n * });"
  },
  {
    "className": "PolylineMaterialAppearance",
    "methodName": "PolylineMaterialAppearance",
    "description": "An appearance for {@link PolylineGeometry} that supports shading with materials.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.PolylineGeometry({\n *       positions : Cesium.Cartesian3.fromDegreesArray([\n *         0.0, 0.0,\n *         5.0, 0.0\n *       ]),\n *       width : 10.0,\n *       vertexFormat : Cesium.PolylineMaterialAppearance.VERTEX_FORMAT\n *     })\n *   }),\n *   appearance : new Cesium.PolylineMaterialAppearance({\n *     material : Cesium.Material.fromType('Color')\n *   })\n * });"
  },
  {
    "className": "PostProcessStage",
    "methodName": "PostProcessStage",
    "description": "Runs a post-process stage on either the texture rendered by the scene or the output of a previous post-process stage.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Simple stage to change the color\n * const fs =`\n *     uniform sampler2D colorTexture;\n *     in vec2 v_textureCoordinates;\n *     uniform float scale;\n *     uniform vec3 offset;\n *     void main() {\n *         vec4 color = texture(colorTexture, v_textureCoordinates);\n *         out_FragColor = vec4(color.rgb * scale + offset, 1.0);\n *     }`;\n * scene.postProcessStages.add(new Cesium.PostProcessStage({\n *     fragmentShader : fs,\n *     uniforms : {\n *         scale : 1.1,\n *         offset : function() {\n *             return new Cesium.Cartesian3(0.1, 0.2, 0.3);\n *         }\n *     }\n * }));\n *\n *"
  },
  {
    "className": "PostProcessStageCollection",
    "methodName": "function",
    "description": "Specifies the tonemapping algorithm used when rendering with high dynamic range.",
    "parameters": [],
    "returnType": "unknown",
    "example": "viewer.scene.postProcessStages.tonemapper = Cesium.Tonemapper.ACES;\n   *\n   *"
  },
  {
    "className": "PostProcessStageCollection",
    "methodName": "function",
    "description": "Control the exposure when HDR is on. Less than 1.0 makes the tonemapping darker while greater than 1.0 makes it brighter.",
    "parameters": [],
    "returnType": "unknown",
    "example": "viewer.scene.postProcessStages.exposure = 1.0;\n   *\n   *"
  },
  {
    "className": "PostProcessStageComposite",
    "methodName": "PostProcessStageComposite",
    "description": "A collection of {@link PostProcessStage}s or other post-process composite stages that execute together logically.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1: separable blur filter\n * // The input to blurXDirection is the texture rendered to by the scene or the output of the previous stage.\n * // The input to blurYDirection is the texture rendered to by blurXDirection.\n * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({\n *     stages : [blurXDirection, blurYDirection]\n * }));\n *\n *"
  },
  {
    "className": "PostProcessStageLibrary",
    "methodName": "createEdgeDetectionStage",
    "description": "Creates a post-process stage that detects edges.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // multiple silhouette effects\n * const yellowEdge = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();\n * yellowEdge.uniforms.color = Cesium.Color.YELLOW;\n * yellowEdge.selected = [feature0];\n *\n * const greenEdge = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();\n * greenEdge.uniforms.color = Cesium.Color.LIME;\n * greenEdge.selected = [feature1];\n *\n * // draw edges around feature0 and feature1\n * postProcessStages.add(Cesium.PostProcessStageLibrary.createSilhouetteStage([yellowEdge, greenEdge]);"
  },
  {
    "className": "Primitive",
    "methodName": "Primitive",
    "description": "A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Draw a translucent ellipse on the surface with a checkerboard pattern\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipseGeometry({\n *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),\n *       semiMinorAxis : 500000.0,\n *       semiMajorAxis : 1000000.0,\n *       rotation : Cesium.Math.PI_OVER_FOUR,\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Checkerboard')\n *   })\n * }));\n *\n *"
  },
  {
    "className": "Primitive",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);"
  },
  {
    "className": "Primitive",
    "methodName": "function",
    "description": "Determines if the primitive is complete and ready to render.  If this property is",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Wait for a primitive to become ready before accessing attributes\n   * const removeListener = scene.postRender.addEventListener(() => {\n   *   if (!frustumPrimitive.ready) {\n   *     return;\n   *   }\n   *\n   *   const attributes = primitive.getGeometryInstanceAttributes('an id');\n   *   attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n   *\n   *   removeListener();\n   * });"
  },
  {
    "className": "Primitive",
    "methodName": "getGeometryInstanceAttributes",
    "description": "Returns the modifiable per-instance attributes for a {@link GeometryInstance}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);\n * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);"
  },
  {
    "className": "Primitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "PrimitiveCollection",
    "description": "A collection of primitives.  This is most often used with {@link Scene#primitives},",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const billboards = new Cesium.BillboardCollection();\n * const labels = new Cesium.LabelCollection();\n *\n * const collection = new Cesium.PrimitiveCollection();\n * collection.add(billboards);\n *\n * scene.primitives.add(collection);  // Add collection\n * scene.primitives.add(labels);      // Add regular primitive"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "destroyPrimitives",
    "description": "Determines if primitives in the collection are destroyed when they are removed by",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Primitives are destroyed by default.\n   * const primitives = new Cesium.PrimitiveCollection();\n   * const labels = primitives.add(new Cesium.LabelCollection());\n   * primitives = primitives.destroy();\n   * const b = labels.isDestroyed(); // true\n   *\n   *"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "add",
    "description": "Adds a primitive to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const billboards = scene.primitives.add(new Cesium.BillboardCollection());"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "remove",
    "description": "Removes a primitive from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n * scene.primitives.remove(billboards);  // Returns true\n *\n *"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "get",
    "description": "Returns the primitive in the collection at the specified index.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every primitive in the collection.\n * const primitives = scene.primitives;\n * const length = primitives.length;\n * for (let i = 0; i < length; ++i) {\n *   const p = primitives.get(i);\n *   p.show = !p.show;\n * }\n *\n *"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this",
    "parameters": [],
    "returnType": "unknown",
    "example": "* primitives = primitives && primitives.destroy();\n *\n *"
  },
  {
    "className": "QuadtreePrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* primitive = primitive && primitive.destroy();\n *\n *"
  },
  {
    "className": "QuadtreeTileProvider",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* provider = provider && provider();\n *\n *"
  },
  {
    "className": "ResourceLoader",
    "methodName": "destroy",
    "description": "Destroys the loaded resource.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resourceLoader = resourceLoader && resourceLoader.destroy();\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "Scene",
    "description": "The container for all 3D graphical objects and state in a Cesium virtual scene.  Generally,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create scene without anisotropic texture filtering\n * const scene = new Cesium.Scene({\n *   canvas : canvas,\n *   contextOptions : {\n *     allowTextureFilterAnisotropic : false\n *   }\n * });"
  },
  {
    "className": "Scene",
    "methodName": "debugCommandFilter",
    "description": "This property is for debugging only; it is not for production use.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Do not execute any commands.\n   * scene.debugCommandFilter = function(command) {\n   *     return false;\n   * };\n   *\n   * // Execute only the billboard's commands.  That is, only draw the billboard.\n   * const billboards = new Cesium.BillboardCollection();\n   * scene.debugCommandFilter = function(command) {\n   *     return command.owner === billboards;\n   * };"
  },
  {
    "className": "Scene",
    "methodName": "pickTranslucentDepth",
    "description": "When <code>true</code>, enables picking translucent geometry using the depth buffer. Note that {@link Scene#useDepthPicking} must also be true for enabling this to work.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // picking the position of a translucent primitive\n   * viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {\n   *      const pickedFeature = viewer.scene.pick(movement.position);\n   *      if (!Cesium.defined(pickedFeature)) {\n   *          // nothing picked\n   *          return;\n   *      }\n   *      const worldPosition = viewer.scene.pickPosition(movement.position);\n   * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n   *\n   *"
  },
  {
    "className": "Scene",
    "methodName": "pick",
    "description": "Returns an object with a <code>primitive</code> property that contains the first (top) primitive in the scene",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On mouse over, color the feature yellow.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.Cesium3DTileFeature) {\n *         feature.color = Cesium.Color.YELLOW;\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "pickAsync",
    "description": "Performs the same operation as Scene.pick but asynchonosly without blocking the main render thread.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On mouse over, color the feature yellow.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pickAsync(movement.endPosition).then(function(feature) {\n *        if (feature instanceof Cesium.Cesium3DTileFeature) {\n *            feature.color = Cesium.Color.YELLOW;\n *        }\n *     });\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "pickVoxel",
    "description": "Returns a {@link VoxelCell} for the voxel sample rendered at a particular window coordinate,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* On left click, report the value of the \"color\" property at that voxel sample.\n * handler.setInputAction(function(movement) {\n *   const voxelCell = scene.pickVoxel(movement.position);\n *   if (defined(voxelCell)) {\n *     console.log(voxelCell.getProperty(\"color\"));\n *   }\n * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "drillPick",
    "description": "Returns a list of objects, each containing a <code>primitive</code> property, for all primitives at",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const pickedObjects = scene.drillPick(new Cesium.Cartesian2(100.0, 200.0));\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "sampleHeight",
    "description": "Returns the height of scene geometry at the given cartographic position or <code>undefined</code> if there was no",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const position = new Cesium.Cartographic(-1.31968, 0.698874);\n * const height = viewer.scene.sampleHeight(position);\n * console.log(height);\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "clampToHeight",
    "description": "Clamps the given cartesian position to the scene geometry along the geodetic surface normal. Returns the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Clamp an entity to the underlying scene geometry\n * const position = entity.position.getValue(Cesium.JulianDate.now());\n * entity.position = viewer.scene.clampToHeight(position);\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "sampleHeightMostDetailed",
    "description": "Initiates an asynchronous {@link Scene#sampleHeight} query for an array of {@link Cartographic} positions",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = [\n *     new Cesium.Cartographic(-1.31968, 0.69887),\n *     new Cesium.Cartographic(-1.10489, 0.83923)\n * ];\n * const promise = viewer.scene.sampleHeightMostDetailed(positions);\n * promise.then(function(updatedPosition) {\n *     // positions[0].height and positions[1].height have been updated.\n *     // updatedPositions is just a reference to positions.\n * }\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "clampToHeightMostDetailed",
    "description": "Initiates an asynchronous {@link Scene#clampToHeight} query for an array of {@link Cartesian3} positions",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cartesians = [\n *     entities[0].position.getValue(Cesium.JulianDate.now()),\n *     entities[1].position.getValue(Cesium.JulianDate.now())\n * ];\n * const promise = viewer.scene.clampToHeightMostDetailed(cartesians);\n * promise.then(function(updatedCartesians) {\n *     entities[0].position = updatedCartesians[0];\n *     entities[1].position = updatedCartesians[1];\n * }\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "cartesianToCanvasCoordinates",
    "description": "Transforms a position in cartesian coordinates to canvas coordinates.  This is commonly used to place an",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Output the canvas position of longitude/latitude (0, 0) every time the mouse moves.\n * const scene = widget.scene;\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(scene.cartesianToCanvasCoordinates(position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);"
  },
  {
    "className": "Scene",
    "methodName": "setTerrain",
    "description": "Update the terrain providing surface geometry for the globe.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use Cesium World Terrain\n * scene.setTerrain(Cesium.Terrain.fromWorldTerrain());\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene = scene && scene.destroy();\n *\n *"
  },
  {
    "className": "SceneTransforms",
    "methodName": "worldToWindowCoordinates",
    "description": "Transforms a position in world (WGS84 or alternative ellipsoid) coordinates to window coordinates.  This is commonly used to place an",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.worldToWindowCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);"
  },
  {
    "className": "SceneTransforms",
    "methodName": "worldToDrawingBufferCoordinates",
    "description": "Transforms a position in world coordinates to drawing buffer coordinates.  This may produce different",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.worldToDrawingBufferCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);"
  },
  {
    "className": "SceneTransitioner",
    "methodName": "destroy",
    "description": "Once an object is destroyed, it should not be used; calling any function other than",
    "parameters": [],
    "returnType": "unknown",
    "example": "* transitioner = transitioner && transitioner.destroy();"
  },
  {
    "className": "ScreenSpaceCameraController",
    "methodName": "maximumTiltAngle",
    "description": "The angle, relative to the ellipsoid normal, restricting the maximum amount that the user can tilt the camera. If <code>undefined</code>, the angle of the camera tilt is unrestricted.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Prevent the camera from tilting below the ellipsoid surface\n   * viewer.scene.screenSpaceCameraController.maximumTiltAngle = Math.PI / 2.0;"
  },
  {
    "className": "ScreenSpaceCameraController",
    "methodName": "destroy",
    "description": "Removes mouse listeners held by this object.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* controller = controller && controller.destroy();\n *\n *"
  },
  {
    "className": "SingleTileImageryProvider",
    "methodName": "fromUrl",
    "description": "Creates a provider for a single, top-level imagery tile.  The single image is assumed to use a",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const provider = await SingleTileImageryProvider.fromUrl(\"https://yoururl.com/image.png\");"
  },
  {
    "className": "SkyAtmosphere",
    "methodName": "SkyAtmosphere",
    "description": "An atmosphere drawn around the limb of the provided ellipsoid. Based on",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.skyAtmosphere = new Cesium.SkyAtmosphere();\n *\n *"
  },
  {
    "className": "SkyAtmosphere",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();\n *\n *"
  },
  {
    "className": "SkyBox",
    "methodName": "SkyBox",
    "description": "A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.skyBox = new Cesium.SkyBox({\n *   sources : {\n *     positiveX : 'skybox_px.png',\n *     negativeX : 'skybox_nx.png',\n *     positiveY : 'skybox_py.png',\n *     negativeY : 'skybox_ny.png',\n *     positiveZ : 'skybox_pz.png',\n *     negativeZ : 'skybox_nz.png'\n *   }\n * });\n *\n *"
  },
  {
    "className": "SkyBox",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* skyBox = skyBox && skyBox.destroy();\n *\n *"
  },
  {
    "className": "SkyBox",
    "methodName": "createEarthSkyBox",
    "description": "Creates a skybox instance with the default starmap for the Earth.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* viewer.scene.skyBox = Cesium.SkyBox.createEarthSkyBox();"
  },
  {
    "className": "Sun",
    "methodName": "Sun",
    "description": "Draws a sun billboard.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.sun = new Cesium.Sun();\n *\n *"
  },
  {
    "className": "Sun",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* sun = sun && sun.destroy();\n *\n *"
  },
  {
    "className": "Terrain",
    "methodName": "Terrain",
    "description": "A helper to manage async operations of a terrain provider.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   terrain: new Cesium.Terrain(Cesium.CesiumTerrainProvider.fromUrl(\"https://myTestTerrain.com\"));\n * });\n *\n *"
  },
  {
    "className": "Terrain",
    "methodName": "fromWorldTerrain",
    "description": "Creates a {@link Terrain} instance for {@link https://cesium.com/content/#cesium-world-terrain|Cesium World Terrain}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Cesium World Terrain with default settings\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   terrain: Cesium.Terrain.fromWorldTerrain()\n * });\n *\n *"
  },
  {
    "className": "Terrain",
    "methodName": "fromWorldBathymetry",
    "description": "Creates a {@link Terrain} instance for {@link https://cesium.com/content/#cesium-world-bathymetry|Cesium World Bathymetry}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Cesium World Bathymetry with default settings\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   terrain: Cesium.Terrain.fromWorldBathymetry)\n * });\n *\n *"
  },
  {
    "className": "TileMapServiceImageryProvider",
    "methodName": "TileMapServiceImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const tms = await Cesium.TileMapServiceImageryProvider.fromUrl(\n *    \"../images/cesium_maptiler/Cesium_Logo_Color\", {\n *      fileExtension: 'png',\n *      maximumLevel: 4,\n *      rectangle: new Cesium.Rectangle(\n *        Cesium.Math.toRadians(-120.0),\n *        Cesium.Math.toRadians(20.0),\n *        Cesium.Math.toRadians(-60.0),\n *        Cesium.Math.toRadians(40.0))\n * });"
  },
  {
    "className": "TileMapServiceImageryProvider",
    "methodName": "fromUrl",
    "description": "Creates a TileMapServiceImageryProvider from the specified url.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const tms = await Cesium.TileMapServiceImageryProvider.fromUrl(\n *    '../images/cesium_maptiler/Cesium_Logo_Color', {\n *      fileExtension: 'png',\n *      maximumLevel: 4,\n *      rectangle: new Cesium.Rectangle(\n *        Cesium.Math.toRadians(-120.0),\n *        Cesium.Math.toRadians(20.0),\n *        Cesium.Math.toRadians(-60.0),\n *        Cesium.Math.toRadians(40.0))\n * });\n *\n *"
  },
  {
    "className": "TimeDynamicPointCloud",
    "methodName": "style",
    "description": "The style, defined using the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointCloud.style = new Cesium.Cesium3DTileStyle({\n   *    color : {\n   *        conditions : [\n   *            ['${Classification} === 0', 'color(\"purple\", 0.5)'],\n   *            ['${Classification} === 1', 'color(\"red\")'],\n   *            ['true', '${COLOR}']\n   *        ]\n   *    },\n   *    show : '${Classification} !== 2'\n   * });\n   *\n   *"
  },
  {
    "className": "TimeDynamicPointCloud",
    "methodName": "frameFailed",
    "description": "The event fired to indicate that a frame failed to load. A frame may fail to load if the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointCloud.frameFailed.addEventListener(function(error) {\n   *     console.log(`An error occurred loading frame: ${error.uri}`);\n   *     console.log(`Error: ${error.message}`);\n   * });"
  },
  {
    "className": "TimeDynamicPointCloud",
    "methodName": "frameChanged",
    "description": "The event fired to indicate that a new frame was rendered.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointCloud.frameChanged.addEventListener(function(timeDynamicPointCloud) {\n   *     viewer.camera.viewBoundingSphere(timeDynamicPointCloud.boundingSphere);\n   * });"
  },
  {
    "className": "TimeDynamicPointCloud",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointCloud = pointCloud && pointCloud.destroy();\n *\n *"
  },
  {
    "className": "TweenCollection",
    "methodName": "get",
    "description": "Returns the tween in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Output the duration of all the tweens in the collection.\n * const tweens = scene.tweens;\n * const length = tweens.length;\n * for (let i = 0; i < length; ++i) {\n *   console.log(tweens.get(i).duration);\n * }"
  },
  {
    "className": "UrlTemplateImageryProvider",
    "methodName": "UrlTemplateImageryProvider",
    "description": "Provides imagery by requesting tiles using a specified URL template.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Access Natural Earth II imagery, which uses a TMS tiling scheme and Geographic (EPSG:4326) project\n * const tms = new Cesium.UrlTemplateImageryProvider({\n *     url : Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII') + '/{z}/{x}/{reverseY}.jpg',\n *     tilingScheme : new Cesium.GeographicTilingScheme(),\n *     maximumLevel : 5\n * });\n * // Access the CartoDB Positron basemap, which uses an OpenStreetMap-like tiling scheme.\n * const positron = new Cesium.UrlTemplateImageryProvider({\n *     url : 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',\n *     credit : 'Map tiles by CartoDB, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'\n * });\n * // Access a Web Map Service (WMS) server.\n * const wms = new Cesium.UrlTemplateImageryProvider({\n *    url : 'https://services.ga.gov.au/gis/services/NM_Hydrology_and_Marine_Points/MapServer/WMSServer?' +\n *          'tiled=true&transparent=true&format=image%2Fpng&exceptions=application%2Fvnd.ogc.se_xml&' +\n *          'styles=&service=WMS&version=1.3.0&request=GetMap&' +\n *          'layers=Bores&crs=EPSG%3A3857&' +\n *          'bbox={westProjected}%2C{southProjected}%2C{eastProjected}%2C{northProjected}&' +\n *          'width=256&height=256',\n *    rectangle : Cesium.Rectangle.fromDegrees(95.0, -55.0, 170.0, -1.0)  // From GetCapabilities EX_GeographicBoundingBox\n * });\n * // Using custom tags in your template url.\n * const custom = new Cesium.UrlTemplateImageryProvider({\n *    url : 'https://yoururl/{Time}/{z}/{y}/{x}.png',\n *    customTags : {\n *        Time: function(imageryProvider, x, y, level) {\n *            return '20171231'\n *        }\n *    }\n * });\n *\n *"
  },
  {
    "className": "ViewportQuad",
    "methodName": "ViewportQuad",
    "description": "A viewport aligned quad.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewportQuad = new Cesium.ViewportQuad(new Cesium.BoundingRectangle(0, 0, 80, 40));\n * viewportQuad.material.uniforms.color = new Cesium.Color(1.0, 0.0, 0.0, 1.0);"
  },
  {
    "className": "ViewportQuad",
    "methodName": "rectangle",
    "description": "The BoundingRectangle defining the quad's position within the viewport.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* viewportQuad.rectangle = new Cesium.BoundingRectangle(0, 0, 80, 40);"
  },
  {
    "className": "ViewportQuad",
    "methodName": "material",
    "description": "The surface appearance of the viewport quad.  This can be one of several built-in {@link Material} objects or a custom material, scripted with",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Change the color of the default material to yellow\n   * viewportQuad.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);\n   *\n   * // 2. Change material to horizontal stripes\n   * viewportQuad.material = Cesium.Material.fromType(Cesium.Material.StripeType);\n   *\n   *"
  },
  {
    "className": "ViewportQuad",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* quad = quad && quad.destroy();\n *\n *"
  },
  {
    "className": "VoxelBoundsCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelBounds = voxelBounds && voxelBounds.destroy();\n *\n *"
  },
  {
    "className": "VoxelCell",
    "methodName": "VoxelCell",
    "description": "A cell from a {@link VoxelPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On left click, display all the properties for a voxel cell in the console log.\n * handler.setInputAction(function(movement) {\n *   const voxelCell = scene.pickVoxel(movement.position);\n *   if (voxelCell instanceof Cesium.VoxelCell) {\n *     const propertyIds = voxelCell.getPropertyIds();\n *     const length = propertyIds.length;\n *     for (let i = 0; i < length; ++i) {\n *       const propertyId = propertyIds[i];\n *       console.log(`{propertyId}: ${voxelCell.getProperty(propertyId)}`);\n *     }\n *   }\n * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n *\n *"
  },
  {
    "className": "VoxelCell",
    "methodName": "getProperty",
    "description": "Returns a copy of the value of the metadata in the cell with the given name.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Display all the properties for a voxel cell in the console log.\n * const names = voxelCell.getNames();\n * for (let i = 0; i < names.length; ++i) {\n *   const name = names[i];\n *   console.log(`{name}: ${voxelCell.getProperty(name)}`);\n * }"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "tileLoad",
    "description": "The event fired to indicate that a tile's content was loaded.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.tileLoad.addEventListener(function() {\n   *     console.log('A tile was loaded.');\n   * });"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "tileVisible",
    "description": "This event fires once for each visible tile in a frame.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.tileVisible.addEventListener(function() {\n   *     console.log('A tile is visible.');\n   * });\n   *"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "tileFailed",
    "description": "The event fired to indicate that a tile's content failed to load.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.tileFailed.addEventListener(function() {\n   *     console.log('An error occurred loading tile.');\n   * });"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "tileUnload",
    "description": "The event fired to indicate that a tile's content was unloaded.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.tileUnload.addEventListener(function() {\n   *     console.log('A tile was unloaded from the cache.');\n   * });\n   *"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "loadProgress",
    "description": "The event fired to indicate progress of loading new tiles. This event is fired when a new tile",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.loadProgress.addEventListener(function(numberOfPendingRequests, numberOfTilesProcessing) {\n   *     if ((numberOfPendingRequests === 0) && (numberOfTilesProcessing === 0)) {\n   *         console.log('Finished loading');\n   *         return;\n   *     }\n   *\n   *     console.log(`Loading: requests: ${numberOfPendingRequests}, processing: ${numberOfTilesProcessing}`);\n   * });"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "allTilesLoaded",
    "description": "The event fired to indicate that all tiles that meet the screen space error this frame are loaded. The voxel",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.allTilesLoaded.addEventListener(function() {\n   *     console.log('All tiles are loaded');\n   * });"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "initialTilesLoaded",
    "description": "The event fired to indicate that all tiles that meet the screen space error this frame are loaded. This event",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.initialTilesLoaded.addEventListener(function() {\n   *     console.log('Initial tiles are loaded');\n   * });\n   *\n   *"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive = voxelPrimitive && voxelPrimitive.destroy();"
  },
  {
    "className": "VoxelTraversal",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelTraversal = voxelTraversal && voxelTraversal.destroy();"
  },
  {
    "className": "WebMapServiceImageryProvider",
    "methodName": "WebMapServiceImageryProvider",
    "description": "Provides tiled imagery hosted by a Web Map Service (WMS) server.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // WMS servers operated by the US government https://apps.nationalmap.gov/services/\n * const provider = new Cesium.WebMapServiceImageryProvider({\n *     url : 'https://basemap.nationalmap.gov:443/arcgis/services/USGSHydroCached/MapServer/WMSServer',\n *     layers : '0',\n *     proxy: new Cesium.DefaultProxy('/proxy/')\n * });\n * const imageryLayer = new Cesium.ImageryLayer(provider);\n * viewer.imageryLayers.add(imageryLayer);"
  },
  {
    "className": "WebMapTileServiceImageryProvider",
    "methodName": "WebMapTileServiceImageryProvider",
    "description": "Provides tiled imagery served by {@link http://www.opengeospatial.org/standards/wmts|WMTS 1.0.0} compliant servers.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. USGS shaded relief tiles (KVP)\n * const shadedRelief1 = new Cesium.WebMapTileServiceImageryProvider({\n *     url : 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS',\n *     layer : 'USGSShadedReliefOnly',\n *     style : 'default',\n *     format : 'image/jpeg',\n *     tileMatrixSetID : 'default028mm',\n *     // tileMatrixLabels : ['default028mm:0', 'default028mm:1', 'default028mm:2' ...],\n *     maximumLevel: 19,\n *     credit : new Cesium.Credit('U. S. Geological Survey')\n * });\n * viewer.imageryLayers.addImageryProvider(shadedRelief1);\n *\n *"
  },
  {
    "className": "createElevationBandMaterial",
    "methodName": "createElevationBandMaterial",
    "description": "Creates a {@link Material} that combines multiple layers of color/gradient bands and maps them to terrain heights.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.globe.material = Cesium.createElevationBandMaterial({\n *     scene : scene,\n *     layers : [{\n *         entries : [{\n *             height : 4200.0,\n *             color : new Cesium.Color(0.0, 0.0, 0.0, 1.0)\n *         }, {\n *             height : 8848.0,\n *             color : new Cesium.Color(1.0, 1.0, 1.0, 1.0)\n *         }],\n *         extendDownwards : true,\n *         extendUpwards : true,\n *     }, {\n *         entries : [{\n *             height : 7000.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }, {\n *             height : 7100.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }]\n *     }]\n * });"
  },
  {
    "className": "createGooglePhotorealistic3DTileset",
    "methodName": "createGooglePhotorealistic3DTileset",
    "description": "Creates a {@link Cesium3DTileset} instance for the Google Photorealistic 3D",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   geocoder: Cesium.IonGeocodeProviderType.GOOGLE\n * });\n *\n * try {\n *   const tileset = await Cesium.createGooglePhotorealistic3DTileset({\n *      onlyUsingWithGoogleGeocoder: true,\n *   });\n *   viewer.scene.primitives.add(tileset));\n * } catch (error) {\n *   console.log(`Error creating tileset: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "createOsmBuildingsAsync",
    "methodName": "createOsmBuildingsAsync",
    "description": "Creates a {@link Cesium3DTileset} instance for the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Cesium OSM Buildings with default styling\n * const viewer = new Cesium.Viewer(\"cesiumContainer\");\n * try {\n *   const tileset = await Cesium.createOsmBuildingsAsync();\n *   viewer.scene.primitives.add(tileset));\n * } catch (error) {\n *   console.log(`Error creating tileset: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "createTangentSpaceDebugPrimitive",
    "methodName": "createTangentSpaceDebugPrimitive",
    "description": "Creates a {@link Primitive} to visualize well-known vector vertex attributes:",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.primitives.add(Cesium.createTangentSpaceDebugPrimitive({\n *    geometry : instance.geometry,\n *    length : 100000.0,\n *    modelMatrix : instance.modelMatrix\n * }));"
  },
  {
    "className": "createWorldImageryAsync",
    "methodName": "createWorldImageryAsync",
    "description": "Creates an {@link IonImageryProvider} instance for ion's default global base imagery layer, currently Bing Maps.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a Cesium World Imagery base layer with default settings\n * try {\n *   const imageryProvider = await Cesium.createWorldImageryAsync();\n * } catch (error) {\n *   console.log(`There was an error creating world imagery: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "CesiumWidget",
    "methodName": "CesiumWidget",
    "description": "A widget containing a Cesium scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // For each example, include a link to CesiumWidget.css stylesheet in HTML head,\n * // and in the body, include: <div id=\"cesiumContainer\"></div>\n *\n * // Widget with no terrain and default Bing Maps imagery provider.\n * const widget = new Cesium.CesiumWidget(\"cesiumContainer\");\n *\n * // Widget with ion imagery and Cesium World Terrain.\n * const widget2 = new Cesium.CesiumWidget(\"cesiumContainer\", {\n *     baseLayer: Cesium.ImageryLayer.fromWorldTerrain(),\n *     terrain: Cesium.Terrain.fromWorldTerrain()\n *     skyBox: new Cesium.SkyBox({\n *       sources: {\n *         positiveX: \"stars/TychoSkymapII.t3_08192x04096_80_px.jpg\",\n *         negativeX: \"stars/TychoSkymapII.t3_08192x04096_80_mx.jpg\",\n *         positiveY: \"stars/TychoSkymapII.t3_08192x04096_80_py.jpg\",\n *         negativeY: \"stars/TychoSkymapII.t3_08192x04096_80_my.jpg\",\n *         positiveZ: \"stars/TychoSkymapII.t3_08192x04096_80_pz.jpg\",\n *         negativeZ: \"stars/TychoSkymapII.t3_08192x04096_80_mz.jpg\"\n *       }\n *     }),\n *     // Show Columbus View map with Web Mercator projection\n *     sceneMode: Cesium.SceneMode.COLUMBUS_VIEW,\n *     mapProjection: new Cesium.WebMercatorProjection()\n * });"
  },
  {
    "className": "createTaskProcessorWorker",
    "methodName": "createTaskProcessorWorker",
    "description": "Creates an adapter function to allow a calculation function to operate as a Web Worker,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* function doCalculation(parameters, transferableObjects) {\n *   // calculate some result using the inputs in parameters\n *   return result;\n * }\n *\n * return Cesium.createTaskProcessorWorker(doCalculation);\n * // the resulting function is compatible with TaskProcessor\n *\n *"
  },
  {
    "className": "ArcGISTiledElevationTerrainProvider",
    "methodName": "ArcGISTiledElevationTerrainProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\", {\n *   token: \"KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\"\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n *"
  },
  {
    "className": "ArcGISTiledElevationTerrainProvider",
    "methodName": "fromUrl",
    "description": "Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\", {\n *   token: \"KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\"\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n *"
  },
  {
    "className": "AxisAlignedBoundingBox",
    "methodName": "fromCorners",
    "description": "Creates an instance of an AxisAlignedBoundingBox from its corners.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Compute an axis aligned bounding box from the two corners.\n * const box = Cesium.AxisAlignedBoundingBox.fromCorners(new Cesium.Cartesian3(-1, -1, -1), new Cesium.Cartesian3(1, 1, 1));"
  },
  {
    "className": "AxisAlignedBoundingBox",
    "methodName": "fromPoints",
    "description": "Computes an instance of an AxisAlignedBoundingBox. The box is determined by",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Compute an axis aligned bounding box enclosing two points.\n * const box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);"
  },
  {
    "className": "BoundingSphere",
    "methodName": "fromVertices",
    "description": "Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Compute the bounding sphere from 3 positions, each specified relative to a center.\n * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n * // elements per point which are ignored for the purpose of computing the bounding sphere.\n * const center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const points = [1.0, 2.0, 3.0, 0.1, 0.2,\n *               4.0, 5.0, 6.0, 0.1, 0.2,\n *               7.0, 8.0, 9.0, 0.1, 0.2];\n * const sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n *\n *"
  },
  {
    "className": "BoundingSphere",
    "methodName": "fromCornerPoints",
    "description": "Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a bounding sphere around the unit cube\n * const sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));"
  },
  {
    "className": "BoundingSphere",
    "methodName": "fromEllipsoid",
    "description": "Creates a bounding sphere encompassing an ellipsoid.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);"
  },
  {
    "className": "BoundingSphere",
    "methodName": "distanceSquaredTo",
    "description": "Computes the estimated distance squared from the closest point on a bounding sphere to a point.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n * });"
  },
  {
    "className": "BoundingSphere",
    "methodName": "transformWithoutScale",
    "description": "Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n * const boundingSphere = new Cesium.BoundingSphere();\n * const newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);"
  },
  {
    "className": "BoundingSphere",
    "methodName": "distanceSquaredTo",
    "description": "Computes the estimated distance squared from the closest point on a bounding sphere to a point.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });"
  },
  {
    "className": "BoxGeometry",
    "methodName": "BoxGeometry",
    "description": "Describes a cube centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const box = new Cesium.BoxGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * const geometry = Cesium.BoxGeometry.createGeometry(box);"
  },
  {
    "className": "BoxGeometry",
    "methodName": "fromDimensions",
    "description": "Creates a cube centered at the origin given its dimensions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const box = Cesium.BoxGeometry.fromDimensions({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.BoxGeometry.createGeometry(box);\n *\n *"
  },
  {
    "className": "BoxGeometry",
    "methodName": "fromAxisAlignedBoundingBox",
    "description": "Creates a cube from the dimensions of an AxisAlignedBoundingBox.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * const box = Cesium.BoxGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n *"
  },
  {
    "className": "BoxOutlineGeometry",
    "methodName": "BoxOutlineGeometry",
    "description": "A description of the outline of a cube centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const box = new Cesium.BoxOutlineGeometry({\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);"
  },
  {
    "className": "BoxOutlineGeometry",
    "methodName": "fromDimensions",
    "description": "Creates an outline of a cube centered at the origin given its dimensions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const box = Cesium.BoxOutlineGeometry.fromDimensions({\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n *\n *"
  },
  {
    "className": "BoxOutlineGeometry",
    "methodName": "fromAxisAlignedBoundingBox",
    "description": "Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * const box = Cesium.BoxOutlineGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n *"
  },
  {
    "className": "Cartesian2",
    "methodName": "fromArray",
    "description": "Creates a Cartesian2 from two consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a Cartesian2 with (1.0, 2.0)\n * const v = [1.0, 2.0];\n * const p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0];\n * const p2 = Cesium.Cartesian2.fromArray(v2, 2);"
  },
  {
    "className": "Cartesian2",
    "methodName": "distance",
    "description": "Computes the distance between two points.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 1.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));"
  },
  {
    "className": "Cartesian2",
    "methodName": "distanceSquared",
    "description": "Computes the squared distance between two points.  Comparing squared distances",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromArray",
    "description": "Creates a Cartesian3 from three consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * const v = [1.0, 2.0, 3.0];\n * const p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * const p2 = Cesium.Cartesian3.fromArray(v2, 2);"
  },
  {
    "className": "Cartesian3",
    "methodName": "distance",
    "description": "Computes the distance between two points.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 1.0\n * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));"
  },
  {
    "className": "Cartesian3",
    "methodName": "distanceSquared",
    "description": "Computes the squared distance between two points.  Comparing squared distances",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromDegrees",
    "description": "Returns a Cartesian3 position from longitude and latitude values given in degrees.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromRadians",
    "description": "Returns a Cartesian3 position from longitude and latitude values given in radians.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromDegreesArray",
    "description": "Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromRadiansArray",
    "description": "Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromDegreesArrayHeights",
    "description": "Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);"
  },
  {
    "className": "Cartesian3",
    "methodName": "fromRadiansArrayHeights",
    "description": "Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);"
  },
  {
    "className": "Cartesian4",
    "methodName": "fromArray",
    "description": "Creates a Cartesian4 from four consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * const v = [1.0, 2.0, 3.0, 4.0];\n * const p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * const p2 = Cesium.Cartesian4.fromArray(v2, 2);"
  },
  {
    "className": "Cartesian4",
    "methodName": "distance",
    "description": "Computes the 4-space distance between two points.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 1.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));"
  },
  {
    "className": "Cartesian4",
    "methodName": "distanceSquared",
    "description": "Computes the squared distance between two points.  Comparing squared distances",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));"
  },
  {
    "className": "CatmullRomSpline",
    "methodName": "CatmullRomSpline",
    "description": "A Catmull-Rom spline is a cubic spline where the tangent at control points,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // spline above the earth from Philadelphia to Los Angeles\n * const spline = new Cesium.CatmullRomSpline({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[i]);         // equal to positions[i]\n * const p1 = spline.evaluate(times[i] + delta); // interpolated value when delta < times[i + 1] - times[i]\n *\n *"
  },
  {
    "className": "Cesium3DTilesTerrainProvider",
    "methodName": "fromUrl",
    "description": "Creates a {@link TerrainProvider} that accesses terrain data in a Cesium 3D Tiles format.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.Cesium3DTilesTerrainProvider.fromUrl(\n *       Cesium.IonResource.fromAssetId(3956), {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }"
  },
  {
    "className": "Cesium3DTilesTerrainProvider",
    "methodName": "fromIonAssetId",
    "description": "Creates a {@link TerrainProvider} from a Cesium ion asset ID that accesses terrain data in a Cesium 3D Tiles format",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create GTOPO30 with vertex normals\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.Cesium3DTilesTerrainProvider.fromIonAssetId(2732686, {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "CesiumTerrainProvider",
    "methodName": "CesiumTerrainProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {\n *       requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "CesiumTerrainProvider",
    "methodName": "fromIonAssetId",
    "description": "Creates a {@link TerrainProvider} from a Cesium ion asset ID that accesses terrain data in a Cesium terrain format",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "CesiumTerrainProvider",
    "methodName": "fromUrl",
    "description": "Creates a {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromUrl(\n *       Cesium.IonResource.fromAssetId(3956), {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "CircleGeometry",
    "methodName": "CircleGeometry",
    "description": "A description of a circle on the ellipsoid. Circle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a circle.\n * const circle = new Cesium.CircleGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   radius : 100000.0\n * });\n * const geometry = Cesium.CircleGeometry.createGeometry(circle);"
  },
  {
    "className": "CircleOutlineGeometry",
    "methodName": "CircleOutlineGeometry",
    "description": "A description of the outline of a circle on the ellipsoid.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a circle.\n * const circle = new Cesium.CircleOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   radius : 100000.0\n * });\n * const geometry = Cesium.CircleOutlineGeometry.createGeometry(circle);"
  },
  {
    "className": "Clock",
    "methodName": "Clock",
    "description": "A simple clock for keeping track of simulated time.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a clock that loops on Christmas day 2013 and runs in real-time.\n * const clock = new Cesium.Clock({\n *    startTime : Cesium.JulianDate.fromIso8601(\"2013-12-25\"),\n *    currentTime : Cesium.JulianDate.fromIso8601(\"2013-12-25\"),\n *    stopTime : Cesium.JulianDate.fromIso8601(\"2013-12-26\"),\n *    clockRange : Cesium.ClockRange.LOOP_STOP,\n *    clockStep : Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER\n * });\n *\n *"
  },
  {
    "className": "Color",
    "methodName": "fromAlpha",
    "description": "Creates a new Color that has the same red, green, and blue components",
    "parameters": [],
    "returnType": "unknown",
    "example": "const translucentRed = Cesium.Color.fromAlpha(Cesium.Color.RED, 0.9);"
  },
  {
    "className": "Color",
    "methodName": "fromRgba",
    "description": "Creates a new Color from a single numeric unsigned 32-bit RGBA value, using the endianness",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const color = Cesium.Color.fromRgba(0x67ADDFFF);\n *\n *"
  },
  {
    "className": "Color",
    "methodName": "fromRandom",
    "description": "Creates a random color using the provided options. For reproducible random colors, you should",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create a completely random color\n * const color = Cesium.Color.fromRandom();\n *\n * //Create a random shade of yellow.\n * const color1 = Cesium.Color.fromRandom({\n *     red : 1.0,\n *     green : 1.0,\n *     alpha : 1.0\n * });\n *\n * //Create a random bright color.\n * const color2 = Cesium.Color.fromRandom({\n *     minimumRed : 0.75,\n *     minimumGreen : 0.75,\n *     minimumBlue : 0.75,\n *     alpha : 1.0\n * });"
  },
  {
    "className": "Color",
    "methodName": "fromCssColorString",
    "description": "Creates a Color instance from a CSS color value.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cesiumBlue = Cesium.Color.fromCssColorString('#67ADDF');\n * const green = Cesium.Color.fromCssColorString('green');\n *\n *"
  },
  {
    "className": "Color",
    "methodName": "toRgba",
    "description": "Converts this color to a single numeric unsigned 32-bit RGBA value, using the endianness",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const rgba = Cesium.Color.BLUE.toRgba();\n *\n *"
  },
  {
    "className": "Color",
    "methodName": "brighten",
    "description": "Brightens this color by the provided magnitude.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const brightBlue = Cesium.Color.BLUE.brighten(0.5, new Cesium.Color());"
  },
  {
    "className": "Color",
    "methodName": "darken",
    "description": "Darkens this color by the provided magnitude.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const darkBlue = Cesium.Color.BLUE.darken(0.5, new Cesium.Color());"
  },
  {
    "className": "Color",
    "methodName": "withAlpha",
    "description": "Creates a new Color that has the same red, green, and blue components",
    "parameters": [],
    "returnType": "unknown",
    "example": "const translucentRed = Cesium.Color.RED.withAlpha(0.9);"
  },
  {
    "className": "ColorGeometryInstanceAttribute",
    "methodName": "ColorGeometryInstanceAttribute",
    "description": "Value and type information for per-instance geometry color.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const instance = new Cesium.GeometryInstance({\n *   geometry : Cesium.BoxGeometry.fromDimensions({\n *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(red, green, blue, alpha)\n *   }\n * });\n *\n *"
  },
  {
    "className": "ColorGeometryInstanceAttribute",
    "methodName": "fromColor",
    "description": "Creates a new {@link ColorGeometryInstanceAttribute} instance given the provided {@link Color}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const instance = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.CORNFLOWERBLUE),\n *   }\n * });"
  },
  {
    "className": "ColorGeometryInstanceAttribute",
    "methodName": "toValue",
    "description": "Converts a color to a typed array that can be used to assign a color attribute.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA, attributes.color);"
  },
  {
    "className": "ComponentDatatype",
    "methodName": "getSizeInBytes",
    "description": "Returns the size, in bytes, of the corresponding datatype.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns Int8Array.BYTES_PER_ELEMENT\n * const size = Cesium.ComponentDatatype.getSizeInBytes(Cesium.ComponentDatatype.BYTE);"
  },
  {
    "className": "ComponentDatatype",
    "methodName": "validate",
    "description": "Validates that the provided component datatype is a valid {@link ComponentDatatype}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* if (!Cesium.ComponentDatatype.validate(componentDatatype)) {\n *   throw new Cesium.DeveloperError('componentDatatype must be a valid value.');\n * }"
  },
  {
    "className": "ComponentDatatype",
    "methodName": "createTypedArray",
    "description": "Creates a typed array corresponding to component data type.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates a Float32Array with length of 100\n * const typedArray = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 100);"
  },
  {
    "className": "ConstantSpline",
    "methodName": "ConstantSpline",
    "description": "A spline that evaluates to a constant value. Although this follows the {@link Spline} interface,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const position = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const spline = new Cesium.ConstantSpline(position);\n *\n * const p0 = spline.evaluate(0.0);\n *\n *"
  },
  {
    "className": "CoplanarPolygonGeometry",
    "methodName": "CoplanarPolygonGeometry",
    "description": "A description of a polygon composed of arbitrary coplanar positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const polygonGeometry = new Cesium.CoplanarPolygonGeometry({\n *  polygonHierarchy: new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArrayHeights([\n *      -90.0, 30.0, 0.0,\n *      -90.0, 30.0, 300000.0,\n *      -80.0, 30.0, 300000.0,\n *      -80.0, 30.0, 0.0\n *   ]))\n * });\n *"
  },
  {
    "className": "CoplanarPolygonGeometry",
    "methodName": "fromPositions",
    "description": "A description of a coplanar polygon from an array of positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a polygon from points\n * const polygon = Cesium.CoplanarPolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n *"
  },
  {
    "className": "CoplanarPolygonOutlineGeometry",
    "methodName": "CoplanarPolygonOutlineGeometry",
    "description": "A description of the outline of a polygon composed of arbitrary coplanar positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *      -90.0, 30.0, 0.0,\n *      -90.0, 30.0, 1000.0,\n *      -80.0, 30.0, 1000.0,\n *      -80.0, 30.0, 0.0\n *   ])\n * });\n * const geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);"
  },
  {
    "className": "CorridorGeometry",
    "methodName": "CorridorGeometry",
    "description": "A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const corridor = new Cesium.CorridorGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });"
  },
  {
    "className": "CorridorOutlineGeometry",
    "methodName": "CorridorOutlineGeometry",
    "description": "A description of a corridor outline.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const corridor = new Cesium.CorridorOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });"
  },
  {
    "className": "Credit",
    "methodName": "Credit",
    "description": "A credit contains data pertaining to how to display attributions/credits for certain content on the screen.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a credit with a tooltip, image and link\n * const credit = new Cesium.Credit('<a href=\"https://cesium.com/\" target=\"_blank\"><img src=\"/images/cesium_logo.png\"  style=\"vertical-align: -7px\" title=\"Cesium\"/></a>');"
  },
  {
    "className": "CustomHeightmapTerrainProvider",
    "methodName": "CustomHeightmapTerrainProvider",
    "description": "A simple {@link TerrainProvider} that gets height values from a callback function.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   terrainProvider: new Cesium.CustomHeightmapTerrainProvider({\n *     width: 32,\n *     height: 32,\n *     callback: function (x, y, level) {\n *       return new Float32Array(32 * 32); // all zeros\n *     },\n *   }),\n * });\n *\n *"
  },
  {
    "className": "CylinderGeometry",
    "methodName": "CylinderGeometry",
    "description": "A description of a cylinder.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create cylinder geometry\n * const cylinder = new Cesium.CylinderGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderGeometry.createGeometry(cylinder);"
  },
  {
    "className": "CylinderOutlineGeometry",
    "methodName": "CylinderOutlineGeometry",
    "description": "A description of the outline of a cylinder.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create cylinder geometry\n * const cylinder = new Cesium.CylinderOutlineGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);"
  },
  {
    "className": "DistanceDisplayCondition",
    "methodName": "DistanceDisplayCondition",
    "description": "Determines visibility based on the distance to the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Make a billboard that is only visible when the distance to the camera is between 10 and 20 meters.\n * billboard.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(10.0, 20.0);"
  },
  {
    "className": "DistanceDisplayConditionGeometryInstanceAttribute",
    "methodName": "DistanceDisplayConditionGeometryInstanceAttribute",
    "description": "Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.BoxGeometry({\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)\n *   }\n * });\n *\n *"
  },
  {
    "className": "DistanceDisplayConditionGeometryInstanceAttribute",
    "methodName": "fromDistanceDisplayCondition",
    "description": "Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);\n * const instance = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   attributes : {\n *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n *   }\n * });"
  },
  {
    "className": "DistanceDisplayConditionGeometryInstanceAttribute",
    "methodName": "toValue",
    "description": "Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);"
  },
  {
    "className": "EarthOrientationParameters",
    "methodName": "fromUrl",
    "description": "* @param {Resource|string} [url] The URL from which to obtain EOP data.  If neither this",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // An example EOP data file, EOP.json:\n * {\n *   \"columnNames\" : [\"dateIso8601\",\"modifiedJulianDateUtc\",\"xPoleWanderRadians\",\"yPoleWanderRadians\",\"ut1MinusUtcSeconds\",\"lengthOfDayCorrectionSeconds\",\"xCelestialPoleOffsetRadians\",\"yCelestialPoleOffsetRadians\",\"taiMinusUtcSeconds\"],\n *   \"samples\" : [\n *      \"2011-07-01T00:00:00Z\",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,\n *      \"2011-07-02T00:00:00Z\",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,\n *      \"2011-07-03T00:00:00Z\",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0\n *   ]\n * }\n *\n *"
  },
  {
    "className": "EasingFunction",
    "methodName": "freeze",
    "description": "Function interface for implementing a custom easing function.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* function quadraticIn(time) {\n *     return time * time;\n * }\n *\n *"
  },
  {
    "className": "EllipseGeometry",
    "methodName": "EllipseGeometry",
    "description": "A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create an ellipse.\n * const ellipse = new Cesium.EllipseGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n *\n *"
  },
  {
    "className": "EllipseOutlineGeometry",
    "methodName": "EllipseOutlineGeometry",
    "description": "A description of the outline of an ellipse on an ellipsoid.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const ellipse = new Cesium.EllipseOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);"
  },
  {
    "className": "Ellipsoid",
    "methodName": "function",
    "description": "The default ellipsoid used when not otherwise specified.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.Ellipsoid.default = Cesium.Ellipsoid.MOON;\n   *\n   * // Apollo 11 landing site\n   * const position = Cesium.Cartesian3.fromRadians(\n   *   0.67416,\n   *   23.47315,\n   * );"
  },
  {
    "className": "Ellipsoid",
    "methodName": "cartographicToCartesian",
    "description": "Converts the provided cartographic to Cartesian representation.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * const cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);"
  },
  {
    "className": "Ellipsoid",
    "methodName": "cartographicArrayToCartesianArray",
    "description": "Converts the provided array of cartographics to an array of Cartesians.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * const cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);"
  },
  {
    "className": "Ellipsoid",
    "methodName": "cartesianToCartographic",
    "description": "Converts the provided cartesian to cartographic representation.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * const cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);"
  },
  {
    "className": "Ellipsoid",
    "methodName": "cartesianArrayToCartographicArray",
    "description": "Converts the provided array of cartesians to an array of cartographics.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * const cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);"
  },
  {
    "className": "EllipsoidGeometry",
    "methodName": "EllipsoidGeometry",
    "description": "A description of an ellipsoid centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const ellipsoid = new Cesium.EllipsoidGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);"
  },
  {
    "className": "EllipsoidOutlineGeometry",
    "methodName": "EllipsoidOutlineGeometry",
    "description": "A description of the outline of an ellipsoid centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const ellipsoid = new Cesium.EllipsoidOutlineGeometry({\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),\n *   stackPartitions: 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);"
  },
  {
    "className": "EllipsoidalOccluder",
    "methodName": "EllipsoidalOccluder",
    "description": "Determine whether or not other objects are visible or hidden behind the visible horizon defined by",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * const cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * const occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n *"
  },
  {
    "className": "EllipsoidalOccluder",
    "methodName": "isPointVisible",
    "description": "Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true"
  },
  {
    "className": "EllipsoidalOccluder",
    "methodName": "isScaledSpacePointVisible",
    "description": "Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * const scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true"
  },
  {
    "className": "EncodedCartesian3",
    "methodName": "encode",
    "description": "Encodes a 64-bit floating-point value as two floating-point values that, when converted to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const value = 1234567.1234567;\n * const splitValue = Cesium.EncodedCartesian3.encode(value);"
  },
  {
    "className": "EncodedCartesian3",
    "methodName": "fromCartesian",
    "description": "Encodes a {@link Cartesian3} with 64-bit floating-point components as two {@link Cartesian3}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cart = new Cesium.Cartesian3(-10000000.0, 0.0, 10000000.0);\n * const encoded = Cesium.EncodedCartesian3.fromCartesian(cart);"
  },
  {
    "className": "EncodedCartesian3",
    "methodName": "writeElements",
    "description": "Encodes the provided <code>cartesian</code>, and writes it to an array with <code>high</code>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = [\n *    new Cesium.Cartesian3(),\n *    // ...\n * ];\n * const encodedPositions = new Float32Array(2 * 3 * positions.length);\n * let j = 0;\n * for (let i = 0; i < positions.length; ++i) {\n *   Cesium.EncodedCartesian3.writeElement(positions[i], encodedPositions, j);\n *   j += 6;\n * }"
  },
  {
    "className": "Event",
    "methodName": "Event",
    "description": "A generic utility class for managing subscribers for a particular event.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* MyObject.prototype.myListener = function(arg1, arg2) {\n *     this.myArg1Copy = arg1;\n *     this.myArg2Copy = arg2;\n * }\n *\n * const myObjectInstance = new MyObject();\n * const evt = new Cesium.Event();\n * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);\n * evt.raiseEvent('1', '2');\n * evt.removeEventListener(MyObject.prototype.myListener);"
  },
  {
    "className": "EventHelper",
    "methodName": "EventHelper",
    "description": "A convenience object that simplifies the common pattern of attaching event listeners",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const helper = new Cesium.EventHelper();\n *\n * helper.add(someObject.event, listener1, this);\n * helper.add(otherObject.event, listener2, this);\n *\n * // later...\n * helper.removeAll();\n *\n *"
  },
  {
    "className": "Fullscreen",
    "methodName": "requestFullscreen",
    "description": "Asynchronously requests the browser to enter fullscreen mode on the given element.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Put the entire page into fullscreen.\n * Cesium.Fullscreen.requestFullscreen(document.body)\n *\n * // Place only the Cesium canvas into fullscreen.\n * Cesium.Fullscreen.requestFullscreen(scene.canvas)"
  },
  {
    "className": "Geometry",
    "methodName": "Geometry",
    "description": "A geometry representation with attributes forming vertices and optional index data",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create geometry with a position attribute and indexed lines.\n * const positions = new Float64Array([\n *   0.0, 0.0, 0.0,\n *   7500000.0, 0.0, 0.0,\n *   0.0, 7500000.0, 0.0\n * ]);\n *\n * const geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,\n *       componentsPerAttribute : 3,\n *       values : positions\n *     })\n *   },\n *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),\n *   primitiveType : Cesium.PrimitiveType.LINES,\n *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)\n * });"
  },
  {
    "className": "Geometry",
    "methodName": "attributes",
    "description": "Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry.attributes.position = new Cesium.GeometryAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.FLOAT,\n   *   componentsPerAttribute : 3,\n   *   values : new Float32Array(0)\n   * });\n   *\n   *"
  },
  {
    "className": "Geometry",
    "methodName": "computeNumberOfVertices",
    "description": "Computes the number of vertices in a geometry.  The runtime is linear with",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);"
  },
  {
    "className": "GeometryAttribute",
    "methodName": "GeometryAttribute",
    "description": "Values and type information for geometry attributes.  A {@link Geometry}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.FLOAT,\n *       componentsPerAttribute : 3,\n *       values : new Float32Array([\n *         0.0, 0.0, 0.0,\n *         7500000.0, 0.0, 0.0,\n *         0.0, 7500000.0, 0.0\n *       ])\n *     })\n *   },\n *   primitiveType : Cesium.PrimitiveType.LINE_LOOP\n * });\n *\n *"
  },
  {
    "className": "GeometryAttribute",
    "methodName": "componentsPerAttribute",
    "description": "A number between 1 and 4 that defines the number of components in an attributes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n   * attribute.componentsPerAttribute = 3;\n   * attribute.values = new Float32Array([\n   *   0.0, 0.0, 0.0,\n   *   7500000.0, 0.0, 0.0,\n   *   0.0, 7500000.0, 0.0\n   * ]);"
  },
  {
    "className": "GeometryAttribute",
    "methodName": "normalize",
    "description": "When <code>true</code> and <code>componentDatatype</code> is an integer format,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\n   * attribute.componentsPerAttribute = 4;\n   * attribute.normalize = true;\n   * attribute.values = new Uint8Array([\n   *   Cesium.Color.floatToByte(color.red),\n   *   Cesium.Color.floatToByte(color.green),\n   *   Cesium.Color.floatToByte(color.blue),\n   *   Cesium.Color.floatToByte(color.alpha)\n   * ]);"
  },
  {
    "className": "GeometryAttribute",
    "methodName": "values",
    "description": "The values for the attributes stored in a typed array.  In the code example,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n   * attribute.componentsPerAttribute = 3;\n   * attribute.values = new Float32Array([\n   *   0.0, 0.0, 0.0,\n   *   7500000.0, 0.0, 0.0,\n   *   0.0, 7500000.0, 0.0\n   * ]);"
  },
  {
    "className": "GeometryInstance",
    "methodName": "GeometryInstance",
    "description": "Geometry instancing allows one {@link Geometry} object to be positions in several",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create geometry for a box, and two instances that refer to it.\n * // One instance positions the box on the bottom and colored aqua.\n * // The other instance positions the box on the top and color white.\n * const geometry = Cesium.BoxGeometry.fromDimensions({\n *   vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *   dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n * });\n * const instanceBottom = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   },\n *   id : 'bottom'\n * });\n * const instanceTop = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 3000000.0), new Cesium.Matrix4()),\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   },\n *   id : 'top'\n * });\n *\n *"
  },
  {
    "className": "GeometryInstanceAttribute",
    "methodName": "GeometryInstanceAttribute",
    "description": "Values and type information for per-instance geometry attributes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const instance = new Cesium.GeometryInstance({\n *   geometry : Cesium.BoxGeometry.fromDimensions({\n *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     color : new Cesium.GeometryInstanceAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n *       componentsPerAttribute : 4,\n *       normalize : true,\n *       value : [255, 255, 0, 255]\n *     })\n *   }\n * });\n *\n *"
  },
  {
    "className": "GeometryInstanceAttribute",
    "methodName": "componentsPerAttribute",
    "description": "A number between 1 and 4 that defines the number of components in an attributes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* show : new Cesium.GeometryInstanceAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n   *   componentsPerAttribute : 1,\n   *   normalize : true,\n   *   value : [1.0]\n   * })"
  },
  {
    "className": "GeometryInstanceAttribute",
    "methodName": "normalize",
    "description": "When <code>true</code> and <code>componentDatatype</code> is an integer format,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\n   * attribute.componentsPerAttribute = 4;\n   * attribute.normalize = true;\n   * attribute.value = [\n   *   Cesium.Color.floatToByte(color.red),\n   *   Cesium.Color.floatToByte(color.green),\n   *   Cesium.Color.floatToByte(color.blue),\n   *   Cesium.Color.floatToByte(color.alpha)\n   * ];"
  },
  {
    "className": "GeometryInstanceAttribute",
    "methodName": "value",
    "description": "The values for the attributes stored in a typed array.  In the code example,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* show : new Cesium.GeometryInstanceAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n   *   componentsPerAttribute : 1,\n   *   normalize : true,\n   *   value : [1.0]\n   * })"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "toWireframe",
    "description": "Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.toWireframe(geometry);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "createLineSegmentsForVectors",
    "description": "Creates a new {@link Geometry} with <code>LINES</code> representing the provided",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "createAttributeLocations",
    "description": "Creates an object that maps attribute names to unique locations (indices)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\n * // Example output\n * // {\n * //   'position' : 0,\n * //   'normal' : 1\n * // }"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "reorderForPreVertexCache",
    "description": "Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\n *\n *"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "reorderForPostVertexCache",
    "description": "Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\n *\n *"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "fitToUnsignedShortIndices",
    "description": "Splits a geometry into multiple geometries, if necessary, to ensure that indices in the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "projectTo2D",
    "description": "Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "encodeAttribute",
    "description": "Encodes floating-point geometry attribute values as two separate attributes to improve",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "transformToWorldCoordinates",
    "description": "Transforms a geometry instance to world coordinates.  This changes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.GeometryPipeline.transformToWorldCoordinates(instance);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "combineInstances",
    "description": "Combines geometry from several {@link GeometryInstance} objects into one geometry.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* for (let i = 0; i < instances.length; ++i) {\n *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\n * }\n * const geometries = Cesium.GeometryPipeline.combineInstances(instances);\n *\n *"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "computeNormal",
    "description": "Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.GeometryPipeline.computeNormal(geometry);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "computeTangentAndBitangent",
    "description": "Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "compressVertices",
    "description": "Compresses and packs geometry normal attribute values to save memory.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* geometry = Cesium.GeometryPipeline.compressVertices(geometry);"
  },
  {
    "className": "GeometryPipeline",
    "methodName": "splitLongitude",
    "description": "Splits the instances's geometry, by introducing new vertices and indices,that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* instance = Cesium.GeometryPipeline.splitLongitude(instance);"
  },
  {
    "className": "GoogleEarthEnterpriseTerrainData",
    "methodName": "GoogleEarthEnterpriseTerrainData",
    "description": "Terrain data for a single tile from a Google Earth Enterprise server.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const buffer = ...\n * const childTileMask = ...\n * const terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({\n *   buffer : heightBuffer,\n *   childTileMask : childTileMask\n * });\n *\n *"
  },
  {
    "className": "GoogleEarthEnterpriseTerrainProvider",
    "methodName": "GoogleEarthEnterpriseTerrainProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseTerrainProvider.fromMetadata(geeMetadata);\n *\n *"
  },
  {
    "className": "GoogleEarthEnterpriseTerrainProvider",
    "methodName": "fromMetadata",
    "description": "Creates a GoogleEarthTerrainProvider from GoogleEarthEnterpriseMetadata",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseTerrainProvider.fromMetadata(geeMetadata);"
  },
  {
    "className": "GroundPolylineGeometry",
    "methodName": "GroundPolylineGeometry",
    "description": "A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -112.1340164450331, 36.05494287836128,\n *   -112.08821010582645, 36.097804071380715,\n *   -112.13296079730024, 36.168769146801104\n * ]);\n *\n * const geometry = new Cesium.GroundPolylineGeometry({\n *   positions : positions\n * });"
  },
  {
    "className": "HeightmapTerrainData",
    "methodName": "HeightmapTerrainData",
    "description": "Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const buffer = ...\n * const heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * const childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * const waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * const terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n *"
  },
  {
    "className": "HeightmapTessellator",
    "methodName": "computeVertices",
    "description": "Fills an array of vertices from a heightmap image.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const width = 5;\n * const height = 5;\n * const statistics = Cesium.HeightmapTessellator.computeVertices({\n *     heightmap : [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0],\n *     width : width,\n *     height : height,\n *     skirtHeight : 0.0,\n *     nativeRectangle : {\n *         west : 10.0,\n *         east : 20.0,\n *         south : 30.0,\n *         north : 40.0\n *     }\n * });\n *\n * const encoding = statistics.encoding;\n * const position = encoding.decodePosition(statistics.vertices, index);"
  },
  {
    "className": "HermiteSpline",
    "methodName": "HermiteSpline",
    "description": "A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a G<sup>1</sup> continuous Hermite spline\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.HermiteSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     outTangents : [\n *         new Cesium.Cartesian3(1125196, -161816, 270551),\n *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),\n *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),\n *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)\n *     ],\n *     inTangents : [\n *         new Cesium.Cartesian3(-1993381, -731813, 368057),\n *         new Cesium.Cartesian3(-4193834, 96759, -585367),\n *         new Cesium.Cartesian3(-1781805, 817999, -894230),\n *         new Cesium.Cartesian3(1165345, 112641, 47281)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n *"
  },
  {
    "className": "HermiteSpline",
    "methodName": "createC1",
    "description": "Creates a spline where the tangents at each control point are the same.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const points = [\n *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n * ];\n *\n * // Add tangents\n * const tangents = new Array(points.length);\n * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);\n * const temp = new Cesium.Cartesian3();\n * for (let i = 1; i < tangents.length - 1; ++i) {\n *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());\n * }\n * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);\n *\n * const spline = Cesium.HermiteSpline.createC1({\n *     times : times,\n *     points : points,\n *     tangents : tangents\n * });"
  },
  {
    "className": "HermiteSpline",
    "methodName": "createNaturalCubic",
    "description": "Creates a natural cubic spline. The tangents at the control points are generated",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createNaturalCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });"
  },
  {
    "className": "HermiteSpline",
    "methodName": "createClampedCubic",
    "description": "Creates a clamped cubic spline. The tangents at the interior control points are generated",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createClampedCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),\n *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)\n * });"
  },
  {
    "className": "IndexDatatype",
    "methodName": "getSizeInBytes",
    "description": "Returns the size, in bytes, of the corresponding datatype.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns 2\n * const size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);"
  },
  {
    "className": "IndexDatatype",
    "methodName": "validate",
    "description": "Validates that the provided index datatype is a valid {@link IndexDatatype}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n * }"
  },
  {
    "className": "IndexDatatype",
    "methodName": "createTypedArray",
    "description": "Creates a typed array that will store indices, using either <code><Uint16Array</code>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);"
  },
  {
    "className": "IntersectionTests",
    "methodName": "lineSegmentPlane",
    "description": "Computes the intersection of a line segment and a plane.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * const intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);"
  },
  {
    "className": "IntersectionTests",
    "methodName": "trianglePlaneIntersection",
    "description": "Computes the intersection of a triangle and a plane",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n * const p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n * const triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);"
  },
  {
    "className": "Intersections2D",
    "methodName": "clipTriangleAtAxisAlignedThreshold",
    "description": "Splits a 2D triangle at given axis-aligned threshold value and returns the resulting",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);\n * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]"
  },
  {
    "className": "Intersections2D",
    "methodName": "computeBarycentricCoordinates",
    "description": "Compute the barycentric coordinates of a 2D position within a 2D triangle.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);\n * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);"
  },
  {
    "className": "Intersections2D",
    "methodName": "computeLineSegmentLineSegmentIntersection",
    "description": "Compute the intersection between 2 line segments",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);\n * // result === new Cesium.Cartesian2(0.0, 1.0);"
  },
  {
    "className": "IonResource",
    "methodName": "fromAssetId",
    "description": "Asynchronously creates an instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Load a Cesium3DTileset with asset ID of 124624234\n * try {\n *   const resource = await Cesium.IonResource.fromAssetId(124624234);\n *   const tileset = await Cesium.Cesium3DTileset.fromUrl(resource);\n *   scene.primitives.add(tileset);\n * } catch (error) {\n *   console.error(`Error creating tileset: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "LinearSpline",
    "methodName": "LinearSpline",
    "description": "A spline that uses piecewise linear interpolation to create a curve.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.LinearSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n *"
  },
  {
    "className": "Math",
    "methodName": "lerp",
    "description": "Computes the linear interpolation of two values.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0"
  },
  {
    "className": "Math",
    "methodName": "convertLongitudeRange",
    "description": "Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Convert 270 degrees to -90 degrees longitude\n * const longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));"
  },
  {
    "className": "Math",
    "methodName": "clampToLatitudeRange",
    "description": "Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Clamp 108 degrees latitude to 90 degrees latitude\n * const latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));"
  },
  {
    "className": "Math",
    "methodName": "equalsEpsilon",
    "description": "Determines if two values are equal using an absolute or relative tolerance test. This is useful",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true\n * const b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false\n * const c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true\n * const d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false"
  },
  {
    "className": "Math",
    "methodName": "factorial",
    "description": "Computes the factorial of the provided number.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Compute 7!, which is equal to 5040\n * const computedFactorial = Cesium.Math.factorial(7);\n *\n *"
  },
  {
    "className": "Math",
    "methodName": "incrementWrap",
    "description": "Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6\n * const m = Cesium.Math.incrementWrap(10, 10, 0); // returns 0"
  },
  {
    "className": "Math",
    "methodName": "isPowerOfTwo",
    "description": "Determines if a non-negative integer is a power of two.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const t = Cesium.Math.isPowerOfTwo(16); // true\n * const f = Cesium.Math.isPowerOfTwo(20); // false"
  },
  {
    "className": "Math",
    "methodName": "nextPowerOfTwo",
    "description": "Computes the next power-of-two integer greater than or equal to the provided non-negative integer.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const n = Cesium.Math.nextPowerOfTwo(29); // 32\n * const m = Cesium.Math.nextPowerOfTwo(32); // 32"
  },
  {
    "className": "Math",
    "methodName": "previousPowerOfTwo",
    "description": "Computes the previous power-of-two integer less than or equal to the provided non-negative integer.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const n = Cesium.Math.previousPowerOfTwo(29); // 16\n * const m = Cesium.Math.previousPowerOfTwo(32); // 32"
  },
  {
    "className": "Matrix2",
    "methodName": "fromArray",
    "description": "Creates a Matrix2 from 4 consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create the Matrix2:\n * // [1.0, 2.0]\n * // [1.0, 2.0]\n *\n * const v = [1.0, 1.0, 2.0, 2.0];\n * const m = Cesium.Matrix2.fromArray(v);\n *\n * // Create same Matrix2 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n * const m2 = Cesium.Matrix2.fromArray(v2, 2);"
  },
  {
    "className": "Matrix2",
    "methodName": "fromScale",
    "description": "Computes a Matrix2 instance representing a non-uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [7.0, 0.0]\n * //   [0.0, 8.0]\n * const m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));"
  },
  {
    "className": "Matrix2",
    "methodName": "fromUniformScale",
    "description": "Computes a Matrix2 instance representing a uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [2.0, 0.0]\n * //   [0.0, 2.0]\n * const m = Cesium.Matrix2.fromUniformScale(2.0);"
  },
  {
    "className": "Matrix2",
    "methodName": "fromRotation",
    "description": "Creates a rotation matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Rotate a point 45 degrees counterclockwise.\n * const p = new Cesium.Cartesian2(5, 6);\n * const m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());"
  },
  {
    "className": "Matrix2",
    "methodName": "getElementIndex",
    "description": "Computes the array index of the element at the provided row and column.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const myMatrix = new Cesium.Matrix2();\n * const column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;"
  },
  {
    "className": "Matrix2",
    "methodName": "multiplyByScale",
    "description": "Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix2",
    "methodName": "multiplyByUniformScale",
    "description": "Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromUniformScale(scale), m);\n * Cesium.Matrix2.multiplyByUniformScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix2",
    "methodName": "COLUMN0ROW0",
    "description": "The index into Matrix2 for column 0, row 0.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0"
  },
  {
    "className": "Matrix2",
    "methodName": "COLUMN0ROW1",
    "description": "The index into Matrix2 for column 0, row 1.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0"
  },
  {
    "className": "Matrix2",
    "methodName": "COLUMN1ROW0",
    "description": "The index into Matrix2 for column 1, row 0.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0"
  },
  {
    "className": "Matrix2",
    "methodName": "COLUMN1ROW1",
    "description": "The index into Matrix2 for column 1, row 1.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0"
  },
  {
    "className": "Matrix3",
    "methodName": "fromArray",
    "description": "Creates a Matrix3 from 9 consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create the Matrix3:\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n *\n * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m = Cesium.Matrix3.fromArray(v);\n *\n * // Create same Matrix3 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m2 = Cesium.Matrix3.fromArray(v2, 2);"
  },
  {
    "className": "Matrix3",
    "methodName": "fromScale",
    "description": "Computes a Matrix3 instance representing a non-uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [7.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0]\n * //   [0.0, 0.0, 9.0]\n * const m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));"
  },
  {
    "className": "Matrix3",
    "methodName": "fromUniformScale",
    "description": "Computes a Matrix3 instance representing a uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [2.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 2.0]\n * const m = Cesium.Matrix3.fromUniformScale(2.0);"
  },
  {
    "className": "Matrix3",
    "methodName": "fromCrossProduct",
    "description": "Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [0.0, -9.0,  8.0]\n * //   [9.0,  0.0, -7.0]\n * //   [-8.0, 7.0,  0.0]\n * const m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));"
  },
  {
    "className": "Matrix3",
    "methodName": "fromRotationX",
    "description": "Creates a rotation matrix around the x-axis.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Rotate a point 45 degrees counterclockwise around the x-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());"
  },
  {
    "className": "Matrix3",
    "methodName": "fromRotationY",
    "description": "Creates a rotation matrix around the y-axis.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Rotate a point 45 degrees counterclockwise around the y-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());"
  },
  {
    "className": "Matrix3",
    "methodName": "fromRotationZ",
    "description": "Creates a rotation matrix around the z-axis.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Rotate a point 45 degrees counterclockwise around the z-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());"
  },
  {
    "className": "Matrix3",
    "methodName": "getElementIndex",
    "description": "Computes the array index of the element at the provided row and column.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const myMatrix = new Cesium.Matrix3();\n * const column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;"
  },
  {
    "className": "Matrix3",
    "methodName": "multiplyByScale",
    "description": "Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix3",
    "methodName": "multiplyByUniformScale",
    "description": "Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromUniformScale(scale), m);\n * Cesium.Matrix3.multiplyByUniformScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix3",
    "methodName": "computeEigenDecomposition",
    "description": "Computes the eigenvectors and eigenvalues of a symmetric matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const a = //... symetric matrix\n * const result = {\n *     unitary : new Cesium.Matrix3(),\n *     diagonal : new Cesium.Matrix3()\n * };\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n * const b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n * const v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n * const c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)"
  },
  {
    "className": "Matrix4",
    "methodName": "fromArray",
    "description": "Creates a Matrix4 from 16 consecutive elements in an array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create the Matrix4:\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n *\n * const v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n * const m = Cesium.Matrix4.fromArray(v);\n *\n * // Create same Matrix4 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n * const m2 = Cesium.Matrix4.fromArray(v2, 2);"
  },
  {
    "className": "Matrix4",
    "methodName": "fromTranslationQuaternionRotationScale",
    "description": "Computes a Matrix4 instance from a translation, rotation, and scale (TRS)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(\n *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation\n *   Cesium.Quaternion.IDENTITY,           // rotation\n *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale\n *   result);"
  },
  {
    "className": "Matrix4",
    "methodName": "fromScale",
    "description": "Computes a Matrix4 instance representing a non-uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [7.0, 0.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0, 0.0]\n * //   [0.0, 0.0, 9.0, 0.0]\n * //   [0.0, 0.0, 0.0, 1.0]\n * const m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));"
  },
  {
    "className": "Matrix4",
    "methodName": "fromUniformScale",
    "description": "Computes a Matrix4 instance representing a uniform scale.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Creates\n * //   [2.0, 0.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0, 0.0]\n * //   [0.0, 0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 0.0, 1.0]\n * const m = Cesium.Matrix4.fromUniformScale(2.0);"
  },
  {
    "className": "Matrix4",
    "methodName": "computeViewportTransformation",
    "description": "Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create viewport transformation using an explicit viewport and depth range.\n * const m = Cesium.Matrix4.computeViewportTransformation({\n *     x : 0.0,\n *     y : 0.0,\n *     width : 1024.0,\n *     height : 768.0\n * }, 0.0, 1.0, new Cesium.Matrix4());"
  },
  {
    "className": "Matrix4",
    "methodName": "toArray",
    "description": "Computes an Array from the provided Matrix4 instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //create an array from an instance of Matrix4\n * // m = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n * const a = Cesium.Matrix4.toArray(m);\n *\n * // m remains the same\n * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "getElementIndex",
    "description": "Computes the array index of the element at the provided row and column.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const myMatrix = new Cesium.Matrix4();\n * const column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index];\n * myMatrix[column1Row0Index] = 10.0;"
  },
  {
    "className": "Matrix4",
    "methodName": "getColumn",
    "description": "Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //returns a Cartesian4 instance with values from the specified column\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * //Example 1: Creates an instance of Cartesian\n * const a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());\n *\n *"
  },
  {
    "className": "Matrix4",
    "methodName": "setColumn",
    "description": "Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //creates a new Matrix4 instance with new column values from the Cartesian4 instance\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 11.0, 99.0, 13.0]\n * //     [14.0, 15.0, 98.0, 17.0]\n * //     [18.0, 19.0, 97.0, 21.0]\n * //     [22.0, 23.0, 96.0, 25.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "getRow",
    "description": "Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //returns a Cartesian4 instance with values from the specified column\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * //Example 1: Returns an instance of Cartesian\n * const a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());\n *\n *"
  },
  {
    "className": "Matrix4",
    "methodName": "setRow",
    "description": "Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //create a new Matrix4 instance with new row values from the Cartesian4 instance\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [99.0, 98.0, 97.0, 96.0]\n * //     [22.0, 23.0, 24.0, 25.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyTransformation",
    "description": "Computes the product of two matrices assuming the matrices are affine transformation matrices,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n * const m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));\n * const m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByMatrix3",
    "description": "Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);\n * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByTranslation",
    "description": "Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);\n * Cesium.Matrix4.multiplyByTranslation(m, position, m);"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByScale",
    "description": "Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);\n * Cesium.Matrix4.multiplyByScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByUniformScale",
    "description": "Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);\n * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);\n *\n *"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByPointAsVector",
    "description": "Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());\n * // A shortcut for\n * //   Cartesian3 p = ...\n * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByPoint",
    "description": "Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());"
  },
  {
    "className": "Matrix4",
    "methodName": "multiplyByScalar",
    "description": "Computes the product of a matrix and a scalar.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //create a Matrix4 instance which is a scaled version of the supplied Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [-20.0, -22.0, -24.0, -26.0]\n * //     [-28.0, -30.0, -32.0, -34.0]\n * //     [-36.0, -38.0, -40.0, -42.0]\n * //     [-44.0, -46.0, -48.0, -50.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "negate",
    "description": "Computes a negated copy of the provided matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //create a new Matrix4 instance which is a negation of a Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [-10.0, -11.0, -12.0, -13.0]\n * //     [-14.0, -15.0, -16.0, -17.0]\n * //     [-18.0, -19.0, -20.0, -21.0]\n * //     [-22.0, -23.0, -24.0, -25.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "transpose",
    "description": "Computes the transpose of the provided matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //returns transpose of a Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]"
  },
  {
    "className": "Matrix4",
    "methodName": "equals",
    "description": "Compares the provided matrices componentwise and returns",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //compares two Matrix4 instances\n *\n * // a = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * // b = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * if(Cesium.Matrix4.equals(a,b)) {\n *      console.log(\"Both matrices are equal\");\n * } else {\n *      console.log(\"They are not equal\");\n * }\n *\n * //Prints \"Both matrices are equal\" on the console"
  },
  {
    "className": "Matrix4",
    "methodName": "equalsEpsilon",
    "description": "Compares the provided matrices componentwise and returns",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //compares two Matrix4 instances\n *\n * // a = [10.5, 14.5, 18.5, 22.5]\n * //     [11.5, 15.5, 19.5, 23.5]\n * //     [12.5, 16.5, 20.5, 24.5]\n * //     [13.5, 17.5, 21.5, 25.5]\n *\n * // b = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){\n *      console.log(\"Difference between both the matrices is less than 0.1\");\n * } else {\n *      console.log(\"Difference between both the matrices is not less than 0.1\");\n * }\n *\n * //Prints \"Difference between both the matrices is not less than 0.1\" on the console"
  },
  {
    "className": "Matrix4",
    "methodName": "getMatrix3",
    "description": "Gets the upper left 3x3 matrix of the provided matrix.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // returns a Matrix3 instance from a Matrix4 instance\n *\n * // m = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * const b = new Cesium.Matrix3();\n * Cesium.Matrix4.getMatrix3(m,b);\n *\n * // b = [10.0, 14.0, 18.0]\n * //     [11.0, 15.0, 19.0]\n * //     [12.0, 16.0, 20.0]"
  },
  {
    "className": "MorphWeightSpline",
    "methodName": "MorphWeightSpline",
    "description": "A spline that linearly interpolates over an array of weight values used by morph targets.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const weights = [0.0, 1.0, 0.25, 0.75, 0.5, 0.5, 0.75, 0.25, 1.0, 0.0]; //Two targets\n * const spline = new Cesium.WeightSpline({\n *     times : times,\n *     weights : weights\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n *"
  },
  {
    "className": "Occluder",
    "methodName": "Occluder",
    "description": "Creates an Occluder derived from an object's position and radius, as well as the camera position.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Construct an occluder one unit away from the origin with a radius of one.\n * const cameraPosition = Cesium.Cartesian3.ZERO;\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 1);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);"
  },
  {
    "className": "Occluder",
    "methodName": "isPointVisible",
    "description": "Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const point = new Cesium.Cartesian3(0, 0, -3);\n * occluder.isPointVisible(point); //returns true\n *\n *"
  },
  {
    "className": "Occluder",
    "methodName": "isBoundingSphereVisible",
    "description": "Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const bigSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -3), 1);\n * occluder.isBoundingSphereVisible(bigSphere); //returns true\n *\n *"
  },
  {
    "className": "Occluder",
    "methodName": "computeVisibility",
    "description": "Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const sphere1 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1.5), 0.5);\n * const sphere2 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -2.5), 0.5);\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluder = new Cesium.Occluder(sphere1, cameraPosition);\n * occluder.computeVisibility(sphere2); //returns Visibility.NONE"
  },
  {
    "className": "Occluder",
    "methodName": "computeOccludeePoint",
    "description": "Computes a point that can be used as the occludee position to the visibility functions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -8), 2);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n * const positions = [new Cesium.Cartesian3(-0.25, 0, -5.3), new Cesium.Cartesian3(0.25, 0, -5.3)];\n * const tileOccluderSphere = Cesium.BoundingSphere.fromPoints(positions);\n * const occludeePosition = tileOccluderSphere.center;\n * const occludeePt = Cesium.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);"
  },
  {
    "className": "OffsetGeometryInstanceAttribute",
    "methodName": "toValue",
    "description": "Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.modelMatrix = Cesium.OffsetGeometryInstanceAttribute.toValue(modelMatrix, attributes.modelMatrix);"
  },
  {
    "className": "OpenCageGeocoderService",
    "methodName": "OpenCageGeocoderService",
    "description": "Provides geocoding via a {@link https://opencagedata.com/|OpenCage} server.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Configure a Viewer to use the OpenCage Geocoder\n * const viewer = new Cesium.Viewer('cesiumContainer', {\n *   geocoder: new Cesium.OpenCageGeocoderService('https://api.opencagedata.com/geocode/v1/', '<API key>')\n * });"
  },
  {
    "className": "OrientedBoundingBox",
    "methodName": "OrientedBoundingBox",
    "description": "Creates an instance of an OrientedBoundingBox.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n *"
  },
  {
    "className": "OrientedBoundingBox",
    "methodName": "fromPoints",
    "description": "Computes an instance of an OrientedBoundingBox of the given positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Compute an object oriented bounding box enclosing two points.\n * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);"
  },
  {
    "className": "OrientedBoundingBox",
    "methodName": "distanceSquaredTo",
    "description": "Computes the estimated distance squared from the closest point on a bounding box to a point.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });"
  },
  {
    "className": "OrientedBoundingBox",
    "methodName": "distanceSquaredTo",
    "description": "Computes the estimated distance squared from the closest point on a bounding box to a point.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });"
  },
  {
    "className": "OrthographicFrustum",
    "methodName": "OrthographicFrustum",
    "description": "The viewing frustum is defined by 6 planes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicFrustum();\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;"
  },
  {
    "className": "OrthographicFrustum",
    "methodName": "computeCullingVolume",
    "description": "Creates a culling volume for this frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);"
  },
  {
    "className": "OrthographicFrustum",
    "methodName": "getPixelDimensions",
    "description": "Returns the pixel's width and height in meters.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());"
  },
  {
    "className": "OrthographicOffCenterFrustum",
    "methodName": "OrthographicOffCenterFrustum",
    "description": "The viewing frustum is defined by 6 planes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicOffCenterFrustum();\n * frustum.right = maxRadii * Cesium.Math.PI;\n * frustum.left = -c.frustum.right;\n * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);\n * frustum.bottom = -c.frustum.top;\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;"
  },
  {
    "className": "OrthographicOffCenterFrustum",
    "methodName": "computeCullingVolume",
    "description": "Creates a culling volume for this frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);"
  },
  {
    "className": "OrthographicOffCenterFrustum",
    "methodName": "getPixelDimensions",
    "description": "Returns the pixel's width and height in meters.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());"
  },
  {
    "className": "PeliasGeocoderService",
    "methodName": "PeliasGeocoderService",
    "description": "Provides geocoding via a {@link https://pelias.io/|Pelias} server.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Configure a Viewer to use the Pelias server hosted by https://geocode.earth/\n * const viewer = new Cesium.Viewer('cesiumContainer', {\n *   geocoder: new Cesium.PeliasGeocoderService(new Cesium.Resource({\n *     url: 'https://api.geocode.earth/v1/',\n *       queryParameters: {\n *         api_key: '<Your geocode.earth API key>'\n *     }\n *   }))\n * });"
  },
  {
    "className": "PerspectiveFrustum",
    "methodName": "PerspectiveFrustum",
    "description": "The viewing frustum is defined by 6 planes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const frustum = new Cesium.PerspectiveFrustum({\n *     fov : Cesium.Math.PI_OVER_THREE,\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\n *     near : 1.0,\n *     far : 1000.0\n * });\n *\n *"
  },
  {
    "className": "PerspectiveFrustum",
    "methodName": "computeCullingVolume",
    "description": "Creates a culling volume for this frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);"
  },
  {
    "className": "PerspectiveFrustum",
    "methodName": "getPixelDimensions",
    "description": "Returns the pixel's width and height in meters.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n *"
  },
  {
    "className": "PerspectiveOffCenterFrustum",
    "methodName": "PerspectiveOffCenterFrustum",
    "description": "The viewing frustum is defined by 6 planes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const frustum = new Cesium.PerspectiveOffCenterFrustum({\n *     left : -1.0,\n *     right : 1.0,\n *     top : 1.0,\n *     bottom : -1.0,\n *     near : 1.0,\n *     far : 100.0\n * });\n *\n *"
  },
  {
    "className": "PerspectiveOffCenterFrustum",
    "methodName": "computeCullingVolume",
    "description": "Creates a culling volume for this frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);"
  },
  {
    "className": "PerspectiveOffCenterFrustum",
    "methodName": "getPixelDimensions",
    "description": "Returns the pixel's width and height in meters.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n *"
  },
  {
    "className": "Plane",
    "methodName": "Plane",
    "description": "A plane in Hessian Normal Form defined by",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // The plane x=0\n * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n *\n *"
  },
  {
    "className": "Plane",
    "methodName": "fromPointNormal",
    "description": "Creates a plane from a normal and a point on the plane.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const normal = ellipsoid.geodeticSurfaceNormal(point);\n * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n *\n *"
  },
  {
    "className": "PlaneGeometry",
    "methodName": "PlaneGeometry",
    "description": "Describes geometry representing a plane centered at the origin, with a unit width and length.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const planeGeometry = new Cesium.PlaneGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n * });"
  },
  {
    "className": "PolygonGeometry",
    "methodName": "PolygonGeometry",
    "description": "A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. create a polygon from points\n * const polygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes\n * const polygonWithHole = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon\n * const extrudedPolygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);"
  },
  {
    "className": "PolygonGeometry",
    "methodName": "fromPositions",
    "description": "A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a polygon from points\n * const polygon = Cesium.PolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n *"
  },
  {
    "className": "PolygonOutlineGeometry",
    "methodName": "PolygonOutlineGeometry",
    "description": "A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. create a polygon outline from points\n * const polygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes outline\n * const polygonWithHole = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon outline\n * const extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);"
  },
  {
    "className": "PolygonOutlineGeometry",
    "methodName": "fromPositions",
    "description": "A description of a polygon outline from an array of positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a polygon from points\n * const polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n *"
  },
  {
    "className": "PolylineGeometry",
    "methodName": "PolylineGeometry",
    "description": "A description of a polyline modeled as a line strip; the first two positions define a line segment,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // A polyline with two connected line segments\n * const polyline = new Cesium.PolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ]),\n *   width : 10.0\n * });\n * const geometry = Cesium.PolylineGeometry.createGeometry(polyline);"
  },
  {
    "className": "PolylinePipeline",
    "methodName": "wrapLongitude",
    "description": "Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const polylines = new Cesium.PolylineCollection();\n * const polyline = polylines.add(...);\n * const positions = polyline.positions;\n * const modelMatrix = polylines.modelMatrix;\n * const segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n *\n *"
  },
  {
    "className": "PolylinePipeline",
    "methodName": "generateArc",
    "description": "Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateArc({\n *   positons: positions\n * });"
  },
  {
    "className": "PolylinePipeline",
    "methodName": "generateRhumbArc",
    "description": "Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n *   positons: positions\n * });"
  },
  {
    "className": "PolylinePipeline",
    "methodName": "generateCartesianArc",
    "description": "Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n *   positons: positions\n * });"
  },
  {
    "className": "PolylinePipeline",
    "methodName": "generateCartesianRhumbArc",
    "description": "Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n *   positons: positions\n * });"
  },
  {
    "className": "PolylineVolumeGeometry",
    "methodName": "PolylineVolumeGeometry",
    "description": "A description of a polyline with a volume (a 2D shape extruded along a polyline).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* function computeCircle(radius) {\n *   const positions = [];\n *   for (let i = 0; i < 360; i++) {\n *     const radians = Cesium.Math.toRadians(i);\n *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n *   }\n *   return positions;\n * }\n *\n * const volume = new Cesium.PolylineVolumeGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0\n *   ]),\n *   shapePositions : computeCircle(100000.0)\n * });"
  },
  {
    "className": "PolylineVolumeOutlineGeometry",
    "methodName": "PolylineVolumeOutlineGeometry",
    "description": "A description of a polyline with a volume (a 2D shape extruded along a polyline).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* function computeCircle(radius) {\n *   const positions = [];\n *   for (let i = 0; i < 360; i++) {\n *     const radians = Cesium.Math.toRadians(i);\n *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n *   }\n *   return positions;\n * }\n *\n * const volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({\n *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0\n *   ]),\n *   shapePositions : computeCircle(100000.0)\n * });"
  },
  {
    "className": "QuantizedMeshTerrainData",
    "methodName": "QuantizedMeshTerrainData",
    "description": "Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const data = new Cesium.QuantizedMeshTerrainData({\n *     minimumHeight : -100,\n *     maximumHeight : 2101,\n *     quantizedVertices : new Uint16Array([// order is SW NW SE NE\n *                                          // longitude\n *                                          0, 0, 32767, 32767,\n *                                          // latitude\n *                                          0, 32767, 0, 32767,\n *                                          // heights\n *                                          16384, 0, 32767, 16384]),\n *     indices : new Uint16Array([0, 3, 1,\n *                                0, 2, 3]),\n *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),\n *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),\n *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),\n *     westIndices : [0, 1],\n *     southIndices : [0, 1],\n *     eastIndices : [2, 3],\n *     northIndices : [1, 3],\n *     westSkirtHeight : 1.0,\n *     southSkirtHeight : 1.0,\n *     eastSkirtHeight : 1.0,\n *     northSkirtHeight : 1.0\n * });\n *\n *"
  },
  {
    "className": "Quaternion",
    "methodName": "squad",
    "description": "Computes the spherical quadrangle interpolation between quaternions.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. compute the squad interpolation between two quaternions on a curve\n * const s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());\n *\n * // 2. compute the squad interpolation as above but where the first quaternion is a end point.\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());\n *\n *"
  },
  {
    "className": "Ray",
    "methodName": "getPoint",
    "description": "Computes the point along the ray given by r(t) = o + t*d,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Get the first intersection point of a ray and an ellipsoid.\n * const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * const point = Cesium.Ray.getPoint(ray, intersection.start);"
  },
  {
    "className": "Rectangle",
    "methodName": "fromDegrees",
    "description": "Creates a rectangle given the boundary longitude and latitude in degrees.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);"
  },
  {
    "className": "Rectangle",
    "methodName": "fromRadians",
    "description": "Creates a rectangle given the boundary longitude and latitude in radians.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);"
  },
  {
    "className": "RectangleGeometry",
    "methodName": "RectangleGeometry",
    "description": "A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. create a rectangle\n * const rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.default,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n *\n * // 2. create an extruded rectangle without a top\n * const rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.default,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0,\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);"
  },
  {
    "className": "RectangleOutlineGeometry",
    "methodName": "RectangleOutlineGeometry",
    "description": "A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const rectangle = new Cesium.RectangleOutlineGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);"
  },
  {
    "className": "RequestScheduler",
    "methodName": "requestsByServer",
    "description": "A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* RequestScheduler.requestsByServer[\"myserver.com:443\"] = 18;\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "Resource",
    "description": "A resource that includes the location and any other parameters we need to retrieve it or create derived resources. It also provides the ability to retry requests.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* function refreshTokenRetryCallback(resource, error) {\n *   if (error.statusCode === 403) {\n *     // 403 status code means a new token should be generated\n *     return getNewAccessToken()\n *       .then(function(token) {\n *         resource.queryParameters.access_token = token;\n *         return true;\n *       })\n *       .catch(function() {\n *         return false;\n *       });\n *   }\n *\n *   return false;\n * }\n *\n * const resource = new Resource({\n *    url: 'http://server.com/path/to/resource.json',\n *    proxy: new DefaultProxy('/proxy/'),\n *    headers: {\n *      'X-My-Header': 'valueOfHeader'\n *    },\n *    queryParameters: {\n *      'access_token': '123-435-456-000'\n *    },\n *    retryCallback: refreshTokenRetryCallback,\n *    retryAttempts: 1\n * });"
  },
  {
    "className": "Resource",
    "methodName": "combineQueryParameters",
    "description": "This combines a map of query parameters.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const q1 = {\n *   a: 1,\n *   b: 2\n * };\n * const q2 = {\n *   a: 3,\n *   c: 4\n * };\n * const q3 = {\n *   b: [5, 6],\n *   d: 7\n * }\n *\n * // Returns\n * // {\n * //   a: [1, 3],\n * //   b: 2,\n * //   c: 4\n * // };\n * combineQueryParameters(q1, q2, true);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: 2,\n * //   c: 4\n * // };\n * combineQueryParameters(q1, q2, false);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: [2, 5, 6],\n * //   d: 7\n * // };\n * combineQueryParameters(q1, q3, true);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: 2,\n * //   d: 7\n * // };\n * combineQueryParameters(q1, q3, false);\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchArrayBuffer",
    "description": "Asynchronously loads the resource as raw binary data.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load a single URL asynchronously\n * resource.fetchArrayBuffer().then(function(arrayBuffer) {\n *     // use the data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchBlob",
    "description": "Asynchronously loads the given resource as a blob.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load a single URL asynchronously\n * resource.fetchBlob().then(function(blob) {\n *     // use the data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchImage",
    "description": "Asynchronously loads the given image resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load a single image asynchronously\n * resource.fetchImage().then(function(image) {\n *     // use the loaded image\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * // load several images in parallel\n * Promise.all([resource1.fetchImage(), resource2.fetchImage()]).then(function(images) {\n *     // images is an array containing all the loaded images\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchText",
    "description": "Asynchronously loads the given resource as text.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load text from a URL, setting a custom header\n * const resource = new Resource({\n *   url: 'http://someUrl.com/someJson.txt',\n *   headers: {\n *     'X-Custom-Header' : 'some value'\n *   }\n * });\n * resource.fetchText().then(function(text) {\n *     // Do something with the text\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchJson",
    "description": "Asynchronously loads the given resource as JSON.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.fetchJson().then(function(jsonData) {\n *     // Do something with the JSON object\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchXML",
    "description": "Asynchronously loads the given resource as XML.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load XML from a URL, setting a custom header\n * Cesium.loadXML('http://someUrl.com/someXML.xml', {\n *   'X-Custom-Header' : 'some value'\n * }).then(function(document) {\n *     // Do something with the document\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetchJsonp",
    "description": "Requests a resource using JSONP.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load a data asynchronously\n * resource.fetchJsonp().then(function(data) {\n *     // use the loaded data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "fetch",
    "description": "Asynchronously loads the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.fetch()\n *   .then(function(body) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "delete",
    "description": "Asynchronously deletes the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.delete()\n *   .then(function(body) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "head",
    "description": "Asynchronously gets headers the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.head()\n *   .then(function(headers) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "options",
    "description": "Asynchronously gets options the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.options()\n *   .then(function(headers) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "post",
    "description": "Asynchronously posts data to the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.post(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "put",
    "description": "Asynchronously puts data to the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.put(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "Resource",
    "methodName": "patch",
    "description": "Asynchronously patches data to the given resource.  Returns a promise that will resolve to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resource.patch(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n *"
  },
  {
    "className": "ScreenSpaceEventHandler",
    "methodName": "destroy",
    "description": "Removes listeners held by this object.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* handler = handler && handler.destroy();\n *\n *"
  },
  {
    "className": "ShowGeometryInstanceAttribute",
    "methodName": "ShowGeometryInstanceAttribute",
    "description": "Value and type information for per-instance geometry attribute that determines if the geometry instance will be shown.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.BoxGeometry({\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     show : new Cesium.ShowGeometryInstanceAttribute(false)\n *   }\n * });\n *\n *"
  },
  {
    "className": "ShowGeometryInstanceAttribute",
    "methodName": "toValue",
    "description": "Converts a boolean show to a typed array that can be used to assign a show attribute.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true, attributes.show);"
  },
  {
    "className": "SimplePolylineGeometry",
    "methodName": "SimplePolylineGeometry",
    "description": "A description of a polyline modeled as a line strip; the first two positions define a line segment,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // A polyline with two connected line segments\n * const polyline = new Cesium.SimplePolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ])\n * });\n * const geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);"
  },
  {
    "className": "SphereGeometry",
    "methodName": "SphereGeometry",
    "description": "A description of a sphere centered at the origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const sphere = new Cesium.SphereGeometry({\n *   radius : 100.0,\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n * });\n * const geometry = Cesium.SphereGeometry.createGeometry(sphere);"
  },
  {
    "className": "SphereOutlineGeometry",
    "methodName": "SphereOutlineGeometry",
    "description": "A description of the outline of a sphere.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const sphere = new Cesium.SphereOutlineGeometry({\n *   radius : 100.0,\n *   stackPartitions : 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.SphereOutlineGeometry.createGeometry(sphere);"
  },
  {
    "className": "SteppedSpline",
    "methodName": "SteppedSpline",
    "description": "A spline that is composed of piecewise constants representing a step function.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.SteppedSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n *"
  },
  {
    "className": "TaskProcessor",
    "methodName": "scheduleTask",
    "description": "Schedule a task to be processed by the web worker asynchronously.  If there are currently more",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const taskProcessor = new Cesium.TaskProcessor('myWorkerPath');\n * const promise = taskProcessor.scheduleTask({\n *     someParameter : true,\n *     another : 'hello'\n * });\n * if (!Cesium.defined(promise)) {\n *     // too many active tasks - try again later\n * } else {\n *     promise.then(function(result) {\n *         // use the result of the task\n *     });\n * }"
  },
  {
    "className": "TimeInterval",
    "methodName": "TimeInterval",
    "description": "An interval defined by a start and a stop time; optionally including those times as part of the interval.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create an instance that spans August 1st, 1980 and is associated\n * // with a Cartesian position.\n * const timeInterval = new Cesium.TimeInterval({\n *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),\n *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)\n * });\n *\n *"
  },
  {
    "className": "Tipsify",
    "methodName": "calculateACMR",
    "description": "Calculates the average cache miss ratio (ACMR) for a given set of indices.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const indices = [0, 1, 2, 3, 4, 5];\n * const maxIndex = 5;\n * const cacheSize = 3;\n * const acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});"
  },
  {
    "className": "Tipsify",
    "methodName": "tipsify",
    "description": "Optimizes triangles for the post-vertex shader cache.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const indices = [0, 1, 2, 3, 4, 5];\n * const maxIndex = 5;\n * const cacheSize = 3;\n * const reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});"
  },
  {
    "className": "Transforms",
    "methodName": "eastNorthUpToFixedFrame",
    "description": "Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);"
  },
  {
    "className": "Transforms",
    "methodName": "northEastDownToFixedFrame",
    "description": "Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northEastDownToFixedFrame(center);"
  },
  {
    "className": "Transforms",
    "methodName": "northUpEastToFixedFrame",
    "description": "Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northUpEastToFixedFrame(center);"
  },
  {
    "className": "Transforms",
    "methodName": "northWestUpToFixedFrame",
    "description": "Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northWestUpToFixedFrame(center);"
  },
  {
    "className": "Transforms",
    "methodName": "headingPitchRollToFixedFrame",
    "description": "Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);\n * const transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);"
  },
  {
    "className": "Transforms",
    "methodName": "headingPitchRollQuaternion",
    "description": "Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new HeadingPitchRoll(heading, pitch, roll);\n * const quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);"
  },
  {
    "className": "Transforms",
    "methodName": "computeIcrfToCentralBodyFixedMatrix",
    "description": "The default function to compute a rotation matrix to transform a point or vector from the International Celestial",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set the default ICRF to fixed transformation to that of the Moon.\n * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;\n *\n *"
  },
  {
    "className": "Transforms",
    "methodName": "computeTemeToPseudoFixedMatrix",
    "description": "Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Set the view to the inertial frame.\n * scene.postUpdate.addEventListener(function(scene, time) {\n *    const now = Cesium.JulianDate.now();\n *    const offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n *    const transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));\n *    const inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n *    camera.lookAtTransform(transform, offset);\n * });"
  },
  {
    "className": "Transforms",
    "methodName": "preloadIcrfFixed",
    "description": "Preloads the data necessary to transform between the ICRF and Fixed axes, in either",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const interval = new Cesium.TimeInterval(...);\n * await Cesium.Transforms.preloadIcrfFixed(interval));\n * // the data is now loaded\n *\n *"
  },
  {
    "className": "Transforms",
    "methodName": "computeIcrfToFixedMatrix",
    "description": "Computes a rotation matrix to transform a point or vector from the International Celestial",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.postUpdate.addEventListener(function(scene, time) {\n *   // View in ICRF.\n *   const icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);\n *   if (Cesium.defined(icrfToFixed)) {\n *     const offset = Cesium.Cartesian3.clone(camera.position);\n *     const transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);\n *     camera.lookAtTransform(transform, offset);\n *   }\n * });\n *\n *"
  },
  {
    "className": "Transforms",
    "methodName": "computeMoonFixedToIcrfMatrix",
    "description": "Computes a rotation matrix to transform a point or vector from the Moon-Fixed frame axes",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Transform a point from the Fixed axes to the ICRF axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeMoonFixedToIcrfMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }"
  },
  {
    "className": "Transforms",
    "methodName": "computeIcrfToMoonFixedMatrix",
    "description": "Computes a rotation matrix to transform a point or vector from the International Celestial",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set the default ICRF to fixed transformation to that of the Moon.\n * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;"
  },
  {
    "className": "Transforms",
    "methodName": "computeFixedToIcrfMatrix",
    "description": "Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Transform a point from the Fixed axes to the ICRF axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeFixedToIcrfMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n *\n *"
  },
  {
    "className": "TridiagonalSystemSolver",
    "methodName": "solve",
    "description": "Solves a tridiagonal system of linear equations.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const lowerDiagonal = [1.0, 1.0, 1.0, 1.0];\n * const diagonal = [2.0, 4.0, 4.0, 4.0, 2.0];\n * const upperDiagonal = [1.0, 1.0, 1.0, 1.0];\n * const rightHandSide = [\n *     new Cesium.Cartesian3(410757.0, -1595711.0, 1375302.0),\n *     new Cesium.Cartesian3(-5986705.0, -2190640.0, 1099600.0),\n *     new Cesium.Cartesian3(-12593180.0, 288588.0, -1755549.0),\n *     new Cesium.Cartesian3(-5349898.0, 2457005.0, -2685438.0),\n *     new Cesium.Cartesian3(845820.0, 1573488.0, -1205591.0)\n * ];\n *\n * const solution = Cesium.TridiagonalSystemSolver.solve(lowerDiagonal, diagonal, upperDiagonal, rightHandSide);\n *\n *"
  },
  {
    "className": "TrustedServers",
    "methodName": "add",
    "description": "Adds a trusted server to the registry",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Add a trusted server\n * TrustedServers.add('my.server.com', 80);"
  },
  {
    "className": "TrustedServers",
    "methodName": "remove",
    "description": "Removes a trusted server from the registry",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Remove a trusted server\n * TrustedServers.remove('my.server.com', 80);"
  },
  {
    "className": "TrustedServers",
    "methodName": "contains",
    "description": "Tests whether a server is trusted or not. The server must have been added with the port if it is included in the url.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Add server\n * TrustedServers.add('my.server.com', 81);\n *\n * // Check if server is trusted\n * if (TrustedServers.contains('https://my.server.com:81/path/to/file.png')) {\n *     // my.server.com:81 is trusted\n * }\n * if (TrustedServers.contains('https://my.server.com/path/to/file.png')) {\n *     // my.server.com isn't trusted\n * }"
  },
  {
    "className": "TrustedServers",
    "methodName": "clear",
    "description": "Clears the registry",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Remove a trusted server\n * TrustedServers.clear();"
  },
  {
    "className": "VRTheWorldTerrainProvider",
    "methodName": "VRTheWorldTerrainProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const terrainProvider = await Cesium.VRTheWorldTerrainProvider.fromUrl(\n *   \"https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/\"\n * );\n * viewer.terrainProvider = terrainProvider;\n *\n *"
  },
  {
    "className": "VRTheWorldTerrainProvider",
    "methodName": "fromUrl",
    "description": "Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const terrainProvider = await Cesium.VRTheWorldTerrainProvider.fromUrl(\n *   \"https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/\"\n * );\n * viewer.terrainProvider = terrainProvider;\n *\n *"
  },
  {
    "className": "VertexFormat",
    "methodName": "VertexFormat",
    "description": "A vertex format defines what attributes make up a vertex.  A VertexFormat can be provided",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a vertex format with position and 2D texture coordinate attributes.\n * const format = new Cesium.VertexFormat({\n *   position : true,\n *   st : true\n * });\n *\n *"
  },
  {
    "className": "WallGeometry",
    "methodName": "WallGeometry",
    "description": "A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a wall that spans from ground level to 10000 meters\n * const wall = new Cesium.WallGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *     19.0, 47.0, 10000.0,\n *     19.0, 48.0, 10000.0,\n *     20.0, 48.0, 10000.0,\n *     20.0, 47.0, 10000.0,\n *     19.0, 47.0, 10000.0\n *   ])\n * });\n * const geometry = Cesium.WallGeometry.createGeometry(wall);"
  },
  {
    "className": "WallGeometry",
    "methodName": "fromConstantHeights",
    "description": "A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a wall that spans from 10000 meters to 20000 meters\n * const wall = Cesium.WallGeometry.fromConstantHeights({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     19.0, 47.0,\n *     19.0, 48.0,\n *     20.0, 48.0,\n *     20.0, 47.0,\n *     19.0, 47.0,\n *   ]),\n *   minimumHeight : 20000.0,\n *   maximumHeight : 10000.0\n * });\n * const geometry = Cesium.WallGeometry.createGeometry(wall);\n *\n *"
  },
  {
    "className": "WallOutlineGeometry",
    "methodName": "WallOutlineGeometry",
    "description": "A description of a wall outline. A wall is defined by a series of points,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a wall outline that spans from ground level to 10000 meters\n * const wall = new Cesium.WallOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *     19.0, 47.0, 10000.0,\n *     19.0, 48.0, 10000.0,\n *     20.0, 48.0, 10000.0,\n *     20.0, 47.0, 10000.0,\n *     19.0, 47.0, 10000.0\n *   ])\n * });\n * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);"
  },
  {
    "className": "WallOutlineGeometry",
    "methodName": "fromConstantHeights",
    "description": "A description of a walloutline. A wall is defined by a series of points,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a wall that spans from 10000 meters to 20000 meters\n * const wall = Cesium.WallOutlineGeometry.fromConstantHeights({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     19.0, 47.0,\n *     19.0, 48.0,\n *     20.0, 48.0,\n *     20.0, 47.0,\n *     19.0, 47.0,\n *   ]),\n *   minimumHeight : 20000.0,\n *   maximumHeight : 10000.0\n * });\n * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n *\n *"
  },
  {
    "className": "addAllToArray",
    "methodName": "addAllToArray",
    "description": "Adds all elements from the given source array to the given target array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const target = [ 0, 1, 2 ];\n * const source = [ 3, 4, 5 ];\n * Cesium.addAllToArray(target, source);\n * // The target is now [ 0, 1, 2, 3, 4, 5 ]"
  },
  {
    "className": "arrayRemoveDuplicates",
    "methodName": "arrayRemoveDuplicates",
    "description": "Removes adjacent duplicate values in an array of values.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0), (1.0, 1.0, 1.0)]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon);\n *\n *"
  },
  {
    "className": "barycentricCoordinates",
    "methodName": "barycentricCoordinates",
    "description": "Computes the barycentric coordinates for a point with respect to a triangle.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns Cartesian3.UNIT_X\n * const p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);\n * const b = Cesium.barycentricCoordinates(p,\n *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));"
  },
  {
    "className": "binarySearch",
    "methodName": "binarySearch",
    "description": "Finds an item in a sorted array.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a comparator function to search through an array of numbers.\n * function comparator(a, b) {\n *     return a - b;\n * };\n * const numbers = [0, 2, 4, 6, 8];\n * const index = Cesium.binarySearch(numbers, 6, comparator); // 3"
  },
  {
    "className": "buildModuleUrl",
    "methodName": "buildModuleUrl",
    "description": "Given a relative URL under the Cesium base URL, returns an absolute URL.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(\n *     Cesium.TileMapServiceImageryProvider.fromUrl(\n *       Cesium.buildModuleUrl(\"Assets/Textures/NaturalEarthII\"),\n *     )),\n *   baseLayerPicker: false,\n * });"
  },
  {
    "className": "combine",
    "methodName": "combine",
    "description": "Merges two objects, copying their properties onto a new combined object. When two objects have the same",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const object1 = {\n *     propOne : 1,\n *     propTwo : {\n *         value1 : 10\n *     }\n * }\n * const object2 = {\n *     propTwo : 2\n * }\n * const final = Cesium.combine(object1, object2);\n *\n * // final === {\n * //     propOne : 1,\n * //     propTwo : {\n * //         value1 : 10\n * //     }\n * // }\n *\n *"
  },
  {
    "className": "createGuid",
    "methodName": "createGuid",
    "description": "Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* this.guid = Cesium.createGuid();\n *\n *"
  },
  {
    "className": "createWorldBathymetryAsync",
    "methodName": "createWorldBathymetryAsync",
    "description": "Creates a {@link CesiumTerrainProvider} instance for the {@link https://cesium.com/content/#cesium-world-bathymetry|Cesium World Bathymetry}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Cesium World Bathymetry with default settings\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.createWorldBathymetryAsync();\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "createWorldTerrainAsync",
    "methodName": "createWorldTerrainAsync",
    "description": "Creates a {@link CesiumTerrainProvider} instance for the {@link https://cesium.com/content/#cesium-world-terrain|Cesium World Terrain}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Cesium World Terrain with default settings\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.createWorldTerrainAsync();\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n *"
  },
  {
    "className": "defined",
    "methodName": "defined",
    "description": "@function",
    "parameters": [],
    "returnType": "unknown",
    "example": "* if (Cesium.defined(positions)) {\n *      doSomething();\n * } else {\n *      doSomethingElse();\n * }"
  },
  {
    "className": "deprecationWarning",
    "methodName": "deprecationWarning",
    "description": "Logs a deprecation message to the console.  Use this function instead of",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Deprecated function or class\n * function Foo() {\n *    deprecationWarning('Foo', 'Foo was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use newFoo instead.');\n *    // ...\n * }\n *\n * // Deprecated function\n * Bar.prototype.func = function() {\n *    deprecationWarning('Bar.func', 'Bar.func() was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newFunc() instead.');\n *    // ...\n * };\n *\n * // Deprecated property\n * Object.defineProperties(Bar.prototype, {\n *     prop : {\n *         get : function() {\n *             deprecationWarning('Bar.prop', 'Bar.prop was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newProp instead.');\n *             // ...\n *         },\n *         set : function(value) {\n *             deprecationWarning('Bar.prop', 'Bar.prop was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newProp instead.');\n *             // ...\n *         }\n *     }\n * });\n *\n *"
  },
  {
    "className": "destroyObject",
    "methodName": "destroyObject",
    "description": "Destroys an object.  Each of the object's functions, including functions in its prototype,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // How a texture would destroy itself.\n * this.destroy = function () {\n *     _gl.deleteTexture(_texture);\n *     return Cesium.destroyObject(this);\n * };\n *\n *"
  },
  {
    "className": "getAbsoluteUri",
    "methodName": "getAbsoluteUri",
    "description": "Given a relative Uri and a base Uri, returns the absolute Uri of the relative Uri.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //absolute Uri will be \"https://test.com/awesome.png\";\n * const absoluteUri = Cesium.getAbsoluteUri('awesome.png', 'https://test.com');"
  },
  {
    "className": "getBaseUri",
    "methodName": "getBaseUri",
    "description": "Given a URI, returns the base path of the URI.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // basePath will be \"/Gallery/\";\n * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false');\n *\n * // basePath will be \"/Gallery/?value=true&example=false\";\n * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false', true);"
  },
  {
    "className": "getExtensionFromUri",
    "methodName": "getExtensionFromUri",
    "description": "Given a URI, returns the extension of the URI.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //extension will be \"czml\";\n * const extension = Cesium.getExtensionFromUri('/Gallery/simple.czml?value=true&example=false');"
  },
  {
    "className": "getFilenameFromUri",
    "methodName": "getFilenameFromUri",
    "description": "Given a URI, returns the last segment of the URI, removing any path or query information.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //fileName will be\"simple.czml\";\n * const fileName = Cesium.getFilenameFromUri('/Gallery/simple.czml?value=true&example=false');"
  },
  {
    "className": "isLeapYear",
    "methodName": "isLeapYear",
    "description": "Determines if a given date is a leap year.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const leapYear = Cesium.isLeapYear(2000); // true"
  },
  {
    "className": "loadKTX2",
    "methodName": "loadKTX2",
    "description": "Asynchronously loads and parses the given URL to a KTX2 file or parses the raw binary data of a KTX2 file.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load a single URL asynchronously\n * Cesium.loadKTX2('some/url').then(function (ktx2Data) {\n *     const width = ktx2Data.width;\n *     const height = ktx2Data.height;\n *     const format = ktx2Data.internalFormat;\n *     const arrayBufferView = ktx2Data.bufferView;\n *     // use the data to create a texture\n * }).catch(function (error) {\n *     // an error occurred.\n * });\n *\n *"
  },
  {
    "className": "mergeSort",
    "methodName": "mergeSort",
    "description": "A stable merge sort.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Assume array contains BoundingSpheres in world coordinates.\n * // Sort them in ascending order of distance from the camera.\n * const position = camera.positionWC;\n * Cesium.mergeSort(array, function(a, b, position) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, position) - Cesium.BoundingSphere.distanceSquaredTo(a, position);\n * }, position);"
  },
  {
    "className": "objectToQuery",
    "methodName": "objectToQuery",
    "description": "Converts an object representing a set of name/value pairs into a query string,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const str = Cesium.objectToQuery({\n *     key1 : 'some value',\n *     key2 : 'a/b',\n *     key3 : ['x', 'y']\n * });\n *\n *"
  },
  {
    "className": "oneTimeWarning",
    "methodName": "oneTimeWarning",
    "description": "Logs a one time message to the console.  Use this function instead of",
    "parameters": [],
    "returnType": "unknown",
    "example": "* for(let i=0;i<foo.length;++i) {\n *    if (!defined(foo[i].bar)) {\n *       // Something that can be recovered from but may happen a lot\n *       oneTimeWarning('foo.bar undefined', 'foo.bar is undefined. Setting to 0.');\n *       foo[i].bar = 0;\n *       // ...\n *    }\n * }\n *\n *"
  },
  {
    "className": "pointInsideTriangle",
    "methodName": "pointInsideTriangle",
    "description": "Determines if a point is inside a triangle.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns true\n * const p = new Cesium.Cartesian2(0.25, 0.25);\n * const b = Cesium.pointInsideTriangle(p,\n *   new Cesium.Cartesian2(0.0, 0.0),\n *   new Cesium.Cartesian2(1.0, 0.0),\n *   new Cesium.Cartesian2(0.0, 1.0));"
  },
  {
    "className": "queryToObject",
    "methodName": "queryToObject",
    "description": "Parses a query string into an object, where the keys and values of the object are the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const obj = Cesium.queryToObject('key1=some%20value&key2=a%2Fb&key3=x&key3=y');\n * // obj will be:\n * // {\n * //   key1 : 'some value',\n * //   key2 : 'a/b',\n * //   key3 : ['x', 'y']\n * // }\n *\n *"
  },
  {
    "className": "sampleTerrain",
    "methodName": "sampleTerrain",
    "description": "Initiates a terrain height query for an array of {@link Cartographic} positions by",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Query the terrain height of two Cartographic positions\n * const terrainProvider = await Cesium.createWorldTerrainAsync();\n * const positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions);\n * // positions[0].height and positions[1].height have been updated.\n * // updatedPositions is just a reference to positions.\n *\n * // To handle tile errors, pass true for the rejectOnTileFail parameter.\n * try {\n *    const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions, true);\n * } catch (error) {\n *   // A tile request error occurred.\n * }"
  },
  {
    "className": "sampleTerrainMostDetailed",
    "methodName": "sampleTerrainMostDetailed",
    "description": "Initiates a sampleTerrain() request at the maximum available tile level for a terrain dataset.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Query the terrain height of two Cartographic positions\n * const terrainProvider = await Cesium.createWorldTerrainAsync();\n * const positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions);\n * // positions[0].height and positions[1].height have been updated.\n * // updatedPositions is just a reference to positions.\n *\n * // To handle tile errors, pass true for the rejectOnTileFail parameter.\n * try {\n *    const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions, true);\n * } catch (error) {\n *   // A tile request error occurred.\n * }"
  },
  {
    "className": "srgbToLinear",
    "methodName": "srgbToLinear",
    "description": "Converts the value from sRGB color space to linear color space.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const srgbColor = [0.5, 0.5, 0.5];\n * const linearColor = srgbColor.map(function (c) {\n *     return Cesium.srgbToLinear(c);\n * });"
  },
  {
    "className": "CompositeProperty",
    "methodName": "CompositeProperty",
    "description": "A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const constantProperty = ...;\n * const sampledProperty = ...;\n *\n * //Create a composite property from two previously defined properties\n * //where the property is valid on August 1st, 2012 and uses a constant\n * //property for the first half of the day and a sampled property for the\n * //remaining half.\n * const composite = new Cesium.CompositeProperty();\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',\n *     data : constantProperty\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',\n *     isStartIncluded : false,\n *     isStopIncluded : false,\n *     data : sampledProperty\n * }));\n *\n *"
  },
  {
    "className": "CustomDataSource",
    "methodName": "CustomDataSource",
    "description": "A {@link DataSource} implementation which can be used to manually manage a group of entities.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const dataSource = new Cesium.CustomDataSource('myData');\n *\n * const entity = dataSource.entities.add({\n *    position : Cesium.Cartesian3.fromDegrees(1, 2, 0),\n *    billboard : {\n *        image : 'image.png'\n *    }\n * });\n *\n * viewer.dataSources.add(dataSource);"
  },
  {
    "className": "DataSourceCollection",
    "methodName": "destroy",
    "description": "Destroys the resources held by all data sources in this collection.  Explicitly destroying this",
    "parameters": [],
    "returnType": "unknown",
    "example": "* dataSourceCollection = dataSourceCollection && dataSourceCollection.destroy();\n *\n *"
  },
  {
    "className": "DataSourceDisplay",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* dataSourceDisplay = dataSourceDisplay.destroy();\n *\n *"
  },
  {
    "className": "GeoJsonDataSource",
    "methodName": "GeoJsonDataSource",
    "description": "A {@link DataSource} which processes both",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.GeoJsonDataSource.load('../../SampleData/ne_10m_us_states.topojson', {\n *   stroke: Cesium.Color.HOTPINK,\n *   fill: Cesium.Color.PINK,\n *   strokeWidth: 3,\n *   markerSymbol: '?'\n * }));"
  },
  {
    "className": "GpxDataSource",
    "methodName": "GpxDataSource",
    "description": "A {@link DataSource} which processes the GPS Exchange Format (GPX).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.GpxDataSource.load('../../SampleData/track.gpx'));"
  },
  {
    "className": "KmlDataSource",
    "methodName": "KmlDataSource",
    "description": "A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',\n *      {\n *           camera: viewer.scene.camera,\n *           canvas: viewer.scene.canvas\n *      })\n * );"
  },
  {
    "className": "ReferenceProperty",
    "methodName": "ReferenceProperty",
    "description": "A {@link Property} which transparently links to another property on a provided object.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const collection = new Cesium.EntityCollection();\n *\n * //Create a new entity and assign a billboard scale.\n * const object1 = new Cesium.Entity({id:'object1'});\n * object1.billboard = new Cesium.BillboardGraphics();\n * object1.billboard.scale = new Cesium.ConstantProperty(2.0);\n * collection.add(object1);\n *\n * //Create a second entity and reference the scale from the first one.\n * const object2 = new Cesium.Entity({id:'object2'});\n * object2.model = new Cesium.ModelGraphics();\n * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);\n * collection.add(object2);\n *\n * //Create a third object, but use the fromString helper function.\n * const object3 = new Cesium.Entity({id:'object3'});\n * object3.billboard = new Cesium.BillboardGraphics();\n * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');\n * collection.add(object3);\n *\n * //You can refer to an entity with a # or . in id and property names by escaping them.\n * const object4 = new Cesium.Entity({id:'#object.4'});\n * object4.billboard = new Cesium.BillboardGraphics();\n * object4.billboard.scale = new Cesium.ConstantProperty(2.0);\n * collection.add(object4);\n *\n * const object5 = new Cesium.Entity({id:'object5'});\n * object5.billboard = new Cesium.BillboardGraphics();\n * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\\\#object\\\\.4#billboard.scale');\n * collection.add(object5);"
  },
  {
    "className": "Rotation",
    "methodName": "Rotation",
    "description": "Represents a {@link Packable} number that always interpolates values",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const time1 = Cesium.JulianDate.fromIso8601('2010-05-07T00:00:00');\n * const time2 = Cesium.JulianDate.fromIso8601('2010-05-07T00:01:00');\n * const time3 = Cesium.JulianDate.fromIso8601('2010-05-07T00:02:00');\n *\n * const property = new Cesium.SampledProperty(Cesium.Rotation);\n * property.addSample(time1, 0);\n * property.addSample(time3, Cesium.Math.toRadians(350));\n *\n * //Getting the value at time2 will equal 355 degrees instead\n * //of 175 degrees (which is what you get if you construct\n * //a SampledProperty(Number) instead.  Note, the actual\n * //return value is in radians, not degrees.\n * property.getValue(time2);\n *\n *"
  },
  {
    "className": "SampledProperty",
    "methodName": "SampledProperty",
    "description": "A {@link Property} whose value is interpolated for a given time from the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create a linearly interpolated Cartesian2\n * const property = new Cesium.SampledProperty(Cesium.Cartesian2);\n *\n * //Populate it with data\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), new Cesium.Cartesian2(0, 0));\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-02T00:00:00.00Z'), new Cesium.Cartesian2(4, 7));\n *\n * //Retrieve an interpolated value\n * const result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T12:00:00.00Z'));\n *\n *"
  },
  {
    "className": "TimeIntervalCollectionProperty",
    "methodName": "TimeIntervalCollectionProperty",
    "description": "A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create a Cartesian2 interval property which contains data on August 1st, 2012\n * //and uses a different value every 6 hours.\n * const composite = new Cesium.TimeIntervalCollectionProperty();\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T06:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(2.0, 3.4)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T06:00:00.00Z/2012-08-01T12:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(12.0, 2.7)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-01T18:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(5.0, 12.4)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T18:00:00.00Z/2012-08-02T00:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : true,\n *     data : new Cesium.Cartesian2(85.0, 4.1)\n * }));"
  },
  {
    "className": "VelocityOrientationProperty",
    "methodName": "VelocityOrientationProperty",
    "description": "A {@link Property} which evaluates to a {@link Quaternion} rotation",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create an entity with position and orientation.\n * const position = new Cesium.SampledProperty();\n * position.addSamples(...);\n * const entity = viewer.entities.add({\n *   position : position,\n *   orientation : new Cesium.VelocityOrientationProperty(position)\n * }));"
  },
  {
    "className": "VelocityVectorProperty",
    "methodName": "VelocityVectorProperty",
    "description": "A {@link Property} which evaluates to a {@link Cartesian3} vector",
    "parameters": [],
    "returnType": "unknown",
    "example": "* //Create an entity with a billboard rotated to match its velocity.\n * const position = new Cesium.SampledProperty();\n * position.addSamples(...);\n * const entity = viewer.entities.add({\n *   position : position,\n *   billboard : {\n *     image : 'image.png',\n *     alignedAxis : new Cesium.VelocityVectorProperty(position, true) // alignedAxis must be a unit vector\n *   }\n * }));"
  },
  {
    "className": "exportKml",
    "methodName": "exportKml",
    "description": "Exports an EntityCollection as a KML document. Only Point, Billboard, Model, Path, Polygon, Polyline geometries",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.exportKml({\n *      entities: entityCollection\n *  })\n *   .then(function(result) {\n *     // The XML string is in result.kml\n *\n *     const externalFiles = result.externalFiles\n *     for(const file in externalFiles) {\n *       // file is the name of the file used in the KML document as the href\n *       // externalFiles[file] is a blob with the contents of the file\n *     }\n *   });\n *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec4 czm_viewport;\n   *\n   * // Scale the window coordinate components to [0, 1] by dividing\n   * // by the viewport's width and height.\n   * vec2 v = gl_FragCoord.xy / czm_viewport.zw;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 orthographic projection matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_viewportOrthographic;\n   *\n   * // Example\n   * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_viewportTransformation;\n   *\n   * // Use czm_viewportTransformation as part of the\n   * // transform from model to window coordinates.\n   * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates\n   * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)\n   * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the depth of the scene",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform sampler2D czm_globeDepthTexture;\n   *\n   * // Get the depth at the current fragment\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * float depth = czm_unpackDepth(texture(czm_globeDepthTexture, coords));"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a texture containing edge IDs",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform sampler2D czm_edgeIdTexture;\n   *\n   * // Get the edge ID at the current fragment\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * vec4 edgeId = texture(czm_edgeIdTexture, coords);"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the edge color texture.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform sampler2D czm_edgeColorTexture;\n   *\n   * // Sample the edge color at the current fragment\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * vec4 edgeColor = texture(czm_edgeColorTexture, coords);"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the packed depth texture produced by the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform sampler2D czm_edgeDepthTexture;\n   *\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * float d = czm_unpackDepth(texture(czm_edgeDepthTexture, coords));"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_model;\n   *\n   * // Example\n   * vec4 worldPosition = czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseModel;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModel * worldPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 view transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_view;\n   *\n   * // Example\n   * vec4 eyePosition = czm_view * worldPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 view transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_view3D;\n   *\n   * // Example\n   * vec4 eyePosition3D = czm_view3D * worldPosition3D;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 view rotation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_viewRotation;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation * worldVector;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 view rotation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_viewRotation3D;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation3D * worldVector;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseView;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseView3D;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView3D * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 rotation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation * eyeVector;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 rotation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation3D;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation3D * eyeVector;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_projection;\n   *\n   * // Example\n   * gl_Position = czm_projection * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseProjection;\n   *\n   * // Example\n   * vec4 eyePosition = czm_inverseProjection * clipPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_infiniteProjection;\n   *\n   * // Example\n   * gl_Position = czm_infiniteProjection * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelView;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view * czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelView3D;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView3D * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view3D * czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelViewRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);\n   * }\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseModelView;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseModelView3D;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView3D * eyePosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_viewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseViewProjection;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseViewProjection * clipPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelViewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 inverse model-view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_inverseModelViewProjection;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelViewProjection * clipPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelViewProjectionRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n   * }\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat4 czm_modelViewInfiniteProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 normal transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_normal;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal * normal;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 normal transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_normal3D;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal3D * normal;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 normal transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_inverseNormal;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal * normalEC;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 normal transformation matrix that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_inverseNormal3D;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal3D * normalEC;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec2 czm_entireFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec2 czm_currentFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_currentFrustum.y - czm_currentFrustum.x;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the sun position in world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_sunPositionWC;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the sun position in Columbus view world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_sunPositionColumbusView;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_sunDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_sunDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionWC, normalWC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_moonDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the normalized direction to the scene's light source in eye coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_lightDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionEC, normalEC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the normalized direction to the scene's light source in world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_lightDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform that represents the color of light emitted by the scene's light source. This",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_lightColor;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColor * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform that represents the high dynamic range color of light emitted by the scene's light",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_lightColorHdr;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColorHdr * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the high bits of the camera position in model",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCHigh;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the low bits of the camera position in model",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCLow;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3 czm_viewerPositionWC;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the frame number. This uniform is automatically incremented",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_frameNumber;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the current morph transition time between",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_morphTime;\n   *\n   * // Example\n   * vec4 p = czm_columbusViewMorph(position2D, position3D, czm_morphTime);"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the current {@link SceneMode}, expressed",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_sceneMode;\n   *\n   * // Example\n   * if (czm_sceneMode == czm_sceneMode2D)\n   * {\n   *     eyeHeightSq = czm_eyeHeight2D.y;\n   * }\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the current rendering pass.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_pass;\n   *\n   * // Example\n   * if ((czm_pass == czm_passTranslucent) && isOpaque())\n   * {\n   *     gl_Position *= 0.0; // Cull opaque geometry in the translucent pass\n   * }"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the current scene background color.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec4 czm_backgroundColor;\n   *\n   * // Example: If the given color's RGB matches the background color, invert it.\n   * vec4 adjustColorForContrast(vec4 color)\n   * {\n   *     if (czm_backgroundColor.rgb == color.rgb)\n   *     {\n   *         color.rgb = vec3(1.0) - color.rgb;\n   *     }\n   *\n   *     return color;\n   * }"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the BRDF look up texture used for image-based lighting computations.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform sampler2D czm_brdfLut;\n   *\n   * // Example: For a given roughness and NdotV value, find the material's BRDF information in the red and green channels\n   * float roughness = 0.5;\n   * float NdotV = dot(normal, view);\n   * vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the environment map used within the scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform samplerCube czm_environmentMap;\n   *\n   * // Example: Create a perfect reflection of the environment map on a  model\n   * float reflected = reflect(view, normal);\n   * vec4 reflectedColor = texture(czm_environmentMap, reflected);"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the specular environment cube map used within the scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform samplerCube czm_specularEnvironmentMaps;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the maximum valid level-of-detail of the specular environment cube map used within the scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_specularEnvironmentMapsMaximumLOD;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform containing the spherical harmonic coefficients used within the scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform vec3[9] czm_sphericalHarmonicCoefficients;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing a 3x3 rotation matrix that transforms",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform mat3 czm_temeToPseudoFixed;\n   *\n   * // Example\n   * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;\n   *\n   *"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the ratio of canvas coordinate space to canvas pixel space.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform float czm_pixelRatio;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the color shift for the atmosphere in HSB color space",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform vec3 czm_atmosphereHsbShift;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the intensity of the light that is used for computing the atmosphere color",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform float czm_atmosphereLightIntensity;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the Rayleigh scattering coefficient used when computing the atmosphere scattering",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform vec3 czm_atmosphereRayleighCoefficient;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the Rayleigh scale height in meters used for computing atmosphere scattering.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform vec3 czm_atmosphereRayleighScaleHeight;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the Mie scattering coefficient used when computing atmosphere scattering.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform vec3 czm_atmosphereMieCoefficient;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform storign the Mie scale height used when computing atmosphere scattering.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform float czm_atmosphereMieScaleHeight;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing the anisotropy of the medium to consider for Mie scattering.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform float czm_atmosphereAnisotropy;"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic uniform representing which light source to use for dynamic lighting",
    "parameters": [],
    "returnType": "unknown",
    "example": "* uniform float czm_atmosphereDynamicLighting"
  },
  {
    "className": "AutomaticUniforms",
    "methodName": "AutomaticUniform",
    "description": "An automatic GLSL uniform representing the splitter position to use when rendering with a splitter.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // GLSL declaration\n   * uniform float czm_splitPosition;"
  },
  {
    "className": "Buffer",
    "methodName": "createVertexBuffer",
    "description": "Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Create a dynamic vertex buffer 16 bytes in size.\n * const buffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.DYNAMIC_DRAW\n * });\n *\n *"
  },
  {
    "className": "Buffer",
    "methodName": "createIndexBuffer",
    "description": "Creates an index buffer, which contains typed indices in GPU-controlled memory.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Create a stream index buffer of unsigned shorts that is\n * // 16 bytes in size.\n * const buffer = Buffer.createIndexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.STREAM_DRAW,\n *     indexDatatype : IndexDatatype.UNSIGNED_SHORT\n * });\n *\n *"
  },
  {
    "className": "Context",
    "methodName": "getObjectByPickColor",
    "description": "Gets the object associated with a pick color.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const object = context.getObjectByPickColor(pickColor);\n *\n *"
  },
  {
    "className": "Context",
    "methodName": "createPickId",
    "description": "Creates a unique ID associated with the input object for use with color-buffer picking.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* this._pickId = context.createPickId({\n *   primitive : this,\n *   id : this.id\n * });\n *\n *"
  },
  {
    "className": "CubeMap",
    "methodName": "generateMipmap",
    "description": "Generates a complete mipmap chain for each cubemap face.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Generate mipmaps, and then set the sampler so mipmaps are used for\n * // minification when the cube map is sampled.\n * cubeMap.generateMipmap();\n * cubeMap.sampler = new Sampler({\n *   minificationFilter : Cesium.TextureMinificationFilter.NEAREST_MIPMAP_LINEAR\n * });"
  },
  {
    "className": "CubeMapFace",
    "methodName": "copyFrom",
    "description": "Copies texels from the source to the cubemap's face.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a cubemap with 1x1 faces, and make the +x face red.\n * const cubeMap = new CubeMap({\n *   context : context\n *   width : 1,\n *   height : 1\n * });\n * cubeMap.positiveX.copyFrom({\n *   source: {\n *     width : 1,\n *     height : 1,\n *     arrayBufferView : new Uint8Array([255, 0, 0, 255])\n *   }\n * });"
  },
  {
    "className": "CubeMapFace",
    "methodName": "copyFromFramebuffer",
    "description": "Copies texels from the framebuffer to the cubemap's face.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Copy the framebuffer contents to the +x cube map face.\n * cubeMap.positiveX.copyFromFramebuffer();"
  },
  {
    "className": "CubeMapFace",
    "methodName": "copyMipmapFromFramebuffer",
    "description": "Copies texels from the framebuffer to the cubemap's face mipmap.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Copy the framebuffer contents to the +x cube map face.\n * cubeMap.positiveX.copyFromFramebuffer();"
  },
  {
    "className": "Framebuffer",
    "methodName": "Framebuffer",
    "description": "Creates a framebuffer with optional initial color, depth, and stencil attachments.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a framebuffer with color and depth texture attachments.\n * const width = context.canvas.clientWidth;\n * const height = context.canvas.clientHeight;\n * const framebuffer = new Framebuffer({\n *   context : context,\n *   colorTextures : [new Texture({\n *     context : context,\n *     width : width,\n *     height : height,\n *     pixelFormat : PixelFormat.RGBA\n *   })],\n *   depthTexture : new Texture({\n *     context : context,\n *     width : width,\n *     height : height,\n *     pixelFormat : PixelFormat.DEPTH_COMPONENT,\n *     pixelDatatype : PixelDatatype.UNSIGNED_SHORT\n *   })\n * });\n *\n *"
  },
  {
    "className": "RenderState",
    "methodName": "fromCache",
    "description": "Validates and then finds or creates an immutable render state, which defines the pipeline",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const defaults = {\n *     frontFace : WindingOrder.COUNTER_CLOCKWISE,\n *     cull : {\n *         enabled : false,\n *         face : CullFace.BACK\n *     },\n *     lineWidth : 1,\n *     polygonOffset : {\n *         enabled : false,\n *         factor : 0,\n *         units : 0\n *     },\n *     scissorTest : {\n *         enabled : false,\n *         rectangle : {\n *             x : 0,\n *             y : 0,\n *             width : 0,\n *             height : 0\n *         }\n *     },\n *     depthRange : {\n *         near : 0,\n *         far : 1\n *     },\n *     depthTest : {\n *         enabled : false,\n *         func : DepthFunction.LESS\n *      },\n *     colorMask : {\n *         red : true,\n *         green : true,\n *         blue : true,\n *         alpha : true\n *     },\n *     depthMask : true,\n *     stencilMask : ~0,\n *     blending : {\n *         enabled : false,\n *         color : {\n *             red : 0.0,\n *             green : 0.0,\n *             blue : 0.0,\n *             alpha : 0.0\n *         },\n *         equationRgb : BlendEquation.ADD,\n *         equationAlpha : BlendEquation.ADD,\n *         functionSourceRgb : BlendFunction.ONE,\n *         functionSourceAlpha : BlendFunction.ONE,\n *         functionDestinationRgb : BlendFunction.ZERO,\n *         functionDestinationAlpha : BlendFunction.ZERO\n *     },\n *     stencilTest : {\n *         enabled : false,\n *         frontFunction : StencilFunction.ALWAYS,\n *         backFunction : StencilFunction.ALWAYS,\n *         reference : 0,\n *         mask : ~0,\n *         frontOperation : {\n *             fail : StencilOperation.KEEP,\n *             zFail : StencilOperation.KEEP,\n *             zPass : StencilOperation.KEEP\n *         },\n *         backOperation : {\n *             fail : StencilOperation.KEEP,\n *             zFail : StencilOperation.KEEP,\n *             zPass : StencilOperation.KEEP\n *         }\n *     },\n *     sampleCoverage : {\n *         enabled : false,\n *         value : 1.0,\n *         invert : false\n *      }\n * };\n *\n * const rs = RenderState.fromCache(defaults);\n *\n *"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "ShaderBuilder",
    "description": "An object that makes it easier to build the text of a {@link ShaderProgram}. This tracks GLSL code for both the vertex shader and the fragment shader.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const shaderBuilder = new ShaderBuilder();\n * shaderBuilder.addDefine(\"SOLID_COLOR\", undefined, ShaderDestination.FRAGMENT);\n * shaderBuilder.addUniform(\"vec3\", \"u_color\", ShaderDestination.FRAGMENT);\n * shaderBuilder.addVarying(\"vec3\", v_color\");\n * // These locations can be used when creating the VertexArray\n * const positionLocation = shaderBuilder.addPositionAttribute(\"vec3\", \"a_position\");\n * const colorLocation = shaderBuilder.addAttribute(\"vec3\", \"a_color\");\n * shaderBuilder.addVertexLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    v_color = a_color;\",\n *  \"    gl_Position = vec4(a_position, 1.0);\",\n *  \"}\"\n * ]);\n * shaderBuilder.addFragmentLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    #ifdef SOLID_COLOR\",\n *  \"    out_FragColor = vec4(u_color, 1.0);\",\n *  \"    #else\",\n *  \"    out_FragColor = vec4(v_color, 1.0);\",\n *  \"    #endif\",\n *  \"}\"\n * ]);\n * const shaderProgram = shaderBuilder.build(context);\n *\n *"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addDefine",
    "description": "Add a <code>#define</code> macro to one or both of the shaders. These lines",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates the line \"#define ENABLE_LIGHTING\" in both shaders\n * shaderBuilder.addDefine(\"ENABLE_LIGHTING\");\n * // creates the line \"#define PI 3.141592\" in the fragment shader\n * shaderBuilder.addDefine(\"PI\", 3.141593, ShaderDestination.FRAGMENT);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addStruct",
    "description": "Add a new dynamically-generated struct to the shader",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // generates the following struct in the fragment shader\n * // struct TestStruct\n * // {\n * // };\n * shaderBuilder.addStruct(\"testStructId\", \"TestStruct\", ShaderDestination.FRAGMENT);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addStructField",
    "description": "Add a field to a dynamically-generated struct.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // generates the following struct in the fragment shader\n * // struct TestStruct\n * // {\n * //    float minimum;\n * //    float maximum;\n * // };\n * shaderBuilder.addStruct(\"testStructId\", \"TestStruct\", ShaderDestination.FRAGMENT);\n * shaderBuilder.addStructField(\"testStructId\", \"float\", \"maximum\");\n * shaderBuilder.addStructField(\"testStructId\", \"float\", \"minimum\");"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addFunction",
    "description": "Add a new dynamically-generated function to the shader.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // generates the following function in the vertex shader\n * // vec3 testFunction(float parameter)\n * // {\n * // }\n * shaderBuilder.addStruct(\"testFunction\", \"vec3 testFunction(float parameter)\", ShaderDestination.VERTEX);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addFunctionLines",
    "description": "Add lines to a dynamically-generated function",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // generates the following function in the vertex shader\n * // vec3 testFunction(float parameter)\n * // {\n * //   float signed = 2.0 * parameter - 1.0;\n * //   return vec3(signed, 0.0, 0.0);\n * // }\n * shaderBuilder.addStruct(\"testFunction\", \"vec3 testFunction(float parameter)\", ShaderDestination.VERTEX);\n * shaderBuilder.addFunctionLines(\"testFunction\", [\n *   \"float signed = 2.0 * parameter - 1.0;\",\n *   \"return vec3(parameter);\"\n * ]);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addUniform",
    "description": "Add a uniform declaration to one or both of the shaders. These lines",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates the line \"uniform vec3 u_resolution;\"\n * shaderBuilder.addUniform(\"vec3\", \"u_resolution\", ShaderDestination.FRAGMENT);\n * // creates the line \"uniform float u_time;\" in both shaders\n * shaderBuilder.addUniform(\"float\", \"u_time\", ShaderDestination.BOTH);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "setPositionAttribute",
    "description": "Add a position attribute declaration to the vertex shader. These lines",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates the line \"in vec3 a_position;\"\n * shaderBuilder.setPositionAttribute(\"vec3\", \"a_position\");"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addAttribute",
    "description": "Add an attribute declaration to the vertex shader. These lines",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates the line \"in vec2 a_texCoord0;\" in the vertex shader\n * shaderBuilder.addAttribute(\"vec2\", \"a_texCoord0\");"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addVarying",
    "description": "Add a varying declaration to both the vertex and fragment shaders.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // creates the line \"in vec3 v_color;\" in the vertex shader\n * // creates the line \"out vec3 v_color;\" in the fragment shader\n * shaderBuilder.addVarying(\"vec3\", \"v_color\");"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addVertexLines",
    "description": "Appends lines of GLSL code to the vertex shader",
    "parameters": [],
    "returnType": "unknown",
    "example": "* shaderBuilder.addVertexLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    v_color = a_color;\",\n *  \"    gl_Position = vec4(a_position, 1.0);\",\n *  \"}\"\n * ]);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "addFragmentLines",
    "description": "Appends lines of GLSL code to the fragment shader",
    "parameters": [],
    "returnType": "unknown",
    "example": "* shaderBuilder.addFragmentLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    #ifdef SOLID_COLOR\",\n *  \"    out_FragColor = vec4(u_color, 1.0);\",\n *  \"    #else\",\n *  \"    out_FragColor = vec4(v_color, 1.0);\",\n *  \"    #endif\",\n *  \"}\"\n * ]);"
  },
  {
    "className": "ShaderBuilder",
    "methodName": "buildShaderProgram",
    "description": "Builds the {@link ShaderProgram} from the pieces added by the other methods.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const shaderProgram = shaderBuilder.buildShaderProgram(context);"
  },
  {
    "className": "ShaderCache",
    "methodName": "replaceShaderProgram",
    "description": "Returns a shader program from the cache, or creates and caches a new shader program,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* this._shaderProgram = context.shaderCache.replaceShaderProgram({\n     *     shaderProgram : this._shaderProgram,\n     *     vertexShaderSource : vs,\n     *     fragmentShaderSource : fs,\n     *     attributeLocations : attributeLocations\n     * });\n     *\n     *"
  },
  {
    "className": "ShaderFunction",
    "methodName": "ShaderFunction",
    "description": "A utility for dynamically-generating a GLSL function",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // generate the following function\n * //\n * // void assignVaryings(vec3 position)\n * // {\n * //    v_positionEC = (czm_modelView * vec4(a_position, 1.0)).xyz;\n * //    v_texCoord = a_texCoord;\n * // }\n * const signature = \"void assignVaryings(vec3 position)\";\n * const func = new ShaderFunction(signature);\n * func.addLine(\"v_positionEC = (czm_modelView * vec4(a_position, 1.0)).xyz;\");\n * func.addLine(\"v_texCoord = a_texCoord;\");\n * const generatedLines = func.generateGlslLines();\n *\n *"
  },
  {
    "className": "ShaderSource",
    "methodName": "ShaderSource",
    "description": "An object containing various inputs that will be combined to form a final GLSL shader string.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Prepend #defines to a shader\n * const source = new Cesium.ShaderSource({\n *   defines : ['WHITE'],\n *   sources : ['void main() { \\n#ifdef WHITE\\n out_FragColor = vec4(1.0); \\n#else\\n out_FragColor = vec4(0.0); \\n#endif\\n }']\n * });\n *\n * // 2. Modify a fragment shader for picking\n * const source2 = new Cesium.ShaderSource({\n *   sources : ['void main() { out_FragColor = vec4(1.0); }'],\n *   pickColorQualifier : 'uniform'\n * });\n *\n *"
  },
  {
    "className": "ShaderStruct",
    "methodName": "ShaderStruct",
    "description": "A utility for dynamically-generating a GLSL struct.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Generate the struct:\n * //\n * // struct Attributes\n * // {\n * //     vec3 position;\n * //     vec3 normal;\n * //     vec2 texCoord;\n * // };\n * const struct = new ShaderStruct(\"Attributes\");\n * struct.addField(\"vec3\", \"position\");\n * struct.addField(\"vec3\", \"normal\");\n * struct.addField(\"vec2\", \"texCoord\");\n * const generatedLines = struct.generateGlslLines();\n *\n *"
  },
  {
    "className": "SharedContext",
    "methodName": "SharedContext",
    "description": "Enables a single WebGL context to be used by any number of {@link Scene}s.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create two Scenes sharing a single WebGL context\n * const context = new Cesium.SharedContext();\n * const scene1 = new Cesium.Scene({\n *   canvas: canvas1,\n *   contextOptions: context,\n * });\n * const scene2 = new Cesium.Scene({\n *   canvas: canvas2,\n *   contextOptions: context,\n * });"
  },
  {
    "className": "SharedContext",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object. Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* context = context && context.destroy();\n *\n *"
  },
  {
    "className": "Sync",
    "methodName": "waitForSignal",
    "description": "Incremantally polls the status of the Sync object until signaled then resolves.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *  await sync.waitForSignal(function (next) {\n *    setTimeout(next, 100);\n *  });\n *} catch (e) {\n *  throw \"Signal timeout\";\n *} finally {\n *  sync.destroy();\n *}\n *\n *"
  },
  {
    "className": "Texture",
    "methodName": "fromFramebuffer",
    "description": "Creates a texture, and copies a subimage of the framebuffer to it.  When called without arguments,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a texture with the contents of the framebuffer.\n * const t = Texture.fromFramebuffer({\n *     context : context\n * });\n *\n *"
  },
  {
    "className": "Texture",
    "methodName": "copyFrom",
    "description": "Copy new image data into this texture, from a source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, or {@link HTMLVideoElement}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* texture.copyFrom({\n *  source: {\n *   width : 1,\n *   height : 1,\n *   arrayBufferView : new Uint8Array([255, 0, 0, 255])\n *  }\n * });"
  },
  {
    "className": "TextureAtlas",
    "methodName": "computeTextureCoordinates",
    "description": "Get the texture coordinates for reading the associated image in shaders.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const index = await atlas.addImage(\"myImage\", image);\n * const rectangle = atlas.computeTextureCoordinates(index);\n * BoundingRectangle.pack(rectangle, bufferView);"
  },
  {
    "className": "TextureAtlas",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* atlas = atlas && atlas.destroy();\n *"
  },
  {
    "className": "VertexArray",
    "methodName": "VertexArray",
    "description": "Creates a vertex array, which defines the attributes making up a vertex, and contains an optional index buffer",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Create a vertex array with vertices made up of three floating point\n * // values, e.g., a position, from a single vertex buffer.  No index buffer is used.\n * const positionBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * const attributes = [\n *     {\n *         index                  : 0,\n *         enabled                : true,\n *         vertexBuffer           : positionBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         normalize              : false,\n *         offsetInBytes          : 0,\n *         strideInBytes          : 0 // tightly packed\n *         instanceDivisor        : 0 // not instanced\n *     }\n * ];\n * const va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n *"
  },
  {
    "className": "VertexArray",
    "methodName": "fromGeometry",
    "description": "Creates a vertex array from a geometry.  A geometry contains vertex attributes and optional index data",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Creates a vertex array for rendering a box.  The default dynamic draw\n * // usage is used for the created vertex and index buffer.  The attributes are not\n * // interleaved by default.\n * const geometry = new BoxGeometry();\n * const va = VertexArray.fromGeometry({\n *     context            : context,\n *     geometry           : geometry,\n *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),\n * });\n *\n *"
  },
  {
    "className": "loadCubeMap",
    "methodName": "loadCubeMap",
    "description": "Asynchronously loads six images and creates a cube map.  Returns a promise that",
    "parameters": [],
    "returnType": "unknown",
    "example": "* Cesium.loadCubeMap(context, {\n *     positiveX : 'skybox_px.png',\n *     negativeX : 'skybox_nx.png',\n *     positiveY : 'skybox_py.png',\n *     negativeY : 'skybox_ny.png',\n *     positiveZ : 'skybox_pz.png',\n *     negativeZ : 'skybox_nz.png'\n * }).then(function(cubeMap) {\n *     // use the cubemap\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n *"
  },
  {
    "className": "ArcGisMapServerImageryProvider",
    "methodName": "ArcGisMapServerImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set the default access token for accessing ArcGIS Image Tile service\n * Cesium.ArcGisMapService.defaultAccessToken = \"<ArcGIS Access Token>\";\n *\n * // Add a base layer from a default ArcGIS basemap\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(\n *     Cesium.ArcGisMapServerImageryProvider.fromBasemapType(\n *       Cesium.ArcGisBaseMapType.SATELLITE\n *     )\n *   ),\n * });\n *\n *"
  },
  {
    "className": "ArcGisMapServerImageryProvider",
    "methodName": "fromBasemapType",
    "description": "Creates an {@link ImageryProvider} which provides tiled imagery from an ArcGIS base map.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set the default access token for accessing ArcGIS Image Tile service\n * Cesium.ArcGisMapService.defaultAccessToken = \"<ArcGIS Access Token>\";\n *\n * // Add a base layer from a default ArcGIS basemap\n * const provider = await Cesium.ArcGisMapServerImageryProvider.fromBasemapType(\n *   Cesium.ArcGisBaseMapType.SATELLITE);\n *\n *"
  },
  {
    "className": "ArcGisMapServerImageryProvider",
    "methodName": "fromUrl",
    "description": "Creates an {@link ImageryProvider} which provides tiled imagery hosted by an ArcGIS MapServer.  By default, the server's pre-cached tiles are",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const esri = await Cesium.ArcGisMapServerImageryProvider.fromUrl(\n *     \"https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer\"\n * );\n *\n *"
  },
  {
    "className": "Atmosphere",
    "methodName": "Atmosphere",
    "description": "Common atmosphere settings used by 3D Tiles and models for rendering sky atmosphere, ground atmosphere, and fog.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Turn on dynamic atmosphere lighting using the sun direction\n * scene.atmosphere.dynamicLighting = Cesium.DynamicAtmosphereLightingType.SUNLIGHT;\n *\n *"
  },
  {
    "className": "Azure2DImageryProvider",
    "methodName": "Azure2DImageryProvider",
    "description": "Provides 2D image tiles from Azure.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Azure 2D imagery provider\n * const azureImageryProvider = new Cesium.Azure2DImageryProvider({\n *     subscriptionKey: \"subscription-key\",\n *     tilesetId: \"microsoft.base.road\"\n * });"
  },
  {
    "className": "BatchTable",
    "methodName": "BatchTable",
    "description": "Creates a texture to look up per instance attributes for batched primitives. For example, store each primitive's pick color in the texture.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create the batch table\n * const attributes = [{\n *     functionName : 'getShow',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 1\n * }, {\n *     functionName : 'getPickColor',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 4,\n *     normalize : true\n * }];\n * const batchTable = new BatchTable(context, attributes, 5);\n *\n * // when creating the draw commands, update the uniform map and the vertex shader\n * vertexShaderSource = batchTable.getVertexShaderCallback()(vertexShaderSource);\n * const shaderProgram = ShaderProgram.fromCache({\n *    // ...\n *    vertexShaderSource : vertexShaderSource,\n * });\n *\n * drawCommand.shaderProgram = shaderProgram;\n * drawCommand.uniformMap = batchTable.getUniformMapCallback()(uniformMap);\n *\n * // use the attribute function names in the shader to retrieve the instance values\n * // ...\n * attribute float batchId;\n *\n * void main() {\n *     // ...\n *     float show = getShow(batchId);\n *     vec3 pickColor = getPickColor(batchId);\n *     // ...\n * }"
  },
  {
    "className": "BatchTexture",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets near and far scaling properties of a Billboard based on the billboard's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a billboard's scaleByDistance to scale by 1.5 when the\n   * // camera is 1500 meters from the billboard and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * b.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets near and far translucency properties of a Billboard based on the billboard's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a billboard's translucency to 1.0 when the\n   * // camera is 1500 meters from the billboard and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * b.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets near and far pixel offset scaling properties of a Billboard based on the billboard's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a billboard's pixel offset scale to 0.0 when the\n   * // camera is 1500 meters from the billboard and scale pixel offset to 10.0 pixels\n   * // in the y direction the camera distance approaches 8.0e6 meters.\n   * b.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);\n   * b.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);\n   *\n   *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets the horizontal origin of this billboard, which determines if the billboard is",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use a bottom, left origin\n   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;\n   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets the vertical origin of this billboard, which determines if the billboard is",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use a bottom, left origin\n   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;\n   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Assign yellow.\n   * b.color = Cesium.Color.YELLOW;\n   *\n   *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "Gets or sets the aligned axis in world space. The aligned axis is the unit vector that the billboard up vector points towards.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Have the billboard up vector point north\n   * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;\n   *\n   *"
  },
  {
    "className": "Billboard",
    "methodName": "function",
    "description": "<p>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // load an image from a URL\n   * b.image = 'some/image/url.png';\n   *\n   * // assuming b1 and b2 are billboards in the same billboard collection,\n   * // use the same image for both billboards.\n   * b2.image = b1.image;"
  },
  {
    "className": "Billboard",
    "methodName": "setImage",
    "description": "<p>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // create a billboard image dynamically\n * function drawImage(id) {\n *   // create and draw an image using a canvas\n *   const canvas = document.createElement('canvas');\n *   const context2D = canvas.getContext('2d');\n *   // ... draw image\n *   return canvas;\n * }\n * // drawImage will be called to create the texture\n * b.setImage('myImage', drawImage);\n *\n * // subsequent billboards created in the same collection using the same id will use the existing\n * // texture, without the need to create the canvas or draw the image\n * b2.setImage('myImage', drawImage);"
  },
  {
    "className": "Billboard",
    "methodName": "computeScreenSpacePosition",
    "description": "Computes the screen-space position of the billboard's origin, taking into account eye and pixel offsets.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* console.log(b.computeScreenSpacePosition(scene).toString());\n *\n *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "BillboardCollection",
    "description": "A renderable collection of billboards.  Billboards are viewport-aligned",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a billboard collection with two billboards\n * const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n * billboards.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   image : 'url/to/image'\n * });\n * billboards.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   image : 'url/to/another/image'\n * });"
  },
  {
    "className": "BillboardCollection",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * billboards.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "function",
    "description": "Gets or sets a value which determines if the texture atlas is",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set destroyTextureAtlas\n   * // Destroy a billboard collection but not its texture atlas.\n   *\n   * const atlas = new TextureAtlas();\n   * billboards.textureAtlas = atlas;\n   * billboards.destroyTextureAtlas = false;\n   *\n   * billboards = billboards.destroy();\n   * console.log(atlas.isDestroyed()); // False"
  },
  {
    "className": "BillboardCollection",
    "methodName": "add",
    "description": "Creates and adds a billboard with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1:  Add a billboard, specifying all the default values.\n * const b = billboards.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   heightReference : Cesium.HeightReference.NONE,\n *   horizontalOrigin : Cesium.HorizontalOrigin.CENTER,\n *   verticalOrigin : Cesium.VerticalOrigin.CENTER,\n *   scale : 1.0,\n *   image : 'url/to/image',\n *   imageSubRegion : undefined,\n *   color : Cesium.Color.WHITE,\n *   id : undefined,\n *   rotation : 0.0,\n *   alignedAxis : Cesium.Cartesian3.ZERO,\n *   width : undefined,\n *   height : undefined,\n *   scaleByDistance : undefined,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   sizeInMeters : false,\n *   distanceDisplayCondition : undefined\n * });\n *\n *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "remove",
    "description": "Removes a billboard from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const b = billboards.add(...);\n * billboards.remove(b);  // Returns true\n *\n *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "removeAll",
    "description": "Removes all billboards from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* billboards.add(...);\n * billboards.add(...);\n * billboards.removeAll();\n *\n *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "get",
    "description": "Returns the billboard in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every billboard in the collection\n * const len = billboards.length;\n * for (let i = 0; i < len; ++i) {\n *   const b = billboards.get(i);\n *   b.show = !b.show;\n * }\n *\n *"
  },
  {
    "className": "BillboardCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* billboards = billboards && billboards.destroy();\n *\n *"
  },
  {
    "className": "BingMapsImageryProvider",
    "methodName": "BingMapsImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const bing = await Cesium.BingMapsImageryProvider.fromUrl(\n *   \"https://dev.virtualearth.net\", {\n *     key: \"get-yours-at-https://www.bingmapsportal.com/\",\n *     mapStyle: Cesium.BingMapsStyle.AERIAL\n * });\n *\n *"
  },
  {
    "className": "BingMapsImageryProvider",
    "methodName": "fromUrl",
    "description": "Creates an {@link ImageryProvider} which provides tiled imagery using the Bing Maps Imagery REST API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const bing = await Cesium.BingMapsImageryProvider.fromUrl(\n *   \"https://dev.virtualearth.net\", {\n *     key: \"get-yours-at-https://www.bingmapsportal.com/\",\n *     mapStyle: Cesium.BingMapsStyle.AERIAL\n * });\n *\n *"
  },
  {
    "className": "Camera",
    "methodName": "Camera",
    "description": "The camera is defined by a position, orientation, and view frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * const camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;"
  },
  {
    "className": "Camera",
    "methodName": "setView",
    "description": "Sets the camera position, orientation and transform.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });"
  },
  {
    "className": "Camera",
    "methodName": "lookAt",
    "description": "Sets the camera position and orientation using a target and offset. The target must be given in",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Using a cartesian offset\n * const center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));"
  },
  {
    "className": "Camera",
    "methodName": "lookAtTransform",
    "description": "Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Using a cartesian offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));"
  },
  {
    "className": "Camera",
    "methodName": "pickEllipsoid",
    "description": "Pick an ellipsoid or map.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const canvas = viewer.scene.canvas;\n * const center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * const ellipsoid = viewer.scene.ellipsoid;\n * const result = viewer.camera.pickEllipsoid(center, ellipsoid);"
  },
  {
    "className": "Camera",
    "methodName": "flyTo",
    "description": "Flies the camera from its current position to a new position.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });"
  },
  {
    "className": "CameraEventAggregator",
    "methodName": "destroy",
    "description": "Removes mouse listeners held by this object.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* handler = handler && handler.destroy();\n *\n *"
  },
  {
    "className": "Cesium3DTileContent",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* content = content && content.destroy();\n *\n *"
  },
  {
    "className": "Cesium3DTileFeature",
    "methodName": "Cesium3DTileFeature",
    "description": "A feature of a {@link Cesium3DTileset}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On mouse over, display all the properties for a feature in the console log.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.Cesium3DTileFeature) {\n *         const propertyIds = feature.getPropertyIds();\n *         const length = propertyIds.length;\n *         for (let i = 0; i < length; ++i) {\n *             const propertyId = propertyIds[i];\n *             console.log(`{propertyId}: ${feature.getProperty(propertyId)}`);\n *         }\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);"
  },
  {
    "className": "Cesium3DTileFeature",
    "methodName": "getProperty",
    "description": "Returns a copy of the value of the feature's property with the given name. This includes properties from this feature's",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Display all the properties for a feature in the console log.\n * const propertyIds = feature.getPropertyIds();\n * const length = propertyIds.length;\n * for (let i = 0; i < length; ++i) {\n *     const propertyId = propertyIds[i];\n *     console.log(`{propertyId}: ${feature.getProperty(propertyId)}`);\n * }"
  },
  {
    "className": "Cesium3DTileFeature",
    "methodName": "setProperty",
    "description": "Sets the value of the feature's property with the given name.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const height = feature.getProperty('Height'); // e.g., the height of a building\n *\n *"
  },
  {
    "className": "Cesium3DTilePointFeature",
    "methodName": "Cesium3DTilePointFeature",
    "description": "A point feature of a {@link Cesium3DTileset}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On mouse over, display all the properties for a feature in the console log.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.Cesium3DTilePointFeature) {\n *         const propertyIds = feature.getPropertyIds();\n *         const length = propertyIds.length;\n *         for (let i = 0; i < length; ++i) {\n *             const propertyId = propertyIds[i];\n *             console.log(`{propertyId}: ${feature.getProperty(propertyId)}`);\n *         }\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);"
  },
  {
    "className": "Cesium3DTilePointFeature",
    "methodName": "getProperty",
    "description": "Returns a copy of the value of the feature's property with the given name. This includes properties from this feature's",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Display all the properties for a feature in the console log.\n * const propertyIds = feature.getPropertyIds();\n * const length = propertyIds.length;\n * for (let i = 0; i < length; ++i) {\n *     const propertyId = propertyIds[i];\n *     console.log(`{propertyId} : ${feature.getProperty(propertyId)}`);\n * }"
  },
  {
    "className": "Cesium3DTilePointFeature",
    "methodName": "setProperty",
    "description": "Sets the value of the feature's property with the given name.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const height = feature.getProperty('Height'); // e.g., the height of a building\n *\n *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "Cesium3DTileStyle",
    "description": "A style that is applied to a {@link Cesium3DTileset}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.style = new Cesium.Cesium3DTileStyle({\n *     color : {\n *         conditions : [\n *             ['${Height} >= 100', 'color(\"purple\", 0.5)'],\n *             ['${Height} >= 50', 'color(\"red\")'],\n *             ['true', 'color(\"blue\")']\n *         ]\n *     },\n *     show : '${Height} > 0',\n *     meta : {\n *         description : '\"Building id ${id} has height ${Height}.\"'\n *     }\n * });\n *\n *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>show</code> property. Alternatively a boolean, string, or object defining a show style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     show : '(regExp(\"^Chest\").test(${County})) && (${YearBuilt} >= 1970)'\n   * });\n   * style.show.evaluate(feature); // returns true or false depending on the feature's properties\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>color</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     color : '(${Temperature} > 90) ? color(\"red\") : color(\"white\")'\n   * });\n   * style.color.evaluateColor(feature, result); // returns a Cesium.Color object\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointSize</code> property. Alternatively a string or object defining a point size style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     pointSize : '(${Temperature} > 90) ? 2.0 : 1.0'\n   * });\n   * style.pointSize.evaluate(feature); // returns a Number\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointOutlineColor</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override pointOutlineColor expression with a string\n   * style.pointOutlineColor = 'color(\"blue\")';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointOutlineWidth</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override pointOutlineWidth expression with a string\n   * style.pointOutlineWidth = '5';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelColor</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override labelColor expression with a string\n   * style.labelColor = 'color(\"blue\")';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelOutlineColor</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override labelOutlineColor expression with a string\n   * style.labelOutlineColor = 'color(\"blue\")';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelOutlineWidth</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override labelOutlineWidth expression with a string\n   * style.labelOutlineWidth = '5';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>font</code> property. Alternatively a string or object defining a string style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     font : '(${Temperature} > 90) ? \"30px Helvetica\" : \"24px Helvetica\"'\n   * });\n   * style.font.evaluate(feature); // returns a String\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>label style</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     labelStyle : `(\\${Temperature} > 90) ? ${LabelStyle.FILL_AND_OUTLINE} : ${LabelStyle.FILL}`\n   * });\n   * style.labelStyle.evaluate(feature); // returns a LabelStyle\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelText</code> property. Alternatively a string or object defining a string style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     labelText : '(${Temperature} > 90) ? \">90\" : \"<=90\"'\n   * });\n   * style.labelText.evaluate(feature); // returns a String\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundColor</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override backgroundColor expression with a string\n   * style.backgroundColor = 'color(\"blue\")';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundPadding</code> property. Alternatively a string or object defining a vec2 style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override backgroundPadding expression with a string\n   * style.backgroundPadding = 'vec2(5.0, 7.0)';\n   * style.backgroundPadding.evaluate(feature); // returns a Cartesian2"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundEnabled</code> property. Alternatively a string or object defining a boolean style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override backgroundEnabled expression with a string\n   * style.backgroundEnabled = 'true';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>scaleByDistance</code> property. Alternatively a string or object defining a vec4 style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override scaleByDistance expression with a string\n   * style.scaleByDistance = 'vec4(1.5e2, 2.0, 1.5e7, 0.5)';\n   * style.scaleByDistance.evaluate(feature); // returns a Cartesian4"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>translucencyByDistance</code> property. Alternatively a string or object defining a vec4 style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override translucencyByDistance expression with a string\n   * style.translucencyByDistance = 'vec4(1.5e2, 1.0, 1.5e7, 0.2)';\n   * style.translucencyByDistance.evaluate(feature); // returns a Cartesian4"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>distanceDisplayCondition</code> property. Alternatively a string or object defining a vec2 style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override distanceDisplayCondition expression with a string\n   * style.distanceDisplayCondition = 'vec2(0.0, 5.5e6)';\n   * style.distanceDisplayCondition.evaluate(feature); // returns a Cartesian2"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>heightOffset</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override heightOffset expression with a string\n   * style.heightOffset = '2.0';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>anchorLineEnabled</code> property. Alternatively a string or object defining a boolean style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override anchorLineEnabled expression with a string\n   * style.anchorLineEnabled = 'true';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>anchorLineColor</code> property. Alternatively a string or object defining a color style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override anchorLineColor expression with a string\n   * style.anchorLineColor = 'color(\"blue\")';\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>image</code> property. Alternatively a string or object defining a string style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     image : '(${Temperature} > 90) ? \"/url/to/image1\" : \"/url/to/image2\"'\n   * });\n   * style.image.evaluate(feature); // returns a String\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>disableDepthTestDistance</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium.Cesium3DTileStyle();\n   * // Override disableDepthTestDistance expression with a string\n   * style.disableDepthTestDistance = '1000.0';\n   * style.disableDepthTestDistance.evaluate(feature); // returns a Number"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>horizontalOrigin</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     horizontalOrigin : HorizontalOrigin.LEFT\n   * });\n   * style.horizontalOrigin.evaluate(feature); // returns a HorizontalOrigin\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>verticalOrigin</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     verticalOrigin : VerticalOrigin.TOP\n   * });\n   * style.verticalOrigin.evaluate(feature); // returns a VerticalOrigin\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelHorizontalOrigin</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n    *     labelHorizontalOrigin : HorizontalOrigin.LEFT\n    * });\n    * style.labelHorizontalOrigin.evaluate(feature); // returns a HorizontalOrigin\n    *\n    *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelVerticalOrigin</code> property. Alternatively a string or object defining a number style can be used.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     labelVerticalOrigin : VerticalOrigin.TOP\n   * });\n   * style.labelVerticalOrigin.evaluate(feature); // returns a VerticalOrigin\n   *\n   *"
  },
  {
    "className": "Cesium3DTileStyle",
    "methodName": "function",
    "description": "Gets or sets the object containing application-specific expression that can be explicitly",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const style = new Cesium3DTileStyle({\n   *     meta : {\n   *         description : '\"Building id ${id} has height ${Height}.\"'\n   *     }\n   * });\n   * style.meta.description.evaluate(feature); // returns a String with the substituted variables"
  },
  {
    "className": "Cesium3DTilesVoxelProvider",
    "methodName": "fromUrl",
    "description": "Creates a {@link Cesium3DTilesVoxelProvider} that fetches voxel data from a 3D Tiles tileset.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *   const voxelProvider = await Cesium3DTilesVoxelProvider.fromUrl(\n *     \"http://localhost:8002/tilesets/voxel/tileset.json\"\n *   );\n *   const voxelPrimitive = new VoxelPrimitive({\n *     provider: voxelProvider,\n *     customShader: customShader,\n *   });\n *   scene.primitives.add(voxelPrimitive);\n * } catch (error) {\n *   console.error(`Error creating voxel primitive: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "Cesium3DTileset",
    "description": "A {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles tileset},",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *   const tileset = await Cesium.Cesium3DTileset.fromUrl(\n *      \"http://localhost:8002/tilesets/Seattle/tileset.json\"\n *   );\n *   scene.primitives.add(tileset);\n * } catch (error) {\n *   console.error(`Error creating tileset: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "loadProgress",
    "description": "The event fired to indicate progress of loading new tiles.  This event is fired when a new tile",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.loadProgress.addEventListener(function(numberOfPendingRequests, numberOfTilesProcessing) {\n   *     if ((numberOfPendingRequests === 0) && (numberOfTilesProcessing === 0)) {\n   *         console.log('Stopped loading');\n   *         return;\n   *     }\n   *\n   *     console.log(`Loading: requests: ${numberOfPendingRequests}, processing: ${numberOfTilesProcessing}`);\n   * });"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "allTilesLoaded",
    "description": "The event fired to indicate that all tiles that meet the screen space error this frame are loaded. The tileset",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.allTilesLoaded.addEventListener(function() {\n   *     console.log('All tiles are loaded');\n   * });\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "initialTilesLoaded",
    "description": "The event fired to indicate that all tiles that meet the screen space error this frame are loaded. This event",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.initialTilesLoaded.addEventListener(function() {\n   *     console.log('Initial tiles are loaded');\n   * });\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "tileLoad",
    "description": "The event fired to indicate that a tile's content was loaded.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.tileLoad.addEventListener(function(tile) {\n   *     console.log('A tile was loaded.');\n   * });"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "tileUnload",
    "description": "The event fired to indicate that a tile's content was unloaded.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.tileUnload.addEventListener(function(tile) {\n   *     console.log('A tile was unloaded from the cache.');\n   * });\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "tileFailed",
    "description": "The event fired to indicate that a tile's content failed to load.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.tileFailed.addEventListener(function(error) {\n   *     console.log(`An error occurred loading tile: ${error.url}`);\n   *     console.log(`Error: ${error.message}`);\n   * });"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "tileVisible",
    "description": "This event fires once for each visible tile in a frame.  This can be used to manually",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.tileVisible.addEventListener(function(tile) {\n   *     if (tile.content instanceof Cesium.Model3DTileContent) {\n   *         console.log('A 3D model tile is visible.');\n   *     }\n   * });\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "The collection of <code>ImageryLayer</code> objects providing 2D georeferenced",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Drape Bing Maps Aerial imagery over the tileset\n   * const imageryProvider = await Cesium.createWorldImageryAsync({\n   *   style: Cesium.IonWorldImageryStyle.AERIAL,\n   * });\n   * const imageryLayer = new ImageryLayer(imageryProvider);\n   * tileset.imageryLayers.add(imageryLayer);"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* console.log(`Maximum building height: ${tileset.properties.height.maximum}`);\n   * console.log(`Minimum building height: ${tileset.properties.height.minimum}`);\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "The style, defined using the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset.style = new Cesium.Cesium3DTileStyle({\n   *    color : {\n   *        conditions : [\n   *            ['${Height} >= 100', 'color(\"purple\", 0.5)'],\n   *            ['${Height} >= 50', 'color(\"red\")'],\n   *            ['true', 'color(\"blue\")']\n   *        ]\n   *    },\n   *    show : '${Height} > 0',\n   *    meta : {\n   *        description : '\"Building id ${id} has height ${Height}.\"'\n   *    }\n   * });\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "The tileset's bounding sphere.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const tileset = await Cesium.Cesium3DTileset.fromUrl(\"http://localhost:8002/tilesets/Seattle/tileset.json\");\n   *\n   * viewer.scene.primitives.add(tileset);\n   *\n   * // Set the camera to view the newly added tileset\n   * viewer.camera.viewBoundingSphere(tileset.boundingSphere, new Cesium.HeadingPitchRange(0, -0.5, 0));"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "A 4x4 transformation matrix that transforms the entire tileset.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Adjust a tileset's height from the globe's surface.\n   * const heightOffset = 20.0;\n   * const boundingSphere = tileset.boundingSphere;\n   * const cartographic = Cesium.Cartographic.fromCartesian(boundingSphere.center);\n   * const surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0);\n   * const offset = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, heightOffset);\n   * const translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3());\n   * tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation);"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "function",
    "description": "The properties for managing dynamic environment maps on this model. Affects lighting.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Change the ground color used for a tileset's environment map to a forest green\n   * const environmentMapManager = tileset.environmentMapManager;\n   * environmentMapManager.groundColor = Cesium.Color.fromCssColorString(\"#203b34\");\n   *\n   *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "fromIonAssetId",
    "description": "Creates a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles tileset},",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Load a Cesium3DTileset with a Cesium ion asset ID of 124624234\n * try {\n *   const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(124624234);\n *   scene.primitives.add(tileset);\n * } catch (error) {\n *   console.error(`Error creating tileset: ${error}`);\n * }"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "fromUrl",
    "description": "Creates a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles tileset},",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *   const tileset = await Cesium.Cesium3DTileset.fromUrl(\n *      \"http://localhost:8002/tilesets/Seattle/tileset.json\"\n *   );\n *   scene.primitives.add(tileset);\n * } catch (error) {\n *   console.error(`Error creating tileset: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* tileset = tileset && tileset.destroy();\n *\n *"
  },
  {
    "className": "Cesium3DTileset",
    "methodName": "getHeight",
    "description": "Get the height of the loaded surface at a given cartographic. This function will only take into account meshes for loaded tiles, not neccisarily the most detailed tiles available for a tileset. This function will always return undefined when sampling a point cloud.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(124624234);\n * scene.primitives.add(tileset);\n *\n * const height = tileset.getHeight(scene.camera.positionCartographic, scene);"
  },
  {
    "className": "ClassificationPrimitive",
    "methodName": "getGeometryInstanceAttributes",
    "description": "Returns the modifiable per-instance attributes for a {@link GeometryInstance}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);"
  },
  {
    "className": "ClassificationPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "ClippingPlaneCollection",
    "methodName": "ClippingPlaneCollection",
    "description": "Specifies a set of clipping planes. Clipping planes selectively disable rendering in a region on the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // This clipping plane's distance is positive, which means its normal\n * // is facing the origin. This will clip everything that is behind\n * // the plane, which is anything with y coordinate < -5.\n * const clippingPlanes = new Cesium.ClippingPlaneCollection({\n *     planes : [\n *         new Cesium.ClippingPlane(new Cesium.Cartesian3(0.0, 1.0, 0.0), 5.0)\n *     ],\n * });\n * // Create an entity and attach the ClippingPlaneCollection to the model.\n * const entity = viewer.entities.add({\n *     position : Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, 10000),\n *     model : {\n *         uri : 'model.gltf',\n *         minimumPixelSize : 128,\n *         maximumScale : 20000,\n *         clippingPlanes : clippingPlanes\n *     }\n * });\n * viewer.zoomTo(entity);"
  },
  {
    "className": "ClippingPlaneCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* clippingPlanes = clippingPlanes && clippingPlanes.destroy();\n *\n *"
  },
  {
    "className": "ClippingPolygon",
    "methodName": "ClippingPolygon",
    "description": "A geodesic polygon to be used with {@link ClippingPlaneCollection} for selectively hiding regions in a model, a 3D tileset, or the globe.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * const polygon = new Cesium.ClippingPolygon({\n *     positions: positions\n * });"
  },
  {
    "className": "ClippingPolygonCollection",
    "methodName": "ClippingPolygonCollection",
    "description": "Specifies a set of clipping polygons. Clipping polygons selectively disable rendering in a region",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * const polygon = new Cesium.ClippingPolygon({\n *     positions: positions\n * });\n *\n * const polygons = new Cesium.ClippingPolygonCollection({\n *    polygons: [ polygon ]\n * });"
  },
  {
    "className": "ClippingPolygonCollection",
    "methodName": "add",
    "description": "Adds the specified {@link ClippingPolygon} to the collection to be used to selectively disable rendering",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const polygons = new Cesium.ClippingPolygonCollection();\n *\n * const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * polygons.add(new Cesium.ClippingPolygon({\n *     positions: positions\n * }));\n *\n *\n *\n *"
  },
  {
    "className": "ClippingPolygonCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* clippingPolygons = clippingPolygons && clippingPolygons.destroy();\n *\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "CloudCollection",
    "description": "A renderable collection of clouds in the 3D scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a cloud collection with two cumulus clouds\n * const clouds = scene.primitives.add(new Cesium.CloudCollection());\n * clouds.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   maximumSize: new Cesium.Cartesian3(20.0, 12.0, 8.0)\n * });\n * clouds.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   maximumSize: new Cesium.Cartesian3(15.0, 9.0, 9.0),\n *   slice: 0.5\n * });\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "add",
    "description": "Creates and adds a cloud with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1:  Add a cumulus cloud, specifying all the default values.\n * const c = clouds.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   scale : new Cesium.Cartesian2(20.0, 12.0),\n *   maximumSize: new Cesium.Cartesian3(20.0, 12.0, 12.0),\n *   slice: -1.0,\n *   cloudType : CloudType.CUMULUS\n * });\n *\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "remove",
    "description": "Removes a cloud from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const c = clouds.add(...);\n * clouds.remove(c);  // Returns true\n *\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "removeAll",
    "description": "Removes all clouds from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* clouds.add(...);\n * clouds.add(...);\n * clouds.removeAll();\n *\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "get",
    "description": "Returns the cloud in the collection at the specified index. Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every cloud in the collection\n * const len = clouds.length;\n * for (let i = 0; i < len; ++i) {\n *   const c = clouds.get(i);\n *   c.show = !c.show;\n * }\n *\n *"
  },
  {
    "className": "CloudCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* clouds = clouds && clouds.destroy();\n *\n *"
  },
  {
    "className": "CloudType",
    "methodName": "validate",
    "description": "Validates that the provided cloud type is a valid {@link CloudType}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* if (!Cesium.CloudType.validate(cloudType)) {\n *   throw new Cesium.DeveloperError('cloudType must be a valid value.');\n * }"
  },
  {
    "className": "ConditionsExpression",
    "methodName": "ConditionsExpression",
    "description": "An expression for a style applied to a {@link Cesium3DTileset}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const expression = new Cesium.ConditionsExpression({\n *     conditions : [\n *         ['${Area} > 10, 'color(\"#FF0000\")'],\n *         ['${id} !== \"1\"', 'color(\"#00FF00\")'],\n *         ['true', 'color(\"#FFFFFF\")']\n *     ]\n * });\n * expression.evaluateColor(feature, result); // returns a Cesium.Color object"
  },
  {
    "className": "CreditDisplay",
    "methodName": "CreditDisplay",
    "description": "The credit display is responsible for displaying credits on screen.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Add a credit with a tooltip, image and link to display onscreen\n * const credit = new Cesium.Credit(`<a href=\"https://cesium.com/\" target=\"_blank\"><img src=\"/images/cesium_logo.png\" title=\"Cesium\"/></a>`, true);\n * viewer.creditDisplay.addStaticCredit(credit);\n *\n *"
  },
  {
    "className": "CreditDisplay",
    "methodName": "addStaticCredit",
    "description": "Adds a {@link Credit} that will show on screen or in the lightbox until removed with {@link CreditDisplay.removeStaticCredit}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Add a credit with a tooltip, image and link to display onscreen\n * const credit = new Cesium.Credit(`<a href=\"https://cesium.com/\" target=\"_blank\"><img src=\"/images/cesium_logo.png\" title=\"Cesium\"/></a>`, true);\n * viewer.creditDisplay.addStaticCredit(credit);\n *\n *"
  },
  {
    "className": "DebugAppearance",
    "methodName": "DebugAppearance",
    "description": "Visualizes a vertex attribute by displaying it as a color for debugging.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const primitive = new Cesium.Primitive({\n *   geometryInstances : // ...\n *   appearance : new Cesium.DebugAppearance({\n *     attributeName : 'normal'\n *   })\n * });"
  },
  {
    "className": "DebugCameraPrimitive",
    "methodName": "DebugCameraPrimitive",
    "description": "Draws the outline of the camera's view frustum.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* primitives.add(new Cesium.DebugCameraPrimitive({\n *   camera : camera,\n *   color : Cesium.Color.YELLOW\n * }));"
  },
  {
    "className": "DebugCameraPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* p = p && p.destroy();\n *\n *"
  },
  {
    "className": "DebugModelMatrixPrimitive",
    "methodName": "DebugModelMatrixPrimitive",
    "description": "Draws the axes of a reference frame defined by a matrix that transforms to world",
    "parameters": [],
    "returnType": "unknown",
    "example": "* primitives.add(new Cesium.DebugModelMatrixPrimitive({\n *   modelMatrix : primitive.modelMatrix,  // primitive to debug\n *   length : 100000.0,\n *   width : 10.0\n * }));"
  },
  {
    "className": "DebugModelMatrixPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* p = p && p.destroy();\n *\n *"
  },
  {
    "className": "DynamicEnvironmentMapManager",
    "methodName": "DynamicEnvironmentMapManager",
    "description": "Generates an environment map at the given position based on scene's current lighting conditions. From this, it produces multiple levels of specular maps and spherical harmonic coefficients than can be used with {@link ImageBasedLighting} for models or tilesets.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Enable time-of-day environment mapping in a scene\n * scene.atmosphere.dynamicLighting = Cesium.DynamicAtmosphereLightingType.SUNLIGHT;\n *\n * // Decrease the directional lighting contribution\n * scene.light.intensity = 0.5\n *\n * // Increase the intensity of of the environment map lighting contribution\n * const environmentMapManager = tileset.environmentMapManager;\n * environmentMapManager.atmosphereScatteringIntensity = 3.0;\n *\n *"
  },
  {
    "className": "DynamicEnvironmentMapManager",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* mapManager = mapManager && mapManager.destroy();\n *"
  },
  {
    "className": "EllipsoidPrimitive",
    "methodName": "radii",
    "description": "The radius of the ellipsoid along the <code>x</code>, <code>y</code>, and <code>z</code> axes in the ellipsoid's model coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // A sphere with a radius of 2.0\n   * e.radii = new Cesium.Cartesian3(2.0, 2.0, 2.0);\n   *\n   *"
  },
  {
    "className": "EllipsoidPrimitive",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms the ellipsoid from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * e.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);"
  },
  {
    "className": "EllipsoidPrimitive",
    "methodName": "material",
    "description": "The surface appearance of the ellipsoid.  This can be one of several built-in {@link Material} objects or a custom material, scripted with",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Change the color of the default material to yellow\n   * e.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);\n   *\n   * // 2. Change material to horizontal stripes\n   * e.material = Cesium.Material.fromType(Cesium.Material.StripeType);\n   *\n   *"
  },
  {
    "className": "EllipsoidPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "EllipsoidSurfaceAppearance",
    "methodName": "EllipsoidSurfaceAppearance",
    "description": "An appearance for geometry on the surface of the ellipsoid like {@link PolygonGeometry}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.PolygonGeometry({\n *       vertexFormat : Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT,\n *       // ...\n *     })\n *   }),\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Stripe')\n *   })\n * });"
  },
  {
    "className": "Expression",
    "methodName": "Expression",
    "description": "An expression for a style applied to a {@link Cesium3DTileset}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const expression = new Cesium.Expression('(regExp(\"^Chest\").test(${County})) && (${YearBuilt} >= 1970)');\n * expression.evaluate(feature); // returns true or false depending on the feature's properties\n *\n *"
  },
  {
    "className": "Fog",
    "methodName": "enabled",
    "description": "<code>true</code> if fog is enabled, <code>false</code> otherwise.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Disable fog in the scene\n   * viewer.scene.fog.enabled = false;"
  },
  {
    "className": "Fog",
    "methodName": "renderable",
    "description": "<code>true</code> if fog is renderable in shaders, <code>false</code> otherwise.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use fog culling but don't render it\n   * viewer.scene.fog.enabled = true;\n   * viewer.scene.fog.renderable = false;"
  },
  {
    "className": "Fog",
    "methodName": "density",
    "description": "A scalar that determines the density of the fog. Terrain that is in full fog are culled.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Double the default fog density\n   * viewer.scene.fog.density = 0.0012;"
  },
  {
    "className": "Fog",
    "methodName": "visualDensityScalar",
    "description": "A scalar that impacts the visual density of fog. This value does not impact the culling of terrain.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Increase fog appearance effect\n   * viewer.scene.fog.visualDensityScalar = 0.6;"
  },
  {
    "className": "FrameState",
    "methodName": "afterRender",
    "description": "An array of functions to be called at the end of the frame.  This array",
    "parameters": [],
    "returnType": "unknown",
    "example": "* frameState.afterRender.push(function() {\n   *   // take some action, raise an event, etc.\n   * });"
  },
  {
    "className": "Globe",
    "methodName": "pick",
    "description": "Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // find intersection of ray through a pixel and the globe\n * const ray = viewer.camera.getPickRay(windowCoordinates);\n * const intersection = globe.pick(ray, scene);"
  },
  {
    "className": "Globe",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* globe = globe && globe.destroy();\n *\n *"
  },
  {
    "className": "GlobeSurfaceTileProvider",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* provider = provider && provider();\n *\n *"
  },
  {
    "className": "GlobeTranslucency",
    "methodName": "function",
    "description": "A constant translucency to apply to front faces of the globe.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set front face translucency to 0.5.\n   * globe.translucency.frontFaceAlpha = 0.5;\n   * globe.translucency.enabled = true;"
  },
  {
    "className": "GlobeTranslucency",
    "methodName": "function",
    "description": "Gets or sets near and far translucency properties of front faces of the globe based on the distance to the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set front face translucency to 0.5 when the\n   * // camera is 1500 meters from the surface and 1.0\n   * // as the camera distance approaches 8.0e6 meters.\n   * globe.translucency.frontFaceAlphaByDistance = new Cesium.NearFarScalar(1.5e2, 0.5, 8.0e6, 1.0);\n   * globe.translucency.enabled = true;\n   *\n   *"
  },
  {
    "className": "GlobeTranslucency",
    "methodName": "function",
    "description": "A constant translucency to apply to back faces of the globe.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Set back face translucency to 0.5.\n   * globe.translucency.backFaceAlpha = 0.5;\n   * globe.translucency.enabled = true;"
  },
  {
    "className": "GlobeTranslucency",
    "methodName": "function",
    "description": "Gets or sets near and far translucency properties of back faces of the globe based on the distance to the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set back face translucency to 0.5 when the\n   * // camera is 1500 meters from the surface and 1.0\n   * // as the camera distance approaches 8.0e6 meters.\n   * globe.translucency.backFaceAlphaByDistance = new Cesium.NearFarScalar(1.5e2, 0.5, 8.0e6, 1.0);\n   * globe.translucency.enabled = true;\n   *\n   *"
  },
  {
    "className": "Google2DImageryProvider",
    "methodName": "Google2DImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Google 2D imagery provider\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromIonAssetId({\n *     assetId: 3830184\n * });\n  *"
  },
  {
    "className": "Google2DImageryProvider",
    "methodName": "fromIonAssetId",
    "description": "Creates an {@link ImageryProvider} which provides 2D global tiled imagery from {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview|Google 2D Tiles}, streamed using the Cesium ion REST API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Google 2D imagery provider\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromIonAssetId({\n *     assetId: 3830184\n * });\n *"
  },
  {
    "className": "Google2DImageryProvider",
    "methodName": "fromUrl",
    "description": "Creates an {@link ImageryProvider} which provides 2D global tiled imagery from {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview|Google 2D Tiles}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use your own Google api key\n * Cesium.GoogleMaps.defaultApiKey = \"your-api-key\";\n *\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromUrl({\n *     mapType: \"satellite\"\n * });\n *"
  },
  {
    "className": "GoogleEarthEnterpriseImageryProvider",
    "methodName": "GoogleEarthEnterpriseImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseImageryProvider.fromMetadata(geeMetadata);\n *\n *"
  },
  {
    "className": "GoogleEarthEnterpriseImageryProvider",
    "methodName": "fromMetadata",
    "description": "Creates a tiled imagery provider using the Google Earth Enterprise REST API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseImageryProvider.fromMetadata(geeMetadata);"
  },
  {
    "className": "GoogleEarthEnterpriseMapsProvider",
    "methodName": "GoogleEarthEnterpriseMapsProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const google = await Cesium.GoogleEarthEnterpriseMapsProvider.fromUrl(\"https://earth.localdomain\", 1008);\n *\n *"
  },
  {
    "className": "GoogleEarthEnterpriseMapsProvider",
    "methodName": "fromUrl",
    "description": "Creates a tiled imagery provider using the Google Earth Imagery API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const google = await Cesium.GoogleEarthEnterpriseMapsProvider.fromUrl(\"https://earth.localdomain\", 1008);"
  },
  {
    "className": "GroundPolylinePrimitive",
    "methodName": "GroundPolylinePrimitive",
    "description": "A GroundPolylinePrimitive represents a polyline draped over the terrain or 3D Tiles in the {@link Scene}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Draw a polyline on terrain with a basic color material\n *\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715\n *      ]),\n *      width : 4.0\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.PolylineMaterialAppearance()\n * }));\n *\n * // 2. Draw a looped polyline on terrain with per-instance color and a distance display condition.\n * // Distance display conditions for polylines on terrain are based on an approximate terrain height\n * // instead of true terrain height.\n *\n * const instance2 = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715,\n *          -112.13296079730024, 36.168769146801104\n *      ]),\n *      loop : true,\n *      width : 4.0\n *   }),\n *   attributes : {\n *      color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('green').withAlpha(0.7)),\n *      distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(1000, 30000)\n *   },\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance2,\n *   appearance : new Cesium.PolylineColorAppearance()\n * }));"
  },
  {
    "className": "GroundPolylinePrimitive",
    "methodName": "getGeometryInstanceAttributes",
    "description": "Returns the modifiable per-instance attributes for a {@link GeometryInstance}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);"
  },
  {
    "className": "GroundPolylinePrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "GroundPrimitive",
    "methodName": "GroundPrimitive",
    "description": "A ground primitive represents geometry draped over terrain or 3D Tiles in the {@link Scene}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1: Create primitive with a single instance\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : rectangleInstance\n * }));\n *\n * // Example 2: Batch instances\n * const color = new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5); // Both instances must have the same color.\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : color\n *   }\n * });\n * const ellipseInstance = new Cesium.GeometryInstance({\n *     geometry : new Cesium.EllipseGeometry({\n *         center : Cesium.Cartesian3.fromDegrees(-105.0, 40.0),\n *         semiMinorAxis : 300000.0,\n *         semiMajorAxis : 400000.0\n *     }),\n *     id : 'ellipse',\n *     attributes : {\n *         color : color\n *     }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : [rectangleInstance, ellipseInstance]\n * }));\n *\n *"
  },
  {
    "className": "GroundPrimitive",
    "methodName": "getGeometryInstanceAttributes",
    "description": "Returns the modifiable per-instance attributes for a {@link GeometryInstance}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);"
  },
  {
    "className": "GroundPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "I3SDataProvider",
    "methodName": "8",
    "description": "@typedef {object} I3SDataProvider.ConstructorOptions",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Increase LOD by reducing SSE\n * const cesium3dTilesetOptions = {\n *   maximumScreenSpaceError: 1,\n * };\n * const i3sOptions = {\n *   cesium3dTilesetOptions: cesium3dTilesetOptions,\n * };\n *\n *"
  },
  {
    "className": "I3SDataProvider",
    "methodName": "I3SDataProvider",
    "description": "An I3SDataProvider is the main public class for I3S support. The url option",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\"\n *   );\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "I3SDataProvider",
    "methodName": "fromUrl",
    "description": "Creates an I3SDataProvider. Currently supported I3S versions are 1.6 and",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\"\n *   );\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "ITwinData",
    "methodName": "createTilesetFromIModelId",
    "description": "Create a {@link Cesium3DTileset} for the given iModel id using iTwin's Mesh Export API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const tileset = await Cesium.ITwinData.createTilesetFromIModelId({ iModelId });\n * if (Cesium.defined(tileset)) {\n *   viewer.scene.primitives.add(tileset);\n * }\n *\n *"
  },
  {
    "className": "ImageBasedLighting",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* imageBasedLighting = imageBasedLighting && imageBasedLighting.destroy();\n *\n *"
  },
  {
    "className": "ImageryLayer",
    "methodName": "ImageryLayer",
    "description": "An imagery layer that displays tiled image data from a single imagery provider",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Add an OpenStreetMaps layer\n * const imageryLayer = new Cesium.ImageryLayer(new Cesium.OpenStreetMapImageryProvider({\n *   url: \"https://tile.openstreetmap.org/\"\n * }));\n * scene.imageryLayers.add(imageryLayer);\n *\n *"
  },
  {
    "className": "ImageryLayer",
    "methodName": "fromProviderAsync",
    "description": "Create a new imagery layer from an asynchronous imagery provider. The layer will handle any asynchronous loads or errors, and begin rendering the imagery layer once ready.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a new base layer\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * });\n *\n *"
  },
  {
    "className": "ImageryLayer",
    "methodName": "fromWorldImagery",
    "description": "Create a new imagery layer for ion's default global base imagery layer, currently Bing Maps. The layer will handle any asynchronous loads or errors, and begin rendering the imagery layer once ready.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a new base layer\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromWorldImagery();\n * });\n *\n *"
  },
  {
    "className": "ImageryLayer",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* imageryLayer = imageryLayer && imageryLayer.destroy();\n *\n *"
  },
  {
    "className": "ImageryLayer",
    "methodName": "getImageryRectangle",
    "description": "Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Zoom to an imagery layer.\n * const imageryRectangle = imageryLayer.getImageryRectangle();\n * scene.camera.flyTo({\n *     destination: rectangle\n * });\n *"
  },
  {
    "className": "ImageryLayerCollection",
    "methodName": "add",
    "description": "Adds a layer to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();\n * scene.imageryLayers.add(imageryLayer);\n *\n *"
  },
  {
    "className": "ImageryLayerCollection",
    "methodName": "addImageryProvider",
    "description": "Creates a new layer using the given ImageryProvider and adds it to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* try {\n *    const provider = await Cesium.IonImageryProvider.fromAssetId(3812);\n *    scene.imageryLayers.addImageryProvider(provider);\n * } catch (error) {\n *   console.log(`There was an error creating the imagery layer. ${error}`)\n * }"
  },
  {
    "className": "ImageryLayerCollection",
    "methodName": "pickImageryLayerFeatures",
    "description": "Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const pickRay = viewer.camera.getPickRay(windowPosition);\n * const featuresPromise = viewer.imageryLayers.pickImageryLayerFeatures(pickRay, viewer.scene);\n * if (!Cesium.defined(featuresPromise)) {\n *     console.log('No features picked.');\n * } else {\n *     Promise.resolve(featuresPromise).then(function(features) {\n *         // This function is called asynchronously when the list if picked features is available.\n *         console.log(`Number of features: ${features.length}`);\n *         if (features.length > 0) {\n *             console.log(`First feature name: ${features[0].name}`);\n *         }\n *     });\n * }"
  },
  {
    "className": "ImageryLayerCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this",
    "parameters": [],
    "returnType": "unknown",
    "example": "* layerCollection = layerCollection && layerCollection.destroy();\n *\n *"
  },
  {
    "className": "IonImageryProvider",
    "methodName": "IonImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * viewer.imageryLayers.add(imageryLayer);\n *\n *"
  },
  {
    "className": "IonImageryProvider",
    "methodName": "fromAssetId",
    "description": "Creates a provider for tiled imagery using the Cesium ion REST API.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * viewer.imageryLayers.add(imageryLayer);\n *\n *"
  },
  {
    "className": "Label",
    "methodName": "function",
    "description": "Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a label's translucencyByDistance to 1.0 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "Label",
    "methodName": "function",
    "description": "Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a label's pixel offset scale to 0.0 when the\n   * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels\n   * // in the y direction the camera distance approaches 8.0e6 meters.\n   * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);\n   * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);\n   *\n   *"
  },
  {
    "className": "Label",
    "methodName": "function",
    "description": "Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a label's scaleByDistance to scale by 1.5 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "Label",
    "methodName": "function",
    "description": "Gets or sets the horizontal origin of this label, which determines if the label is drawn",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;"
  },
  {
    "className": "Label",
    "methodName": "function",
    "description": "Gets or sets the vertical origin of this label, which determines if the label is",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;"
  },
  {
    "className": "Label",
    "methodName": "computeScreenSpacePosition",
    "description": "Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* console.log(l.computeScreenSpacePosition(scene).toString());\n *\n *"
  },
  {
    "className": "Label",
    "methodName": "enableRightToLeftDetection",
    "description": "Determines whether or not run the algorithm, that match the text of the label to right-to-left languages",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n * // Set a label's rightToLeft before init\n * Cesium.Label.enableRightToLeftDetection = true;\n * const myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: '   \\n   ',\n *   }\n * });\n *\n *"
  },
  {
    "className": "LabelCollection",
    "methodName": "LabelCollection",
    "description": "A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a label collection with two labels\n * const labels = scene.primitives.add(new Cesium.LabelCollection());\n * labels.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   text : 'A label'\n * });\n * labels.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   text : 'Another label'\n * });"
  },
  {
    "className": "LabelCollection",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),\n   *   text     : 'Center'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),\n   *   text     : 'East'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),\n   *   text     : 'North'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),\n   *   text     : 'Up'\n   * });"
  },
  {
    "className": "LabelCollection",
    "methodName": "add",
    "description": "Creates and adds a label with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1:  Add a label, specifying all the default values.\n * const l = labels.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   text : '',\n *   font : '30px sans-serif',\n *   fillColor : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.BLACK,\n *   outlineWidth : 1.0,\n *   showBackground : false,\n *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),\n *   backgroundPadding : new Cesium.Cartesian2(7, 5),\n *   style : Cesium.LabelStyle.FILL,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,\n *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,\n *   scale : 1.0,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   heightReference : HeightReference.NONE,\n *   distanceDisplayCondition : undefined\n * });\n *\n *"
  },
  {
    "className": "LabelCollection",
    "methodName": "remove",
    "description": "Removes a label from the collection.  Once removed, a label is no longer usable.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const l = labels.add(...);\n * labels.remove(l);  // Returns true\n *\n *"
  },
  {
    "className": "LabelCollection",
    "methodName": "removeAll",
    "description": "Removes all labels from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* labels.add(...);\n * labels.add(...);\n * labels.removeAll();\n *\n *"
  },
  {
    "className": "LabelCollection",
    "methodName": "get",
    "description": "Returns the label in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every label in the collection\n * const len = labels.length;\n * for (let i = 0; i < len; ++i) {\n *   const l = billboards.get(i);\n *   l.show = !l.show;\n * }\n *\n *"
  },
  {
    "className": "LabelCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* labels = labels && labels.destroy();\n *\n *"
  },
  {
    "className": "MapboxImageryProvider",
    "methodName": "MapboxImageryProvider",
    "description": "Provides tiled imagery hosted by Mapbox.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Mapbox tile provider\n * const mapbox = new Cesium.MapboxImageryProvider({\n *     mapId: 'mapbox.mapbox-terrain-v2',\n *     accessToken: 'thisIsMyAccessToken'\n * });\n *\n *"
  },
  {
    "className": "MapboxStyleImageryProvider",
    "methodName": "MapboxStyleImageryProvider",
    "description": "Provides tiled imagery hosted by Mapbox.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Mapbox style provider\n * const mapbox = new Cesium.MapboxStyleImageryProvider({\n *     styleId: 'streets-v11',\n *     accessToken: 'thisIsMyAccessToken'\n * });\n *\n *"
  },
  {
    "className": "Material",
    "methodName": "Material",
    "description": "A Material defines surface appearance through a combination of diffuse, specular,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a color material with fromType:\n * polygon.material = Cesium.Material.fromType('Color');\n * polygon.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);\n *\n * // Create the default material:\n * polygon.material = new Cesium.Material();\n *\n * // Create a color material with full Fabric notation:\n * polygon.material = new Cesium.Material({\n *   fabric: {\n *     type: 'Color',\n *     uniforms: {\n *       color: new Cesium.Color(1.0, 1.0, 0.0, 1.0)\n *     }\n *   }\n * });"
  },
  {
    "className": "Material",
    "methodName": "fromType",
    "description": "Creates a new material using an existing material type.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const material = Cesium.Material.fromType('Color', {\n *   color: new Cesium.Color(1.0, 0.0, 0.0, 1.0)\n * });"
  },
  {
    "className": "Material",
    "methodName": "fromTypeAsync",
    "description": "Creates a new material using an existing material type and returns a promise that resolves when",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const material = await Cesium.Material.fromTypeAsync('Image', {\n *    image: '../Images/Cesium_Logo_overlay.png'\n * });"
  },
  {
    "className": "Material",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* material = material && material.destroy();\n *\n *"
  },
  {
    "className": "MaterialAppearance",
    "methodName": "MaterialAppearance",
    "description": "An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const primitive = new Cesium.Primitive({\n     *   geometryInstances : new Cesium.GeometryInstance({\n     *     geometry : new Cesium.WallGeometry({\n            materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,\n     *       // ...\n     *     })\n     *   }),\n     *   appearance : new Cesium.MaterialAppearance({\n     *     material : Cesium.Material.fromType('Color'),\n     *     faceForward : true\n     *   })\n     *\n     * });"
  },
  {
    "className": "Megatexture",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* megatexture = megatexture && megatexture.destroy();"
  },
  {
    "className": "CustomShader",
    "methodName": "CustomShader",
    "description": "A user defined GLSL shader used with {@link Model} as well",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const customShader = new CustomShader({\n *   uniforms: {\n *     u_colorIndex: {\n *       type: Cesium.UniformType.FLOAT,\n *       value: 1.0\n *     },\n *     u_normalMap: {\n *       type: Cesium.UniformType.SAMPLER_2D,\n *       value: new Cesium.TextureUniform({\n *         url: \"http://example.com/normal.png\"\n *       })\n *     }\n *   },\n *   varyings: {\n *     v_selectedColor: Cesium.VaryingType.VEC3\n *   },\n *   vertexShaderText: `\n *   void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {\n *     v_selectedColor = mix(vsInput.attributes.color_0, vsInput.attributes.color_1, u_colorIndex);\n *     vsOutput.positionMC += 0.1 * vsInput.attributes.normal;\n *   }\n *   `,\n *   fragmentShaderText: `\n *   void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {\n *     material.normal = texture(u_normalMap, fsInput.attributes.texCoord_0);\n *     material.diffuse = v_selectedColor;\n *   }\n *   `\n * });"
  },
  {
    "className": "CustomShader",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* customShader = customShader && customShader.destroy();\n *\n *"
  },
  {
    "className": "Model",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms the model from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);"
  },
  {
    "className": "Model",
    "methodName": "function",
    "description": "If <code>true</code>, the model is exaggerated along the ellipsoid normal when {@link Scene.verticalExaggeration} is set to a value other than <code>1.0</code>.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Exaggerate terrain by a factor of 2, but prevent model exaggeration\n   * scene.verticalExaggeration = 2.0;\n   * model.enableVerticalExaggeration = false;"
  },
  {
    "className": "Model",
    "methodName": "function",
    "description": "The properties for managing dynamic environment maps on this model. Affects lighting.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Change the ground color used for a model's environment map to a forest green\n   * const environmentMapManager = model.environmentMapManager;\n   * environmentMapManager.groundColor = Cesium.Color.fromCssColorString(\"#203b34\");\n   *\n   *"
  },
  {
    "className": "Model",
    "methodName": "getNode",
    "description": "Returns the node with the given <code>name</code> in the glTF. This is used to",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Apply non-uniform scale to node \"Hand\"\n * const node = model.getNode(\"Hand\");\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);"
  },
  {
    "className": "Model",
    "methodName": "setArticulationStage",
    "description": "Sets the current value of an articulation stage.  After setting one or",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Sets the value of the stage named \"MoveX\" belonging to the articulation named \"SampleArticulation\"\n * model.setArticulationStage(\"SampleArticulation MoveX\", 50.0);"
  },
  {
    "className": "Model",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* model = model && model.destroy();\n *\n *"
  },
  {
    "className": "Model",
    "methodName": "fromGltfAsync",
    "description": "<p>",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Load a model and add it to the scene\n * try {\n *  const model = await Cesium.Model.fromGltfAsync({\n *    url: \"../../SampleData/models/CesiumMan/Cesium_Man.glb\"\n *  });\n *  viewer.scene.primitives.add(model);\n * } catch (error) {\n *  console.log(`Failed to load model. ${error}`);\n * }\n *\n *"
  },
  {
    "className": "ModelAnimation",
    "methodName": "start",
    "description": "The event fired when this animation is started.  This can be used, for",
    "parameters": [],
    "returnType": "unknown",
    "example": "* animation.start.addEventListener(function(model, animation) {\n   *   console.log(`Animation started: ${animation.name}`);\n   * });"
  },
  {
    "className": "ModelAnimation",
    "methodName": "update",
    "description": "The event fired when on each frame when this animation is updated.  The",
    "parameters": [],
    "returnType": "unknown",
    "example": "* animation.update.addEventListener(function(model, animation, time) {\n   *   console.log(`Animation updated: ${animation.name}. glTF animation time: ${time}`);\n   * });"
  },
  {
    "className": "ModelAnimation",
    "methodName": "stop",
    "description": "The event fired when this animation is stopped.  This can be used, for",
    "parameters": [],
    "returnType": "unknown",
    "example": "* animation.stop.addEventListener(function(model, animation) {\n   *   console.log(`Animation stopped: ${animation.name}`);\n   * });"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "animationAdded",
    "description": "The event fired when an animation is added to the collection.  This can be used, for",
    "parameters": [],
    "returnType": "unknown",
    "example": "* model.activeAnimations.animationAdded.addEventListener(function(model, animation) {\n   *   console.log(`Animation added: ${animation.name}`);\n   * });"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "animationRemoved",
    "description": "The event fired when an animation is removed from the collection.  This can be used, for",
    "parameters": [],
    "returnType": "unknown",
    "example": "* model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {\n   *   console.log(`Animation removed: ${animation.name}`);\n   * });"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "add",
    "description": "Creates and adds an animation with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Add an animation by name\n * model.activeAnimations.add({\n *   name : 'animation name'\n * });\n *\n *"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "addAll",
    "description": "Creates and adds animations with the specified initial properties to the collection",
    "parameters": [],
    "returnType": "unknown",
    "example": "* model.activeAnimations.addAll({\n *   multiplier : 0.5,                            // Play at half-speed\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations\n * });"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "remove",
    "description": "Removes an animation from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const a = model.activeAnimations.add({\n *   name : 'animation name'\n * });\n * model.activeAnimations.remove(a); // Returns true"
  },
  {
    "className": "ModelAnimationCollection",
    "methodName": "get",
    "description": "Returns the animation in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Output the names of all the animations in the collection.\n * const animations = model.activeAnimations;\n * const length = animations.length;\n * for (let i = 0; i < length; ++i) {\n *   console.log(animations.get(i).name);\n * }"
  },
  {
    "className": "ModelFeature",
    "methodName": "ModelFeature",
    "description": "A feature of a {@link Model}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On mouse over, display all the properties for a feature in the console log.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.ModelFeature) {\n *         console.log(feature);\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *"
  },
  {
    "className": "ModelFeature",
    "methodName": "getProperty",
    "description": "Returns a copy of the value of the feature's property with the given name.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Display all the properties for a feature in the console log.\n * const propertyIds = feature.getPropertyIds();\n * const length = propertyIds.length;\n * for (let i = 0; i < length; ++i) {\n *     const propertyId = propertyIds[i];\n *     console.log(propertyId + ': ' + feature.getProperty(propertyId));\n * }"
  },
  {
    "className": "ModelFeature",
    "methodName": "setProperty",
    "description": "Sets the value of the feature's property with the given name.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const height = feature.getProperty('Height'); // e.g., the height of a building\n *\n *"
  },
  {
    "className": "ModelFeatureTable",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "ModelNode",
    "methodName": "ModelNode",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const node = model.getNode(\"Hand\");\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n *\n *"
  },
  {
    "className": "ModelRuntimeNode",
    "methodName": "getChild",
    "description": "Returns the child with the given index.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Iterate through all children of a runtime node.\n * for (let i = 0; i < runtimeNode.children.length; i++)\n * {\n *   const childNode = runtimeNode.getChild(i);\n * }\n *\n *"
  },
  {
    "className": "ModelUtility",
    "methodName": "sanitizeGlslIdentifier",
    "description": "Sanitize the identifier to be used in a GLSL shader. The identifier",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Returns \"customProperty\"\n * ModelUtility.sanitizeGlslIdentifier(\"gl_customProperty\");\n *\n *"
  },
  {
    "className": "PrimitiveOutlineGenerator",
    "methodName": "PrimitiveOutlineGenerator",
    "description": "A class to handle the low-level details of processing indices and vertex",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // The constructor will compute the updated indices and generate outline\n * // coordinates.\n * const outlineGenerator = new PrimitiveOutlineGenerator({\n *   triangleIndices: primitive.indices.typedArray,\n *   outlineIndices: outlineIndices,\n *   originalVertexCount: primitive.attributes[0].count\n * });\n *\n * // Caller must update the indices (the data type may have been upgraded!)\n * primitive.indices.typedArray = outlineGenerator.updatedTriangleIndices;\n * primitive.indices.indexDatatype =\n *  IndexDatatype.fromTypedArray(primitive.indices.typedArray);\n *\n * // Create a new attribute for the generated outline coordinates\n * primitive.outlineCoordinates = new ModelComponents.Attribute();\n * // ... initialize as a vec3 attribute\n * primitive.outlineCoordinates.typedArray =\n *   outlineGenerator.outlineCoordinates;\n *\n * // Updating an attribute\n * const attribute = primitive.attributes[i];\n * attribute.typedArray = outlineGenerator.updateAttribute(\n *   attribute.typedArray\n * );\n *\n *"
  },
  {
    "className": "TextureManager",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* textureManager = textureManager && textureManager.destroy();\n *\n *"
  },
  {
    "className": "Moon",
    "methodName": "Moon",
    "description": "Draws the Moon in 3D.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.moon = new Cesium.Moon();\n *\n *"
  },
  {
    "className": "Moon",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* moon = moon && moon.destroy();\n *\n *"
  },
  {
    "className": "OpenStreetMapImageryProvider",
    "methodName": "OpenStreetMapImageryProvider",
    "description": "An imagery provider that provides tiled imagery hosted by OpenStreetMap",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const osm = new Cesium.OpenStreetMapImageryProvider({\n *     url : 'https://tile.openstreetmap.org/'\n * });\n *\n *"
  },
  {
    "className": "OrderedGroundPrimitiveCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this",
    "parameters": [],
    "returnType": "unknown",
    "example": "* primitives = primitives && primitives.destroy();\n *\n *"
  },
  {
    "className": "PerInstanceColorAppearance",
    "methodName": "PerInstanceColorAppearance",
    "description": "An appearance for {@link GeometryInstance} instances with color attributes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // A solid white line segment\n * const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.SimplePolylineGeometry({\n *       positions : Cesium.Cartesian3.fromDegreesArray([\n *         0.0, 0.0,\n *         5.0, 0.0\n *       ])\n *     }),\n *     attributes : {\n *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))\n *     }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance({\n *     flat : true,\n *     translucent : false\n *   })\n * });\n *\n * // Two rectangles in a primitive, each with a different color\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0)\n *   }),\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 0.5)\n *   }\n * });\n *\n * const anotherInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(0.0, 40.0, 10.0, 50.0)\n *   }),\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 0.0, 1.0, 0.5)\n *   }\n * });\n *\n * const rectanglePrimitive = new Cesium.Primitive({\n *   geometryInstances : [instance, anotherInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * });"
  },
  {
    "className": "PointCloudEyeDomeLighting",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* processor = processor && processor.destroy();\n *\n *"
  },
  {
    "className": "PointPrimitive",
    "methodName": "function",
    "description": "Gets or sets near and far scaling properties of a point based on the point's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a pointPrimitive's scaleByDistance to scale to 15 when the\n   * // camera is 1500 meters from the pointPrimitive and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * p.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 15, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "PointPrimitive",
    "methodName": "function",
    "description": "Gets or sets near and far translucency properties of a point based on the point's distance from the camera.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1.\n   * // Set a point's translucency to 1.0 when the\n   * // camera is 1500 meters from the point and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * p.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   *"
  },
  {
    "className": "PointPrimitive",
    "methodName": "function",
    "description": "Gets or sets the inner color of the point.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Assign yellow.\n   * p.color = Cesium.Color.YELLOW;\n   *\n   *"
  },
  {
    "className": "PointPrimitive",
    "methodName": "computeScreenSpacePosition",
    "description": "Computes the screen-space position of the point's origin.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* console.log(p.computeScreenSpacePosition(scene).toString());"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "PointPrimitiveCollection",
    "description": "A renderable collection of points.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a pointPrimitive collection with two points\n * const points = scene.primitives.add(new Cesium.PointPrimitiveCollection());\n * points.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   color : Cesium.Color.YELLOW\n * });\n * points.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   color : Cesium.Color.CYAN\n * });\n *\n *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * pointPrimitives.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * pointPrimitives.add({\n   *   color : Cesium.Color.ORANGE,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.YELLOW,\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.GREEN,\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.CYAN,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "add",
    "description": "Creates and adds a point with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1:  Add a point, specifying all the default values.\n * const p = pointPrimitives.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelSize : 10.0,\n *   color : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.TRANSPARENT,\n *   outlineWidth : 0.0,\n *   id : undefined\n * });\n *\n *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "remove",
    "description": "Removes a point from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const p = pointPrimitives.add(...);\n * pointPrimitives.remove(p);  // Returns true\n *\n *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "removeAll",
    "description": "Removes all points from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointPrimitives.add(...);\n * pointPrimitives.add(...);\n * pointPrimitives.removeAll();\n *\n *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "get",
    "description": "Returns the point in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every point in the collection\n * const len = pointPrimitives.length;\n * for (let i = 0; i < len; ++i) {\n *   const p = pointPrimitives.get(i);\n *   p.show = !p.show;\n * }\n *\n *"
  },
  {
    "className": "PointPrimitiveCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointPrimitives = pointPrimitives && pointPrimitives.destroy();\n *\n *"
  },
  {
    "className": "Polyline",
    "methodName": "function",
    "description": "Gets or sets the positions of the polyline.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* polyline.positions = Cesium.Cartesian3.fromDegreesArray([\n   *     0.0, 0.0,\n   *     10.0, 0.0,\n   *     0.0, 20.0\n   * ]);"
  },
  {
    "className": "PolylineCollection",
    "methodName": "PolylineCollection",
    "description": "A renderable collection of polylines.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a polyline collection with two polylines\n * const polylines = new Cesium.PolylineCollection();\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -75.10, 39.57,\n *     -77.02, 38.53,\n *     -80.50, 35.14,\n *     -80.12, 25.46]),\n *   width : 2\n * });\n *\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -73.10, 37.57,\n *     -75.02, 36.53,\n *     -78.50, 33.14,\n *     -78.12, 23.46]),\n *   width : 4\n * });"
  },
  {
    "className": "PolylineCollection",
    "methodName": "add",
    "description": "Creates and adds a polyline with the specified initial properties to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1:  Add a polyline, specifying all the default values.\n     * const p = polylines.add({\n     *   show : true,\n     *   positions : ellipsoid.cartographicArrayToCartesianArray([\n           Cesium.Cartographic.fromDegrees(-75.10, 39.57),\n           Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),\n     *   width : 1\n     * });\n     *\n     *"
  },
  {
    "className": "PolylineCollection",
    "methodName": "remove",
    "description": "Removes a polyline from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const p = polylines.add(...);\n * polylines.remove(p);  // Returns true\n *\n *"
  },
  {
    "className": "PolylineCollection",
    "methodName": "removeAll",
    "description": "Removes all polylines from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* polylines.add(...);\n * polylines.add(...);\n * polylines.removeAll();\n *\n *"
  },
  {
    "className": "PolylineCollection",
    "methodName": "get",
    "description": "Returns the polyline in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every polyline in the collection\n * const len = polylines.length;\n * for (let i = 0; i < len; ++i) {\n *   const p = polylines.get(i);\n *   p.show = !p.show;\n * }\n *\n *"
  },
  {
    "className": "PolylineCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* polylines = polylines && polylines.destroy();\n *\n *"
  },
  {
    "className": "PolylineColorAppearance",
    "methodName": "PolylineColorAppearance",
    "description": "An appearance for {@link GeometryInstance} instances with color attributes and",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // A solid white line segment\n * const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.PolylineGeometry({\n *       positions : Cesium.Cartesian3.fromDegreesArray([\n *         0.0, 0.0,\n *         5.0, 0.0\n *       ]),\n *       width : 10.0,\n *       vertexFormat : Cesium.PolylineColorAppearance.VERTEX_FORMAT\n *     }),\n *     attributes : {\n *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))\n *     }\n *   }),\n *   appearance : new Cesium.PolylineColorAppearance({\n *     translucent : false\n *   })\n * });"
  },
  {
    "className": "PolylineMaterialAppearance",
    "methodName": "PolylineMaterialAppearance",
    "description": "An appearance for {@link PolylineGeometry} that supports shading with materials.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.PolylineGeometry({\n *       positions : Cesium.Cartesian3.fromDegreesArray([\n *         0.0, 0.0,\n *         5.0, 0.0\n *       ]),\n *       width : 10.0,\n *       vertexFormat : Cesium.PolylineMaterialAppearance.VERTEX_FORMAT\n *     })\n *   }),\n *   appearance : new Cesium.PolylineMaterialAppearance({\n *     material : Cesium.Material.fromType('Color')\n *   })\n * });"
  },
  {
    "className": "PostProcessStage",
    "methodName": "PostProcessStage",
    "description": "Runs a post-process stage on either the texture rendered by the scene or the output of a previous post-process stage.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Simple stage to change the color\n * const fs =`\n *     uniform sampler2D colorTexture;\n *     in vec2 v_textureCoordinates;\n *     uniform float scale;\n *     uniform vec3 offset;\n *     void main() {\n *         vec4 color = texture(colorTexture, v_textureCoordinates);\n *         out_FragColor = vec4(color.rgb * scale + offset, 1.0);\n *     }`;\n * scene.postProcessStages.add(new Cesium.PostProcessStage({\n *     fragmentShader : fs,\n *     uniforms : {\n *         scale : 1.1,\n *         offset : function() {\n *             return new Cesium.Cartesian3(0.1, 0.2, 0.3);\n *         }\n *     }\n * }));\n *\n *"
  },
  {
    "className": "PostProcessStageCollection",
    "methodName": "function",
    "description": "Specifies the tonemapping algorithm used when rendering with high dynamic range.",
    "parameters": [],
    "returnType": "unknown",
    "example": "viewer.scene.postProcessStages.tonemapper = Cesium.Tonemapper.ACES;\n   *\n   *"
  },
  {
    "className": "PostProcessStageCollection",
    "methodName": "function",
    "description": "Control the exposure when HDR is on. Less than 1.0 makes the tonemapping darker while greater than 1.0 makes it brighter.",
    "parameters": [],
    "returnType": "unknown",
    "example": "viewer.scene.postProcessStages.exposure = 1.0;\n   *\n   *"
  },
  {
    "className": "PostProcessStageComposite",
    "methodName": "PostProcessStageComposite",
    "description": "A collection of {@link PostProcessStage}s or other post-process composite stages that execute together logically.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1: separable blur filter\n * // The input to blurXDirection is the texture rendered to by the scene or the output of the previous stage.\n * // The input to blurYDirection is the texture rendered to by blurXDirection.\n * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({\n *     stages : [blurXDirection, blurYDirection]\n * }));\n *\n *"
  },
  {
    "className": "PostProcessStageLibrary",
    "methodName": "createEdgeDetectionStage",
    "description": "Creates a post-process stage that detects edges.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // multiple silhouette effects\n * const yellowEdge = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();\n * yellowEdge.uniforms.color = Cesium.Color.YELLOW;\n * yellowEdge.selected = [feature0];\n *\n * const greenEdge = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();\n * greenEdge.uniforms.color = Cesium.Color.LIME;\n * greenEdge.selected = [feature1];\n *\n * // draw edges around feature0 and feature1\n * postProcessStages.add(Cesium.PostProcessStageLibrary.createSilhouetteStage([yellowEdge, greenEdge]);"
  },
  {
    "className": "Primitive",
    "methodName": "Primitive",
    "description": "A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Draw a translucent ellipse on the surface with a checkerboard pattern\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipseGeometry({\n *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),\n *       semiMinorAxis : 500000.0,\n *       semiMajorAxis : 1000000.0,\n *       rotation : Cesium.Math.PI_OVER_FOUR,\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Checkerboard')\n *   })\n * }));\n *\n *"
  },
  {
    "className": "Primitive",
    "methodName": "modelMatrix",
    "description": "The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);"
  },
  {
    "className": "Primitive",
    "methodName": "function",
    "description": "Determines if the primitive is complete and ready to render.  If this property is",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Wait for a primitive to become ready before accessing attributes\n   * const removeListener = scene.postRender.addEventListener(() => {\n   *   if (!frustumPrimitive.ready) {\n   *     return;\n   *   }\n   *\n   *   const attributes = primitive.getGeometryInstanceAttributes('an id');\n   *   attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n   *\n   *   removeListener();\n   * });"
  },
  {
    "className": "Primitive",
    "methodName": "getGeometryInstanceAttributes",
    "description": "Returns the modifiable per-instance attributes for a {@link GeometryInstance}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);\n * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);"
  },
  {
    "className": "Primitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* e = e && e.destroy();\n *\n *"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "PrimitiveCollection",
    "description": "A collection of primitives.  This is most often used with {@link Scene#primitives},",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const billboards = new Cesium.BillboardCollection();\n * const labels = new Cesium.LabelCollection();\n *\n * const collection = new Cesium.PrimitiveCollection();\n * collection.add(billboards);\n *\n * scene.primitives.add(collection);  // Add collection\n * scene.primitives.add(labels);      // Add regular primitive"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "destroyPrimitives",
    "description": "Determines if primitives in the collection are destroyed when they are removed by",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. Primitives are destroyed by default.\n   * const primitives = new Cesium.PrimitiveCollection();\n   * const labels = primitives.add(new Cesium.LabelCollection());\n   * primitives = primitives.destroy();\n   * const b = labels.isDestroyed(); // true\n   *\n   *"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "add",
    "description": "Adds a primitive to the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const billboards = scene.primitives.add(new Cesium.BillboardCollection());"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "remove",
    "description": "Removes a primitive from the collection.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n * scene.primitives.remove(billboards);  // Returns true\n *\n *"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "get",
    "description": "Returns the primitive in the collection at the specified index.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Toggle the show property of every primitive in the collection.\n * const primitives = scene.primitives;\n * const length = primitives.length;\n * for (let i = 0; i < length; ++i) {\n *   const p = primitives.get(i);\n *   p.show = !p.show;\n * }\n *\n *"
  },
  {
    "className": "PrimitiveCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this",
    "parameters": [],
    "returnType": "unknown",
    "example": "* primitives = primitives && primitives.destroy();\n *\n *"
  },
  {
    "className": "QuadtreePrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* primitive = primitive && primitive.destroy();\n *\n *"
  },
  {
    "className": "QuadtreeTileProvider",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* provider = provider && provider();\n *\n *"
  },
  {
    "className": "ResourceLoader",
    "methodName": "destroy",
    "description": "Destroys the loaded resource.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* resourceLoader = resourceLoader && resourceLoader.destroy();\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "Scene",
    "description": "The container for all 3D graphical objects and state in a Cesium virtual scene.  Generally,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create scene without anisotropic texture filtering\n * const scene = new Cesium.Scene({\n *   canvas : canvas,\n *   contextOptions : {\n *     allowTextureFilterAnisotropic : false\n *   }\n * });"
  },
  {
    "className": "Scene",
    "methodName": "debugCommandFilter",
    "description": "This property is for debugging only; it is not for production use.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Do not execute any commands.\n   * scene.debugCommandFilter = function(command) {\n   *     return false;\n   * };\n   *\n   * // Execute only the billboard's commands.  That is, only draw the billboard.\n   * const billboards = new Cesium.BillboardCollection();\n   * scene.debugCommandFilter = function(command) {\n   *     return command.owner === billboards;\n   * };"
  },
  {
    "className": "Scene",
    "methodName": "pickTranslucentDepth",
    "description": "When <code>true</code>, enables picking translucent geometry using the depth buffer. Note that {@link Scene#useDepthPicking} must also be true for enabling this to work.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // picking the position of a translucent primitive\n   * viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {\n   *      const pickedFeature = viewer.scene.pick(movement.position);\n   *      if (!Cesium.defined(pickedFeature)) {\n   *          // nothing picked\n   *          return;\n   *      }\n   *      const worldPosition = viewer.scene.pickPosition(movement.position);\n   * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n   *\n   *"
  },
  {
    "className": "Scene",
    "methodName": "pick",
    "description": "Returns an object with a <code>primitive</code> property that contains the first (top) primitive in the scene",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On mouse over, color the feature yellow.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.Cesium3DTileFeature) {\n *         feature.color = Cesium.Color.YELLOW;\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "pickAsync",
    "description": "Performs the same operation as Scene.pick but asynchonosly without blocking the main render thread.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On mouse over, color the feature yellow.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pickAsync(movement.endPosition).then(function(feature) {\n *        if (feature instanceof Cesium.Cesium3DTileFeature) {\n *            feature.color = Cesium.Color.YELLOW;\n *        }\n *     });\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "pickVoxel",
    "description": "Returns a {@link VoxelCell} for the voxel sample rendered at a particular window coordinate,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* On left click, report the value of the \"color\" property at that voxel sample.\n * handler.setInputAction(function(movement) {\n *   const voxelCell = scene.pickVoxel(movement.position);\n *   if (defined(voxelCell)) {\n *     console.log(voxelCell.getProperty(\"color\"));\n *   }\n * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "drillPick",
    "description": "Returns a list of objects, each containing a <code>primitive</code> property, for all primitives at",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const pickedObjects = scene.drillPick(new Cesium.Cartesian2(100.0, 200.0));\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "sampleHeight",
    "description": "Returns the height of scene geometry at the given cartographic position or <code>undefined</code> if there was no",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const position = new Cesium.Cartographic(-1.31968, 0.698874);\n * const height = viewer.scene.sampleHeight(position);\n * console.log(height);\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "clampToHeight",
    "description": "Clamps the given cartesian position to the scene geometry along the geodetic surface normal. Returns the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Clamp an entity to the underlying scene geometry\n * const position = entity.position.getValue(Cesium.JulianDate.now());\n * entity.position = viewer.scene.clampToHeight(position);\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "sampleHeightMostDetailed",
    "description": "Initiates an asynchronous {@link Scene#sampleHeight} query for an array of {@link Cartographic} positions",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const positions = [\n *     new Cesium.Cartographic(-1.31968, 0.69887),\n *     new Cesium.Cartographic(-1.10489, 0.83923)\n * ];\n * const promise = viewer.scene.sampleHeightMostDetailed(positions);\n * promise.then(function(updatedPosition) {\n *     // positions[0].height and positions[1].height have been updated.\n *     // updatedPositions is just a reference to positions.\n * }\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "clampToHeightMostDetailed",
    "description": "Initiates an asynchronous {@link Scene#clampToHeight} query for an array of {@link Cartesian3} positions",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const cartesians = [\n *     entities[0].position.getValue(Cesium.JulianDate.now()),\n *     entities[1].position.getValue(Cesium.JulianDate.now())\n * ];\n * const promise = viewer.scene.clampToHeightMostDetailed(cartesians);\n * promise.then(function(updatedCartesians) {\n *     entities[0].position = updatedCartesians[0];\n *     entities[1].position = updatedCartesians[1];\n * }\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "cartesianToCanvasCoordinates",
    "description": "Transforms a position in cartesian coordinates to canvas coordinates.  This is commonly used to place an",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Output the canvas position of longitude/latitude (0, 0) every time the mouse moves.\n * const scene = widget.scene;\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(scene.cartesianToCanvasCoordinates(position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);"
  },
  {
    "className": "Scene",
    "methodName": "setTerrain",
    "description": "Update the terrain providing surface geometry for the globe.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Use Cesium World Terrain\n * scene.setTerrain(Cesium.Terrain.fromWorldTerrain());\n *\n *"
  },
  {
    "className": "Scene",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene = scene && scene.destroy();\n *\n *"
  },
  {
    "className": "SceneTransforms",
    "methodName": "worldToWindowCoordinates",
    "description": "Transforms a position in world (WGS84 or alternative ellipsoid) coordinates to window coordinates.  This is commonly used to place an",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.worldToWindowCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);"
  },
  {
    "className": "SceneTransforms",
    "methodName": "worldToDrawingBufferCoordinates",
    "description": "Transforms a position in world coordinates to drawing buffer coordinates.  This may produce different",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.worldToDrawingBufferCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);"
  },
  {
    "className": "SceneTransitioner",
    "methodName": "destroy",
    "description": "Once an object is destroyed, it should not be used; calling any function other than",
    "parameters": [],
    "returnType": "unknown",
    "example": "* transitioner = transitioner && transitioner.destroy();"
  },
  {
    "className": "ScreenSpaceCameraController",
    "methodName": "maximumTiltAngle",
    "description": "The angle, relative to the ellipsoid normal, restricting the maximum amount that the user can tilt the camera. If <code>undefined</code>, the angle of the camera tilt is unrestricted.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Prevent the camera from tilting below the ellipsoid surface\n   * viewer.scene.screenSpaceCameraController.maximumTiltAngle = Math.PI / 2.0;"
  },
  {
    "className": "ScreenSpaceCameraController",
    "methodName": "destroy",
    "description": "Removes mouse listeners held by this object.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* controller = controller && controller.destroy();\n *\n *"
  },
  {
    "className": "SingleTileImageryProvider",
    "methodName": "fromUrl",
    "description": "Creates a provider for a single, top-level imagery tile.  The single image is assumed to use a",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const provider = await SingleTileImageryProvider.fromUrl(\"https://yoururl.com/image.png\");"
  },
  {
    "className": "SkyAtmosphere",
    "methodName": "SkyAtmosphere",
    "description": "An atmosphere drawn around the limb of the provided ellipsoid. Based on",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.skyAtmosphere = new Cesium.SkyAtmosphere();\n *\n *"
  },
  {
    "className": "SkyAtmosphere",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();\n *\n *"
  },
  {
    "className": "SkyBox",
    "methodName": "SkyBox",
    "description": "A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.skyBox = new Cesium.SkyBox({\n *   sources : {\n *     positiveX : 'skybox_px.png',\n *     negativeX : 'skybox_nx.png',\n *     positiveY : 'skybox_py.png',\n *     negativeY : 'skybox_ny.png',\n *     positiveZ : 'skybox_pz.png',\n *     negativeZ : 'skybox_nz.png'\n *   }\n * });\n *\n *"
  },
  {
    "className": "SkyBox",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* skyBox = skyBox && skyBox.destroy();\n *\n *"
  },
  {
    "className": "SkyBox",
    "methodName": "createEarthSkyBox",
    "description": "Creates a skybox instance with the default starmap for the Earth.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* viewer.scene.skyBox = Cesium.SkyBox.createEarthSkyBox();"
  },
  {
    "className": "Sun",
    "methodName": "Sun",
    "description": "Draws a sun billboard.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.sun = new Cesium.Sun();\n *\n *"
  },
  {
    "className": "Sun",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* sun = sun && sun.destroy();\n *\n *"
  },
  {
    "className": "Terrain",
    "methodName": "Terrain",
    "description": "A helper to manage async operations of a terrain provider.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   terrain: new Cesium.Terrain(Cesium.CesiumTerrainProvider.fromUrl(\"https://myTestTerrain.com\"));\n * });\n *\n *"
  },
  {
    "className": "Terrain",
    "methodName": "fromWorldTerrain",
    "description": "Creates a {@link Terrain} instance for {@link https://cesium.com/content/#cesium-world-terrain|Cesium World Terrain}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Cesium World Terrain with default settings\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   terrain: Cesium.Terrain.fromWorldTerrain()\n * });\n *\n *"
  },
  {
    "className": "Terrain",
    "methodName": "fromWorldBathymetry",
    "description": "Creates a {@link Terrain} instance for {@link https://cesium.com/content/#cesium-world-bathymetry|Cesium World Bathymetry}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Cesium World Bathymetry with default settings\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   terrain: Cesium.Terrain.fromWorldBathymetry)\n * });\n *\n *"
  },
  {
    "className": "TileMapServiceImageryProvider",
    "methodName": "TileMapServiceImageryProvider",
    "description": "<div class=\"notice\">",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const tms = await Cesium.TileMapServiceImageryProvider.fromUrl(\n *    \"../images/cesium_maptiler/Cesium_Logo_Color\", {\n *      fileExtension: 'png',\n *      maximumLevel: 4,\n *      rectangle: new Cesium.Rectangle(\n *        Cesium.Math.toRadians(-120.0),\n *        Cesium.Math.toRadians(20.0),\n *        Cesium.Math.toRadians(-60.0),\n *        Cesium.Math.toRadians(40.0))\n * });"
  },
  {
    "className": "TileMapServiceImageryProvider",
    "methodName": "fromUrl",
    "description": "Creates a TileMapServiceImageryProvider from the specified url.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const tms = await Cesium.TileMapServiceImageryProvider.fromUrl(\n *    '../images/cesium_maptiler/Cesium_Logo_Color', {\n *      fileExtension: 'png',\n *      maximumLevel: 4,\n *      rectangle: new Cesium.Rectangle(\n *        Cesium.Math.toRadians(-120.0),\n *        Cesium.Math.toRadians(20.0),\n *        Cesium.Math.toRadians(-60.0),\n *        Cesium.Math.toRadians(40.0))\n * });\n *\n *"
  },
  {
    "className": "TimeDynamicPointCloud",
    "methodName": "style",
    "description": "The style, defined using the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointCloud.style = new Cesium.Cesium3DTileStyle({\n   *    color : {\n   *        conditions : [\n   *            ['${Classification} === 0', 'color(\"purple\", 0.5)'],\n   *            ['${Classification} === 1', 'color(\"red\")'],\n   *            ['true', '${COLOR}']\n   *        ]\n   *    },\n   *    show : '${Classification} !== 2'\n   * });\n   *\n   *"
  },
  {
    "className": "TimeDynamicPointCloud",
    "methodName": "frameFailed",
    "description": "The event fired to indicate that a frame failed to load. A frame may fail to load if the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointCloud.frameFailed.addEventListener(function(error) {\n   *     console.log(`An error occurred loading frame: ${error.uri}`);\n   *     console.log(`Error: ${error.message}`);\n   * });"
  },
  {
    "className": "TimeDynamicPointCloud",
    "methodName": "frameChanged",
    "description": "The event fired to indicate that a new frame was rendered.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointCloud.frameChanged.addEventListener(function(timeDynamicPointCloud) {\n   *     viewer.camera.viewBoundingSphere(timeDynamicPointCloud.boundingSphere);\n   * });"
  },
  {
    "className": "TimeDynamicPointCloud",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* pointCloud = pointCloud && pointCloud.destroy();\n *\n *"
  },
  {
    "className": "TweenCollection",
    "methodName": "get",
    "description": "Returns the tween in the collection at the specified index.  Indices are zero-based",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Output the duration of all the tweens in the collection.\n * const tweens = scene.tweens;\n * const length = tweens.length;\n * for (let i = 0; i < length; ++i) {\n *   console.log(tweens.get(i).duration);\n * }"
  },
  {
    "className": "UrlTemplateImageryProvider",
    "methodName": "UrlTemplateImageryProvider",
    "description": "Provides imagery by requesting tiles using a specified URL template.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Access Natural Earth II imagery, which uses a TMS tiling scheme and Geographic (EPSG:4326) project\n * const tms = new Cesium.UrlTemplateImageryProvider({\n *     url : Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII') + '/{z}/{x}/{reverseY}.jpg',\n *     tilingScheme : new Cesium.GeographicTilingScheme(),\n *     maximumLevel : 5\n * });\n * // Access the CartoDB Positron basemap, which uses an OpenStreetMap-like tiling scheme.\n * const positron = new Cesium.UrlTemplateImageryProvider({\n *     url : 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',\n *     credit : 'Map tiles by CartoDB, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'\n * });\n * // Access a Web Map Service (WMS) server.\n * const wms = new Cesium.UrlTemplateImageryProvider({\n *    url : 'https://services.ga.gov.au/gis/services/NM_Hydrology_and_Marine_Points/MapServer/WMSServer?' +\n *          'tiled=true&transparent=true&format=image%2Fpng&exceptions=application%2Fvnd.ogc.se_xml&' +\n *          'styles=&service=WMS&version=1.3.0&request=GetMap&' +\n *          'layers=Bores&crs=EPSG%3A3857&' +\n *          'bbox={westProjected}%2C{southProjected}%2C{eastProjected}%2C{northProjected}&' +\n *          'width=256&height=256',\n *    rectangle : Cesium.Rectangle.fromDegrees(95.0, -55.0, 170.0, -1.0)  // From GetCapabilities EX_GeographicBoundingBox\n * });\n * // Using custom tags in your template url.\n * const custom = new Cesium.UrlTemplateImageryProvider({\n *    url : 'https://yoururl/{Time}/{z}/{y}/{x}.png',\n *    customTags : {\n *        Time: function(imageryProvider, x, y, level) {\n *            return '20171231'\n *        }\n *    }\n * });\n *\n *"
  },
  {
    "className": "ViewportQuad",
    "methodName": "ViewportQuad",
    "description": "A viewport aligned quad.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewportQuad = new Cesium.ViewportQuad(new Cesium.BoundingRectangle(0, 0, 80, 40));\n * viewportQuad.material.uniforms.color = new Cesium.Color(1.0, 0.0, 0.0, 1.0);"
  },
  {
    "className": "ViewportQuad",
    "methodName": "rectangle",
    "description": "The BoundingRectangle defining the quad's position within the viewport.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* viewportQuad.rectangle = new Cesium.BoundingRectangle(0, 0, 80, 40);"
  },
  {
    "className": "ViewportQuad",
    "methodName": "material",
    "description": "The surface appearance of the viewport quad.  This can be one of several built-in {@link Material} objects or a custom material, scripted with",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // 1. Change the color of the default material to yellow\n   * viewportQuad.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);\n   *\n   * // 2. Change material to horizontal stripes\n   * viewportQuad.material = Cesium.Material.fromType(Cesium.Material.StripeType);\n   *\n   *"
  },
  {
    "className": "ViewportQuad",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* quad = quad && quad.destroy();\n *\n *"
  },
  {
    "className": "VoxelBoundsCollection",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelBounds = voxelBounds && voxelBounds.destroy();\n *\n *"
  },
  {
    "className": "VoxelCell",
    "methodName": "VoxelCell",
    "description": "A cell from a {@link VoxelPrimitive}.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // On left click, display all the properties for a voxel cell in the console log.\n * handler.setInputAction(function(movement) {\n *   const voxelCell = scene.pickVoxel(movement.position);\n *   if (voxelCell instanceof Cesium.VoxelCell) {\n *     const propertyIds = voxelCell.getPropertyIds();\n *     const length = propertyIds.length;\n *     for (let i = 0; i < length; ++i) {\n *       const propertyId = propertyIds[i];\n *       console.log(`{propertyId}: ${voxelCell.getProperty(propertyId)}`);\n *     }\n *   }\n * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n *\n *"
  },
  {
    "className": "VoxelCell",
    "methodName": "getProperty",
    "description": "Returns a copy of the value of the metadata in the cell with the given name.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Display all the properties for a voxel cell in the console log.\n * const names = voxelCell.getNames();\n * for (let i = 0; i < names.length; ++i) {\n *   const name = names[i];\n *   console.log(`{name}: ${voxelCell.getProperty(name)}`);\n * }"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "tileLoad",
    "description": "The event fired to indicate that a tile's content was loaded.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.tileLoad.addEventListener(function() {\n   *     console.log('A tile was loaded.');\n   * });"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "tileVisible",
    "description": "This event fires once for each visible tile in a frame.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.tileVisible.addEventListener(function() {\n   *     console.log('A tile is visible.');\n   * });\n   *"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "tileFailed",
    "description": "The event fired to indicate that a tile's content failed to load.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.tileFailed.addEventListener(function() {\n   *     console.log('An error occurred loading tile.');\n   * });"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "tileUnload",
    "description": "The event fired to indicate that a tile's content was unloaded.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.tileUnload.addEventListener(function() {\n   *     console.log('A tile was unloaded from the cache.');\n   * });\n   *"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "loadProgress",
    "description": "The event fired to indicate progress of loading new tiles. This event is fired when a new tile",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.loadProgress.addEventListener(function(numberOfPendingRequests, numberOfTilesProcessing) {\n   *     if ((numberOfPendingRequests === 0) && (numberOfTilesProcessing === 0)) {\n   *         console.log('Finished loading');\n   *         return;\n   *     }\n   *\n   *     console.log(`Loading: requests: ${numberOfPendingRequests}, processing: ${numberOfTilesProcessing}`);\n   * });"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "allTilesLoaded",
    "description": "The event fired to indicate that all tiles that meet the screen space error this frame are loaded. The voxel",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.allTilesLoaded.addEventListener(function() {\n   *     console.log('All tiles are loaded');\n   * });"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "initialTilesLoaded",
    "description": "The event fired to indicate that all tiles that meet the screen space error this frame are loaded. This event",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive.initialTilesLoaded.addEventListener(function() {\n   *     console.log('Initial tiles are loaded');\n   * });\n   *\n   *"
  },
  {
    "className": "VoxelPrimitive",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelPrimitive = voxelPrimitive && voxelPrimitive.destroy();"
  },
  {
    "className": "VoxelTraversal",
    "methodName": "destroy",
    "description": "Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic",
    "parameters": [],
    "returnType": "unknown",
    "example": "* voxelTraversal = voxelTraversal && voxelTraversal.destroy();"
  },
  {
    "className": "WebMapServiceImageryProvider",
    "methodName": "WebMapServiceImageryProvider",
    "description": "Provides tiled imagery hosted by a Web Map Service (WMS) server.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // WMS servers operated by the US government https://apps.nationalmap.gov/services/\n * const provider = new Cesium.WebMapServiceImageryProvider({\n *     url : 'https://basemap.nationalmap.gov:443/arcgis/services/USGSHydroCached/MapServer/WMSServer',\n *     layers : '0',\n *     proxy: new Cesium.DefaultProxy('/proxy/')\n * });\n * const imageryLayer = new Cesium.ImageryLayer(provider);\n * viewer.imageryLayers.add(imageryLayer);"
  },
  {
    "className": "WebMapTileServiceImageryProvider",
    "methodName": "WebMapTileServiceImageryProvider",
    "description": "Provides tiled imagery served by {@link http://www.opengeospatial.org/standards/wmts|WMTS 1.0.0} compliant servers.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Example 1. USGS shaded relief tiles (KVP)\n * const shadedRelief1 = new Cesium.WebMapTileServiceImageryProvider({\n *     url : 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS',\n *     layer : 'USGSShadedReliefOnly',\n *     style : 'default',\n *     format : 'image/jpeg',\n *     tileMatrixSetID : 'default028mm',\n *     // tileMatrixLabels : ['default028mm:0', 'default028mm:1', 'default028mm:2' ...],\n *     maximumLevel: 19,\n *     credit : new Cesium.Credit('U. S. Geological Survey')\n * });\n * viewer.imageryLayers.addImageryProvider(shadedRelief1);\n *\n *"
  },
  {
    "className": "createElevationBandMaterial",
    "methodName": "createElevationBandMaterial",
    "description": "Creates a {@link Material} that combines multiple layers of color/gradient bands and maps them to terrain heights.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.globe.material = Cesium.createElevationBandMaterial({\n *     scene : scene,\n *     layers : [{\n *         entries : [{\n *             height : 4200.0,\n *             color : new Cesium.Color(0.0, 0.0, 0.0, 1.0)\n *         }, {\n *             height : 8848.0,\n *             color : new Cesium.Color(1.0, 1.0, 1.0, 1.0)\n *         }],\n *         extendDownwards : true,\n *         extendUpwards : true,\n *     }, {\n *         entries : [{\n *             height : 7000.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }, {\n *             height : 7100.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }]\n *     }]\n * });"
  },
  {
    "className": "createGooglePhotorealistic3DTileset",
    "methodName": "createGooglePhotorealistic3DTileset",
    "description": "Creates a {@link Cesium3DTileset} instance for the Google Photorealistic 3D",
    "parameters": [],
    "returnType": "unknown",
    "example": "* const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   geocoder: Cesium.IonGeocodeProviderType.GOOGLE\n * });\n *\n * try {\n *   const tileset = await Cesium.createGooglePhotorealistic3DTileset({\n *      onlyUsingWithGoogleGeocoder: true,\n *   });\n *   viewer.scene.primitives.add(tileset));\n * } catch (error) {\n *   console.log(`Error creating tileset: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "createOsmBuildingsAsync",
    "methodName": "createOsmBuildingsAsync",
    "description": "Creates a {@link Cesium3DTileset} instance for the",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create Cesium OSM Buildings with default styling\n * const viewer = new Cesium.Viewer(\"cesiumContainer\");\n * try {\n *   const tileset = await Cesium.createOsmBuildingsAsync();\n *   viewer.scene.primitives.add(tileset));\n * } catch (error) {\n *   console.log(`Error creating tileset: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "createTangentSpaceDebugPrimitive",
    "methodName": "createTangentSpaceDebugPrimitive",
    "description": "Creates a {@link Primitive} to visualize well-known vector vertex attributes:",
    "parameters": [],
    "returnType": "unknown",
    "example": "* scene.primitives.add(Cesium.createTangentSpaceDebugPrimitive({\n *    geometry : instance.geometry,\n *    length : 100000.0,\n *    modelMatrix : instance.modelMatrix\n * }));"
  },
  {
    "className": "createWorldImageryAsync",
    "methodName": "createWorldImageryAsync",
    "description": "Creates an {@link IonImageryProvider} instance for ion's default global base imagery layer, currently Bing Maps.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // Create a Cesium World Imagery base layer with default settings\n * try {\n *   const imageryProvider = await Cesium.createWorldImageryAsync();\n * } catch (error) {\n *   console.log(`There was an error creating world imagery: ${error}`);\n * }\n *\n *"
  },
  {
    "className": "CesiumWidget",
    "methodName": "CesiumWidget",
    "description": "A widget containing a Cesium scene.",
    "parameters": [],
    "returnType": "unknown",
    "example": "* // For each example, include a link to CesiumWidget.css stylesheet in HTML head,\n * // and in the body, include: <div id=\"cesiumContainer\"></div>\n *\n * // Widget with no terrain and default Bing Maps imagery provider.\n * const widget = new Cesium.CesiumWidget(\"cesiumContainer\");\n *\n * // Widget with ion imagery and Cesium World Terrain.\n * const widget2 = new Cesium.CesiumWidget(\"cesiumContainer\", {\n *     baseLayer: Cesium.ImageryLayer.fromWorldTerrain(),\n *     terrain: Cesium.Terrain.fromWorldTerrain()\n *     skyBox: new Cesium.SkyBox({\n *       sources: {\n *         positiveX: \"stars/TychoSkymapII.t3_08192x04096_80_px.jpg\",\n *         negativeX: \"stars/TychoSkymapII.t3_08192x04096_80_mx.jpg\",\n *         positiveY: \"stars/TychoSkymapII.t3_08192x04096_80_py.jpg\",\n *         negativeY: \"stars/TychoSkymapII.t3_08192x04096_80_my.jpg\",\n *         positiveZ: \"stars/TychoSkymapII.t3_08192x04096_80_pz.jpg\",\n *         negativeZ: \"stars/TychoSkymapII.t3_08192x04096_80_mz.jpg\"\n *       }\n *     }),\n *     // Show Columbus View map with Web Mercator projection\n *     sceneMode: Cesium.SceneMode.COLUMBUS_VIEW,\n *     mapProjection: new Cesium.WebMercatorProjection()\n * });"
  },
  {
    "className": "createTaskProcessorWorker",
    "methodName": "createTaskProcessorWorker",
    "description": "Creates an adapter function to allow a calculation function to operate as a Web Worker,",
    "parameters": [],
    "returnType": "unknown",
    "example": "* function doCalculation(parameters, transferableObjects) {\n *   // calculate some result using the inputs in parameters\n *   return result;\n * }\n *\n * return Cesium.createTaskProcessorWorker(doCalculation);\n * // the resulting function is compatible with TaskProcessor\n *\n *"
  }
]